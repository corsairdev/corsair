---
title: Create Your Own Plugin
description: A comprehensive guide to building custom plugins for Corsair
---

This guide walks you through creating a custom plugin for Corsair. We'll explain the core types and structure you need to understand, then show you how to put it all together.

## Core Types

### PluginOptions

`PluginOptions` defines the configuration for your plugin, including authentication type, hooks, and error handlers.

```ts
import type { PickAuth } from '../../core/constants';
import type { CorsairErrorHandler } from '../../core/errors';

export type YourPluginOptions = {
  authType?: PickAuth<'api_key' | 'oauth_2'>;
  key?: string;
  hooks?: InternalYourPlugin['hooks'];
  webhookHooks?: InternalYourPlugin['webhookHooks'];
  errorHandlers?: CorsairErrorHandler;
};
```

### CorsairPluginContext

`CorsairPluginContext` is the context type that your endpoints and webhooks receive. It provides access to the database, authentication key, and other plugin services.

```ts
import type { CorsairPluginContext } from '../../core';

export type YourPluginContext = CorsairPluginContext<
  typeof YourPluginSchema,
  YourPluginOptions
>;
```

The context provides:
- `ctx.key` - The resolved authentication key
- `ctx.db` - Typed database clients for your entities
- `ctx.endpoints` - Bound endpoints for calling other endpoints
- `ctx.database` - Raw database access
- `ctx.$getAccountId()` - Get the account ID for this integration
- `ctx.tenantId` - Tenant ID (for multi-tenancy)
- `ctx.options` - Plugin-specific options
- `ctx.keys` - Key manager (if authType is set)

### KeyBuilderContext

`KeyBuilderContext` is used in the `keyBuilder` function to retrieve authentication credentials. It's a discriminated union based on the auth type.

```ts
import type { KeyBuilderContext } from '../../core';

export type YourPluginKeyBuilderContext = KeyBuilderContext<YourPluginOptions>;
```

### CorsairEndpoint

`CorsairEndpoint` is the type for individual endpoints. It takes three type parameters: the context type, input type, and output type.

```ts
import type { CorsairEndpoint } from '../../core';

type YourPluginEndpoint<
  K extends keyof YourPluginEndpointOutputs,
  Input,
> = CorsairEndpoint<YourPluginContext, Input, YourPluginEndpointOutputs[K]>;
```

### Defining Endpoints

Define your endpoints as a type mapping endpoint names to `CorsairEndpoint` types:

```ts
export type YourPluginEndpoints = {
  entitiesGet: YourPluginEndpoint<'entitiesGet', { id: string }>;
  entitiesList: YourPluginEndpoint<'entitiesList', { limit?: number; cursor?: string }>;
  entitiesCreate: YourPluginEndpoint<'entitiesCreate', { name: string }>;
};
```

### Implementing Endpoints

Each endpoint is an async function that receives `(ctx, input)` and returns the typed output. Here's a minimal example:

```ts
import type { YourPluginEndpoints } from '..';
import type { YourPluginEndpointOutputs } from './types';

export const get: YourPluginEndpoints['entitiesGet'] = async (ctx, input) => {
  // Your API call logic here
  const result: YourPluginEndpointOutputs['entitiesGet'] = await fetch(...);

  // Optionally save to database
  if (result && ctx.db.entities) {
    try {
      await ctx.db.entities.upsertByEntityId(result.id, {
        ...result,
        createdAt: new Date(),
      });
    } catch (error) {
      console.warn('Failed to save entity to database:', error);
    }
  }

  return result;
};
```

### Nested Endpoints

You can organize endpoints into nested structures for better organization. This creates a namespace like `plugin.entities.get()` instead of `plugin.entitiesGet()`.

```ts
const yourPluginEndpointsNested = {
  entities: {
    get: Entities.get,
    list: Entities.list,
    create: Entities.create,
  },
} as const;
```

### CorsairWebhook

`CorsairWebhook` is the type for webhook handlers. It takes three type parameters: the context type, payload type, and output type.

```ts
import type { CorsairWebhook } from '../../core';

type YourPluginWebhook<
  K extends keyof YourPluginWebhookOutputs,
  TEvent,
> = CorsairWebhook<
  YourPluginContext,
  YourPluginWebhookPayload<TEvent>,
  YourPluginWebhookOutputs[K]
>;
```

### Defining Webhooks

Define your webhooks as a type mapping webhook names to `CorsairWebhook` types:

```ts
export type YourPluginWebhooks = {
  entityCreated: YourPluginWebhook<'entityCreated', EntityCreatedEvent>;
  entityUpdated: YourPluginWebhook<'entityUpdated', EntityUpdatedEvent>;
};
```

### Implementing Webhooks

Each webhook has a `match` function and a `handler` function:

```ts
import type { YourPluginWebhooks } from '..';

export const created: YourPluginWebhooks['entityCreated'] = {
  match: (request) => {
    const body = typeof request.body === 'string' 
      ? JSON.parse(request.body) 
      : request.body;
    
    return body.type === 'event_callback' && 
           body.event?.type === 'entity.created';
  },

  handler: async (ctx, request) => {
    const event = request.payload.type === 'event_callback' 
      ? request.payload.event 
      : null;

    if (!event || event.type !== 'entity.created') {
      return {
        success: true,
        data: undefined,
      };
    }

    // Save to database
    if (ctx.db.entities) {
      try {
        await ctx.db.entities.upsertByEntityId(event.entity.id, {
          ...event.entity,
          id: event.entity.id,
          createdAt: new Date(parseFloat(event.event_ts) * 1000),
        });
      } catch (error) {
        console.warn('Failed to save entity to database:', error);
      }
    }

    return {
      success: true,
      corsairEntityId: event.entity.id,
      tenantId: ctx.tenantId,
      data: event,
    };
  },
};
```

### Nested Webhooks

Similar to endpoints, you can organize webhooks into nested structures:

```ts
const yourPluginWebhooksNested = {
  entities: {
    created: EntityWebhooks.created,
    updated: EntityWebhooks.updated,
  },
} as const;
```

### Base Plugin Type

`BaseYourPlugin` is the base plugin type that extends `CorsairPlugin`:

```ts
import type { CorsairPlugin } from '../../core';
import type { AuthTypes } from '../../core/constants';

const defaultAuthType: AuthTypes = 'api_key';

export type BaseYourPlugin<T extends YourPluginOptions> = CorsairPlugin<
  'your-plugin', // Plugin ID - must be unique
  typeof YourPluginSchema,
  typeof yourPluginEndpointsNested,
  typeof yourPluginWebhooksNested,
  T,
  typeof defaultAuthType
>;
```

### Internal vs External Plugin Types

Corsair distinguishes between internal and external plugin types:

- **Internal Plugin**: Must provide options for all possible auth methods
- **External Plugin**: Only needs to provide options for the auth method the user selected

```ts
export type InternalYourPlugin = BaseYourPlugin<YourPluginOptions>;
export type ExternalYourPlugin<T extends YourPluginOptions> = BaseYourPlugin<T>;
```

### Plugin Factory Function

The plugin factory function creates and returns your plugin instance:

```ts
export function yourPlugin<const T extends YourPluginOptions>(
  incomingOptions: YourPluginOptions & T = {} as YourPluginOptions & T,
): ExternalYourPlugin<T> {
  const options = {
    ...incomingOptions,
    authType: incomingOptions.authType ?? defaultAuthType,
  };

  return {
    id: 'your-plugin',
    schema: YourPluginSchema,
    options: options,
    hooks: options.hooks,
    webhookHooks: options.webhookHooks,
    endpoints: yourPluginEndpointsNested,
    webhooks: yourPluginWebhooksNested,
    pluginWebhookMatcher: (request) => {
      // Return true if this request should be handled by this plugin
      return false;
    },
    errorHandlers: options.errorHandlers,
    keyBuilder: async (ctx: YourPluginKeyBuilderContext) => {
      // See Advanced section for keyBuilder implementation
      if (options.key) {
        return options.key;
      }
      return '';
    },
  } satisfies InternalYourPlugin;
}
```

## Database Schema

Define your database entities using Zod schemas:

```ts title="schema/database.ts"
import z from 'zod';

export const YourEntity = z.object({
  id: z.string(),
  name: z.string().optional(),
  createdAt: z.coerce.date().optional(),
});

export type YourEntity = z.infer<typeof YourEntity>;
```

Export the schema:

```ts title="schema/index.ts"
import { YourEntity } from './database';

export const YourPluginSchema = {
  version: '1.0.0',
  entities: {
    entities: YourEntity,
  },
} as const;
```

## Complete Example

Here's a complete minimal plugin example:

```ts title="index.ts"
import type {
  CorsairEndpoint,
  CorsairPlugin,
  CorsairPluginContext,
  CorsairWebhook,
  KeyBuilderContext,
} from '../../core';
import type { AuthTypes, PickAuth } from '../../core/constants';
import { Entities } from './endpoints';
import type { YourPluginEndpointOutputs } from './endpoints/types';
import { YourPluginSchema } from './schema';
import { EntityWebhooks } from './webhooks';
import type {
  EntityCreatedEvent,
  YourPluginWebhookOutputs,
  YourPluginWebhookPayload,
} from './webhooks/types';

// Plugin Options
export type YourPluginOptions = {
  authType?: PickAuth<'api_key'>;
  key?: string;
};

// Context Types
export type YourPluginContext = CorsairPluginContext<
  typeof YourPluginSchema,
  YourPluginOptions
>;

export type YourPluginKeyBuilderContext = KeyBuilderContext<YourPluginOptions>;

// Endpoint Types
type YourPluginEndpoint<
  K extends keyof YourPluginEndpointOutputs,
  Input,
> = CorsairEndpoint<YourPluginContext, Input, YourPluginEndpointOutputs[K]>;

export type YourPluginEndpoints = {
  entitiesGet: YourPluginEndpoint<'entitiesGet', { id: string }>;
  entitiesList: YourPluginEndpoint<'entitiesList', { limit?: number }>;
};

// Webhook Types
type YourPluginWebhook<
  K extends keyof YourPluginWebhookOutputs,
  TEvent,
> = CorsairWebhook<
  YourPluginContext,
  YourPluginWebhookPayload<TEvent>,
  YourPluginWebhookOutputs[K]
>;

export type YourPluginWebhooks = {
  entityCreated: YourPluginWebhook<'entityCreated', EntityCreatedEvent>;
};

// Nested Structures
const yourPluginEndpointsNested = {
  entities: {
    get: Entities.get,
    list: Entities.list,
  },
} as const;

const yourPluginWebhooksNested = {
  entities: {
    created: EntityWebhooks.created,
  },
} as const;

// Plugin Factory
const defaultAuthType: AuthTypes = 'api_key';

export type BaseYourPlugin<T extends YourPluginOptions> = CorsairPlugin<
  'your-plugin',
  typeof YourPluginSchema,
  typeof yourPluginEndpointsNested,
  typeof yourPluginWebhooksNested,
  T,
  typeof defaultAuthType
>;

export type InternalYourPlugin = BaseYourPlugin<YourPluginOptions>;
export type ExternalYourPlugin<T extends YourPluginOptions> = BaseYourPlugin<T>;

export function yourPlugin<const T extends YourPluginOptions>(
  incomingOptions: YourPluginOptions & T = {} as YourPluginOptions & T,
): ExternalYourPlugin<T> {
  const options = {
    ...incomingOptions,
    authType: incomingOptions.authType ?? defaultAuthType,
  };

  return {
    id: 'your-plugin',
    schema: YourPluginSchema,
    options: options,
    endpoints: yourPluginEndpointsNested,
    webhooks: yourPluginWebhooksNested,
    pluginWebhookMatcher: () => false,
    keyBuilder: async (ctx: YourPluginKeyBuilderContext) => {
      if (options.key) return options.key;
      return '';
    },
  } satisfies InternalYourPlugin;
}
```

## Advanced Topics

### BindEndpoints and BindWebhooks

`BindEndpoints` and `BindWebhooks` are utility types that transform your flat endpoint/webhook type definitions into the nested structure used at runtime. You typically don't need to use these directly, but they're useful for type annotations:

```ts
import type { BindEndpoints, BindWebhooks } from '../../core';

export type YourPluginBoundEndpoints = BindEndpoints<YourPluginEndpoints>;
export type YourPluginBoundWebhooks = BindWebhooks<YourPluginWebhooks>;
```

These types are used internally by Corsair to provide type-safe access to endpoints and webhooks in the context.

### KeyBuilder Implementation

The `keyBuilder` function retrieves authentication credentials. It receives a `KeyBuilderContext` that narrows based on the auth type:

```ts
keyBuilder: async (ctx: YourPluginKeyBuilderContext) => {
  // If a static key is provided, use it
  if (options.key) {
    return options.key;
  }

  // Check ctx.authType to narrow ctx.keys to the correct key manager type
  if (ctx.authType === 'api_key') {
    // ctx.keys is narrowed to ApiKeyAccountKeyManager
    const res = await ctx.keys.getApiKey();

    if (!res) {
      throw new Error('API key not found');
    }

    return res;
  } else if (ctx.authType === 'oauth_2') {
    // ctx.keys is narrowed to OAuth2AccountKeyManager
    const res = await ctx.keys.getAccessToken();

    if (!res) {
      throw new Error('Access token not found');
    }

    return res;
  }

  throw new Error('No authentication method configured');
},
```

## File Organization

Here's a recommended directory structure for organizing your plugin:

```
packages/corsair/plugins/your-plugin/
├── index.ts                 # Main plugin definition
├── schema/
│   ├── database.ts          # Zod schemas for entities
│   └── index.ts             # Schema export
├── endpoints/
│   ├── index.ts             # Endpoint exports
│   ├── types.ts             # Endpoint type definitions
│   └── [resource].ts        # Individual endpoint implementations
├── webhooks/
│   ├── index.ts             # Webhook exports
│   ├── types.ts             # Webhook type definitions
│   └── [event].ts           # Individual webhook handlers
└── error-handlers.ts        # Error handling (optional)
```

### Endpoint Organization

Group related endpoints together:

```ts title="endpoints/entities.ts"
import type { YourPluginEndpoints } from '..';
import type { YourPluginEndpointOutputs } from './types';

export const get: YourPluginEndpoints['entitiesGet'] = async (ctx, input) => {
  // Implementation
};

export const list: YourPluginEndpoints['entitiesList'] = async (ctx, input) => {
  // Implementation
};
```

```ts title="endpoints/index.ts"
import { get, list } from './entities';

export const Entities = {
  get,
  list,
};

export * from './types';
```

### Webhook Organization

Similarly, group related webhooks:

```ts title="webhooks/entities.ts"
import type { YourPluginWebhooks } from '..';

export const created: YourPluginWebhooks['entityCreated'] = {
  match: (request) => { /* ... */ },
  handler: async (ctx, request) => { /* ... */ },
};
```

```ts title="webhooks/index.ts"
import { created } from './entities';

export const EntityWebhooks = {
  created,
};

export * from './types';
```

## Exporting Your Plugin

Add your plugin to the main plugins export file:

```ts title="packages/corsair/plugins/index.ts"
export {
  type YourPluginContext,
  type YourPluginEndpoints,
  type YourPluginOptions,
  type YourPluginWebhooks,
  yourPlugin,
} from './your-plugin';
```

## Next Steps

- Review the Slack plugin (`packages/corsair/plugins/slack/`) for a comprehensive example
- Check other plugins for simpler examples (Resend, PostHog)
- Refer to the core types in `packages/corsair/core/` for advanced usage
