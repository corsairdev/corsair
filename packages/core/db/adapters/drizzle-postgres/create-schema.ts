import type { DBAdapterSchemaCreation } from '../../adapter';
import type { DBFieldAttribute, DBFieldType } from '../../type';

function isValidIdentifier(id: string) {
	return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(id);
}

function toIdentifier(name: string) {
	// minimal sanitization for table names like "slack-member" (just in case)
	const cleaned = name.replace(/[^A-Za-z0-9_$]/g, '_');
	return isValidIdentifier(cleaned) ? cleaned : `_${cleaned}`;
}

function mapTypeToDrizzle(type: DBFieldType): { fn: string; isArray: boolean } {
	if (Array.isArray(type)) return { fn: 'text', isArray: false };
	if (type === 'string') return { fn: 'text', isArray: false };
	if (type === 'number') return { fn: 'integer', isArray: false };
	if (type === 'boolean') return { fn: 'boolean', isArray: false };
	if (type === 'date') return { fn: 'timestamp', isArray: false };
	if (type === 'json') return { fn: 'jsonb', isArray: false };
	if (type === 'string[]') return { fn: 'text', isArray: true };
	if (type === 'number[]') return { fn: 'integer', isArray: true };
	return { fn: 'text', isArray: false };
}

function onDeleteToDrizzle(onDelete?: string) {
	if (!onDelete) return undefined;
	// drizzle expects: 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default'
	return onDelete;
}

function renderColumn({
	propName,
	columnName,
	field,
	tableIdByModelName,
}: {
	propName: string;
	columnName: string;
	field: DBFieldAttribute;
	tableIdByModelName: Record<string, string>;
}) {
	// special-case createdAt/updatedAt for nice defaults
	if (propName === 'createdAt') {
		return `\t\t${propName}: timestamp('${columnName}', { withTimezone: true }).notNull().defaultNow(),`;
	}
	if (propName === 'updatedAt') {
		return `\t\t${propName}: timestamp('${columnName}', { withTimezone: true }).notNull().defaultNow().$onUpdate(() => new Date()),`;
	}

	const { fn, isArray } = mapTypeToDrizzle(field.type);

	let expr = `${fn}('${columnName}'${fn === 'timestamp' ? ', { withTimezone: true }' : ''})`;
	if (isArray) expr += '.array()';
	if (field.required) expr += '.notNull()';
	if (field.unique) expr += '.unique()';
	if (field.references) {
		const refModelName = field.references.model;
		const refTableId = tableIdByModelName[refModelName];
		const refField = field.references.field;
		if (refTableId) {
			const onDelete = onDeleteToDrizzle(field.references.onDelete);
			expr += `.references(() => ${refTableId}.${refField}${onDelete ? `, { onDelete: '${onDelete}' }` : ''})`;
		}
	}

	return `\t\t${propName}: ${expr},`;
}

/**
 * Generate a Drizzle Postgres schema file from a normalized Corsair DB schema.
 *
 * This is intentionally a *codegen* step (like Better Auth adapters). Migrations can then be created
 * by running drizzle-kit against the generated schema.
 */
export function createDrizzlePostgresSchemaFile(args: {
	schema: Record<string, { fields: Record<string, DBFieldAttribute> }>;
	path?: string;
}): DBAdapterSchemaCreation {
	const path = args.path ?? 'corsair/db/schema.ts';
	const schema = args.schema;

	// Build stable table identifiers by table modelName
	const tableIdByModelName: Record<string, string> = {};
	for (const modelName of Object.keys(schema)) {
		tableIdByModelName[modelName] = toIdentifier(modelName);
	}

	const importFns = new Set<string>([
		'pgTable',
		'text',
		'integer',
		'boolean',
		'timestamp',
		'jsonb',
	]);

	let code = `/* eslint-disable */\n`;
	code += `import { ${Array.from(importFns).sort().join(', ')} } from 'drizzle-orm/pg-core';\n\n`;
	code += `// This file is generated by Corsair. Do not edit by hand.\n\n`;

	for (const [modelName, table] of Object.entries(schema)) {
		const tableId = tableIdByModelName[modelName]!;

		// Ensure default fields exist (Better Auth-style implicit fields)
		const fields: Record<string, DBFieldAttribute> = {
			id: { type: 'string', required: true },
			createdAt: { type: 'date', required: true },
			updatedAt: { type: 'date', required: true },
			...table.fields,
		};

		code += `export const ${tableId} = pgTable('${modelName}', {\n`;
		code += `\t\tid: text('id').primaryKey(),\n`;

		// Render remaining columns (excluding id; createdAt/updatedAt handled specially by renderer)
		for (const [propName, field] of Object.entries(fields)) {
			if (propName === 'id') continue;
			const columnName = propName;
			code += `${renderColumn({
				propName,
				columnName,
				field,
				tableIdByModelName,
			})}\n`;
		}

		code += `});\n\n`;
	}

	return {
		path,
		code,
		overwrite: true,
	};
}
