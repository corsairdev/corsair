import { eventBus } from "../core/event-bus.js";
import { CorsairEvent } from "../types/events.js";
import type {
  QueryDetectedEvent,
  NewQueryAddedEvent,
  NewMutationAddedEvent,
  LLMAnalysisStartedEvent,
} from "../types/events.js";
import { generateStub } from "../generators/stub-generator.js";
import { generateQueryWithLLM } from "../generators/llm-generator.js";
import { writeFile, getQueryOutputPath } from "../writers/file-writer.js";
import type { Query, SchemaDefinition } from "../types/state.js";
import { stateMachine } from "../core/state-machine.js";
import { llm } from "../../../llm/index.js";
import { z } from "zod";
import { operationGeneratorPrompt } from "../../../llm/prompts/operation-generator.js";

/**
 * Query Generator Handler
 *
 * Listens to: QUERY_DETECTED, NEW_QUERY_ADDED, NEW_MUTATION_ADDED
 * Emits: GENERATION_STARTED, GENERATION_PROGRESS, GENERATION_COMPLETE, GENERATION_FAILED
 */
class QueryGenerator {
  private schema: SchemaDefinition = { tables: [] };

  // Define the schema for LLM response
  public llmResponseSchema = z.object({
    input_type: z
      .string()
      .describe(
        "The input type of the function. This will be added to the input_type of the operation. This input type is what your function will receive as input."
      ),
    function: z
      .string()
      .describe(
        "The actual logic of the function. This will be added to the handler of the operation. The response type will be inferred from the function."
      ),
    notes: z
      .string()
      .describe(
        "Any additional notes or instructions for the function that you will receive later as configuration rules."
      ),
  });

  constructor() {
    this.setupListeners();
  }

  private setupListeners() {
    eventBus.on(
      CorsairEvent.QUERY_DETECTED,
      this.handleQueryDetected.bind(this)
    );

    // eventBus.on(
    //   CorsairEvent.NEW_QUERY_ADDED,
    //   this.handleNewQueryAdded.bind(this)
    // );

    // eventBus.on(
    //   CorsairEvent.NEW_MUTATION_ADDED,
    //   this.handleNewMutationAdded.bind(this)
    // );

    eventBus.on(
      CorsairEvent.LLM_ANALYSIS_STARTED,
      this.handleLLMAnalysisStarted.bind(this)
    );
  }

  private async handleQueryDetected(data: QueryDetectedEvent) {
    const query: Query = {
      id: data.id,
      nlQuery: data.nlQuery,
      sourceFile: data.sourceFile,
      params: data.params,
      lineNumber: data.lineNumber,
      timestamp: Date.now(),
    };

    try {
      // Emit generation started
      eventBus.emit(CorsairEvent.GENERATION_STARTED, { queryId: query.id });

      // Step 1: Generate and write stub immediately
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Creating stub",
        percentage: 10,
      });

      const stubContent = generateStub(query);
      const outputPath = getQueryOutputPath(query.id);

      writeFile(outputPath, stubContent, { createDirectories: true });

      // Step 2: Generate actual query with LLM (stub for now)
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Generating query logic",
        percentage: 40,
        message: "Analyzing schema...",
      });

      await new Promise((resolve) => setTimeout(resolve, 300));

      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Generating query logic",
        percentage: 60,
        message: "Creating Drizzle query...",
      });

      const generatedQuery = await generateQueryWithLLM(query, this.schema);

      // Step 3: Write final query
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Writing files",
        percentage: 80,
      });

      const finalContent = `// Auto-generated by Corsair
// Query: "${query.nlQuery}"
// Source: ${query.sourceFile}:${query.lineNumber}

${generatedQuery.types}

${generatedQuery.queryCode}

export default ${generatedQuery.functionName};
`;

      writeFile(outputPath, finalContent, { overwrite: true });

      // Step 4: Complete
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Complete",
        percentage: 100,
      });

      eventBus.emit(CorsairEvent.GENERATION_COMPLETE, {
        queryId: query.id,
        outputPath,
        generatedFiles: [outputPath],
      });
    } catch (error) {
      eventBus.emit(CorsairEvent.GENERATION_FAILED, {
        queryId: query.id,
        error: error instanceof Error ? error.message : "Unknown error",
        code: "GENERATION_ERROR",
      });
    }
  }

  public updateSchema(schema: SchemaDefinition) {
    this.schema = schema;
  }

  // private async handleNewQueryAdded(data: NewQueryAddedEvent) {
  //   // Only process LLM for initial detection (no configurationRules)
  //   // User-submitted operations will be handled through LLM_ANALYSIS_STARTED event
  //   if (data.configurationRules === undefined) {
  //     await this.processWithLLM({
  //       operationType: "query",
  //       operationName: data.operationName,
  //       functionName: data.functionName,
  //       prompt: data.prompt,
  //       file: data.file,
  //       lineNumber: data.lineNumber,
  //       configurationRules: data.configurationRules,
  //     });
  //   }
  // }

  // private async handleNewMutationAdded(data: NewMutationAddedEvent) {
  //   // Only process LLM for initial detection (no configurationRules)
  //   // User-submitted operations will be handled through LLM_ANALYSIS_STARTED event
  //   if (data.configurationRules === undefined) {
  //     await this.processWithLLM({
  //       operationType: "mutation",
  //       operationName: data.operationName,
  //       functionName: data.functionName,
  //       prompt: data.prompt,
  //       file: data.file,
  //       lineNumber: data.lineNumber,
  //       configurationRules: data.configurationRules,
  //     });
  //   }
  // }

  private async processWithLLM(operation: {
    operationType: "query" | "mutation";
    operationName: string;
    functionName: string;
    prompt: string;
    file: string;
    lineNumber: number;
    configurationRules?: string;
  }) {
    const schema = stateMachine.getSchema();
    if (!schema) {
      throw new Error("Schema not found");
    }
    try {
      // Create a detailed prompt for the LLM
      const message = operationGeneratorPrompt({
        schema,
        type: operation.operationType,
        name: operation.operationName,
      });

      // Get the provider from environment variable or default to "openai"
      const provider = "openai";

      // Call the LLM
      const response = await llm({
        provider,
        prompt: `You are an expert TypeScript developer specializing in Corsair framework operations and Drizzle ORM. Your task is to generate high-quality, type-safe database operation handlers.

## Core Responsibilities
Generate the \`input_type\` Zod schema and \`handler\` function for Corsair queries and mutations that:
- Use Drizzle ORM patterns correctly
- Handle database relationships and joins properly
- Follow TypeScript and Corsair best practices
- Include proper error handling and validation
- Are performant and secure

## Corsair Operation Structure
Each operation has this structure:
\`\`\`typescript
const operation = createQuery<DatabaseContext>()({
  prompt: "natural language description",
  input_type: z.object({ /* Zod schema */ }),
  dependencies: { tables: [...], columns: [...] },
  handler: async (input, ctx) => {
    // Your generated code here
    return result;
  }
});
\`\`\`

## Drizzle ORM Patterns

### Basic Operations
\`\`\`typescript
// Select all
const items = await ctx.db.select().from(ctx.schema.tableName);

// Select with where
const item = await ctx.db
  .select()
  .from(ctx.schema.tableName)
  .where(drizzle.eq(ctx.schema.tableName.id, input.id))
  .limit(1);

// Insert
const [newItem] = await ctx.db
  .insert(ctx.schema.tableName)
  .values(input)
  .returning();

// Update
const [updatedItem] = await ctx.db
  .update(ctx.schema.tableName)
  .set(input)
  .where(drizzle.eq(ctx.schema.tableName.id, input.id))
  .returning();
\`\`\`

### Joins and Relationships
\`\`\`typescript
// Inner join
const results = await ctx.db
  .select({
    // Select specific fields
    itemId: ctx.schema.items.id,
    itemName: ctx.schema.items.name,
    relatedData: ctx.schema.related.data
  })
  .from(ctx.schema.items)
  .innerJoin(
    ctx.schema.related,
    drizzle.eq(ctx.schema.items.id, ctx.schema.related.item_id)
  )
  .where(drizzle.eq(ctx.schema.items.id, input.id));

// Complex joins with grouping
const albumWithArtists = await ctx.db
  .select({
    albumId: ctx.schema.albums.id,
    albumName: ctx.schema.albums.name,
    artist: {
      id: ctx.schema.artists.id,
      name: ctx.schema.artists.name,
    }
  })
  .from(ctx.schema.albums)
  .innerJoin(ctx.schema.album_artists, drizzle.eq(ctx.schema.albums.id, ctx.schema.album_artists.album_id))
  .innerJoin(ctx.schema.artists, drizzle.eq(ctx.schema.album_artists.artist_id, ctx.schema.artists.id))
  .where(drizzle.eq(ctx.schema.albums.id, input.id));
\`\`\`

### Search and Filtering
\`\`\`typescript
// Text search
const results = await ctx.db
  .select()
  .from(ctx.schema.tableName)
  .where(drizzle.ilike(ctx.schema.tableName.name, \`%\${input.query}%\`));

// Multiple conditions
const results = await ctx.db
  .select()
  .from(ctx.schema.tableName)
  .where(
    drizzle.and(
      drizzle.eq(ctx.schema.tableName.status, 'active'),
      drizzle.gte(ctx.schema.tableName.created_at, input.since)
    )
  );
\`\`\`

## Input Type Guidelines
- Use descriptive property names
- Include proper validation (min, max, optional, etc.)
- For IDs: \`z.string()\` or \`z.string().uuid()\`
- For search: \`z.string().min(1)\`
- For numbers: \`z.number().min(0)\` etc.
- For optional fields: \`z.string().optional()\`

## Error Handling Patterns
\`\`\`typescript
// Handle missing records
const [item] = await ctx.db.select()...;
if (!item) {
  return null; // or throw error depending on use case
}

// Handle array results
if (results.length === 0) {
  return []; // return empty array for lists
}
\`\`\`

## Performance Tips
- Use \`.limit(1)\` for single record queries
- Select only needed columns in joins
- Use appropriate indexes in where clauses
- Avoid N+1 queries by using joins

## Response Format
Return exactly this JSON structure:
{
  "input_type": "z.object({ id: z.string(), ... })",
  "function": "async (input, ctx) => { /* complete handler code */ }",
  "notes": "Additional implementation details or considerations"
}

The \`input_type\` should be a valid Zod schema string.
The \`function\` should be a complete async handler implementation.
The \`notes\` should explain any complex logic or important considerations.`,
        schema: this.llmResponseSchema,
        message,
      });

      if (response) {
        // Process successful LLM response
        eventBus.emit(CorsairEvent.LLM_ANALYSIS_COMPLETE, {
          operationName: operation.operationName,
          operationType: operation.operationType,
          response,
          operation,
        });
      } else {
        // Handle LLM failure
        eventBus.emit(CorsairEvent.LLM_ANALYSIS_FAILED, {
          operationName: operation.operationName,
          operationType: operation.operationType,
          error: "LLM analysis failed - no response received",
        });
      }
    } catch (error) {
      console.error("LLM processing error:", error);

      eventBus.emit(CorsairEvent.LLM_ANALYSIS_FAILED, {
        operationName: operation.operationName,
        operationType: operation.operationType,
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }

  private async handleLLMAnalysisStarted(data: LLMAnalysisStartedEvent) {
    // This handler should only process user-initiated LLM analysis from the state machine
    // Auto-detected operations are handled directly by handleNewQueryAdded/handleNewMutationAdded

    // Get the current operation from state machine when LLM analysis is requested
    const currentState = stateMachine.getCurrentState();
    const newOperation = currentState.context.newOperation;

    if (!newOperation) {
      console.warn("LLM analysis started but no operation found in state");
      return;
    }

    // Only process if this is a user-submitted operation (has configurationRules or from state machine)
    if (
      newOperation.configurationRules !== undefined ||
      currentState.state === "LLM_PROCESSING"
    ) {
      await this.processWithLLM({
        operationType: newOperation.operationType,
        operationName: newOperation.operationName,
        functionName: newOperation.functionName,
        prompt: newOperation.prompt,
        file: newOperation.file,
        lineNumber: newOperation.lineNumber,
        configurationRules: newOperation.configurationRules,
      });
    }
  }
}

// Initialize handler
export const queryGenerator = new QueryGenerator();
