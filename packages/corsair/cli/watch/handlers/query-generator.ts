import { eventBus } from "../core/event-bus.js";
import { CorsairEvent } from "../types/events.js";
import type { QueryDetectedEvent } from "../types/events.js";
import { generateStub } from "../generators/stub-generator.js";
import { generateQueryWithLLM } from "../generators/llm-generator.js";
import { writeFile, getQueryOutputPath } from "../writers/file-writer.js";
import type { Query, SchemaDefinition } from "../types/state.js";

/**
 * Query Generator Handler
 *
 * Listens to: QUERY_DETECTED
 * Emits: GENERATION_STARTED, GENERATION_PROGRESS, GENERATION_COMPLETE, GENERATION_FAILED
 */
class QueryGenerator {
  private schema: SchemaDefinition = { tables: [], relations: [] };

  constructor() {
    this.setupListeners();
  }

  private setupListeners() {
    eventBus.on(
      CorsairEvent.QUERY_DETECTED,
      this.handleQueryDetected.bind(this)
    );
  }

  private async handleQueryDetected(data: QueryDetectedEvent) {
    const query: Query = {
      id: data.id,
      nlQuery: data.nlQuery,
      sourceFile: data.sourceFile,
      params: data.params,
      lineNumber: data.lineNumber,
      timestamp: Date.now(),
    };

    try {
      // Emit generation started
      eventBus.emit(CorsairEvent.GENERATION_STARTED, { queryId: query.id });

      // Step 1: Generate and write stub immediately
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Creating stub",
        percentage: 10,
      });

      const stubContent = generateStub(query);
      const outputPath = getQueryOutputPath(query.id);

      writeFile(outputPath, stubContent, { createDirectories: true });

      // Step 2: Generate actual query with LLM (stub for now)
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Generating query logic",
        percentage: 40,
        message: "Analyzing schema...",
      });

      await new Promise((resolve) => setTimeout(resolve, 300));

      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Generating query logic",
        percentage: 60,
        message: "Creating Drizzle query...",
      });

      const generatedQuery = await generateQueryWithLLM(query, this.schema);

      // Step 3: Write final query
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Writing files",
        percentage: 80,
      });

      const finalContent = `// Auto-generated by Corsair
// Query: "${query.nlQuery}"
// Source: ${query.sourceFile}:${query.lineNumber}

${generatedQuery.types}

${generatedQuery.queryCode}

export default ${generatedQuery.functionName};
`;

      writeFile(outputPath, finalContent, { overwrite: true });

      // Step 4: Complete
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Complete",
        percentage: 100,
      });

      eventBus.emit(CorsairEvent.GENERATION_COMPLETE, {
        queryId: query.id,
        outputPath,
        generatedFiles: [outputPath],
      });
    } catch (error) {
      eventBus.emit(CorsairEvent.GENERATION_FAILED, {
        queryId: query.id,
        error: error instanceof Error ? error.message : "Unknown error",
        code: "GENERATION_ERROR",
      });
    }
  }

  public updateSchema(schema: SchemaDefinition) {
    this.schema = schema;
  }
}

// Initialize handler
export const queryGenerator = new QueryGenerator();
