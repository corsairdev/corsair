import { eventBus } from '../core/event-bus.js'
import { CorsairEvent } from '../types/events.js'
import type {
  QueryDetectedEvent,
  NewQueryAddedEvent,
  NewMutationAddedEvent,
  LLMAnalysisStartedEvent,
} from '../types/events.js'
import { generateStub } from '../generators/stub-generator.js'
import { generateQueryWithLLM } from '../generators/llm-generator.js'
import { fileWriteHandler } from './file-write-handler.js'
import type { Query, SchemaDefinition } from '../types/state.js'
import { stateMachine } from '../core/state-machine.js'
import { z } from 'zod'
import type { SchemaLoadedEvent, SchemaUpdatedEvent } from '../types/events.js'
import { promptAgent } from '../../../llm/agent/index.js'
import { promptBuilder } from '../../../llm/agent/prompts/prompt-builder.js'
import { kebabToCamelCase, toKebabCase } from '../../utils.js'
import { loadConfig, getResolvedPaths } from '../../config.js'

/**
 * Query Generator Handler
 *
 * Listens to: QUERY_DETECTED, NEW_QUERY_ADDED, NEW_MUTATION_ADDED
 * Emits: GENERATION_STARTED, GENERATION_PROGRESS, GENERATION_COMPLETE, GENERATION_FAILED
 */
class QueryGenerator {
  private schema: SchemaDefinition = { tables: [] }

  // Define the schema for LLM response
  public llmResponseSchema = z.object({
    input_type: z
      .string()
      .describe(
        'The input type of the function. This will be added to the input_type of the operation. This input type is what your function will receive as input.'
      ),
    output_type: z
      .string()
      .describe(
        'The expected TypeScript output type of the handler function, expressed as a type-level description (for example, an object or array shape).'
      ),
    function: z
      .string()
      .describe(
        'The actual logic of the function. This will be added to the handler of the operation. The response type will be inferred from the function.'
      ),
    notes: z
      .string()
      .describe(
        'Any additional notes or instructions for the function that you will receive later as configuration rules.'
      ),
    pseudocode: z
      .string()
      .describe(
        'High-level pseudocode describing what the function does, its inputs, outputs, and main steps.'
      ),
    function_name: z
      .string()
      .describe(
        'A concise, unique, kebab-case or camelCase function name suggestion suitable for naming a file.'
      ),
  })

  constructor() {
    this.setupListeners()
  }

  private setupListeners() {
    eventBus.on(CorsairEvent.SCHEMA_LOADED, (data: SchemaLoadedEvent) => {
      this.schema = data.schema
    })

    eventBus.on(CorsairEvent.SCHEMA_UPDATED, (data: SchemaUpdatedEvent) => {
      this.schema = data.newSchema
    })

    eventBus.on(
      CorsairEvent.QUERY_DETECTED,
      this.handleQueryDetected.bind(this)
    )

    // eventBus.on(
    //   CorsairEvent.NEW_QUERY_ADDED,
    //   this.handleNewQueryAdded.bind(this)
    // );

    // eventBus.on(
    //   CorsairEvent.NEW_MUTATION_ADDED,
    //   this.handleNewMutationAdded.bind(this)
    // );

    eventBus.on(
      CorsairEvent.LLM_ANALYSIS_STARTED,
      this.handleLLMAnalysisStarted.bind(this)
    )
  }

  private async handleQueryDetected(data: QueryDetectedEvent) {
    const writer = fileWriteHandler
    const query: Query = {
      id: data.id,
      nlQuery: data.nlQuery,
      sourceFile: data.sourceFile,
      params: data.params,
      lineNumber: data.lineNumber,
      timestamp: Date.now(),
    }

    try {
      // Emit generation started
      eventBus.emit(CorsairEvent.GENERATION_STARTED, { queryId: query.id })

      // Step 1: Generate and write stub immediately
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Creating stub',
        percentage: 10,
      })

      const stubContent = generateStub(query)
      const outputPath = writer.getQueryOutputPath(query.id)

      writer.writeFile(outputPath, stubContent, { createDirectories: true })

      // Step 2: Generate actual query with LLM (stub for now)
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Generating query logic',
        percentage: 40,
        message: 'Analyzing schema...',
      })

      await new Promise(resolve => setTimeout(resolve, 300))

      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Generating query logic',
        percentage: 60,
        message: 'Creating Drizzle query...',
      })

      const generatedQuery = await generateQueryWithLLM(query, this.schema)

      // Step 3: Write final query
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Writing files',
        percentage: 80,
      })

      const finalContent = `// Auto-generated by Corsair
// Query: "${query.nlQuery}"
// Source: ${query.sourceFile}:${query.lineNumber}

${generatedQuery.types}

${generatedQuery.queryCode}

export default ${generatedQuery.functionName};
`

      writer.writeFile(outputPath, finalContent, { overwrite: true })

      // Step 4: Complete
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Complete',
        percentage: 100,
      })

      eventBus.emit(CorsairEvent.GENERATION_COMPLETE, {
        queryId: query.id,
        outputPath,
        generatedFiles: [outputPath],
      })
    } catch (error) {
      eventBus.emit(CorsairEvent.GENERATION_FAILED, {
        queryId: query.id,
        error: error instanceof Error ? error.message : 'Unknown error',
        code: 'GENERATION_ERROR',
      })
    }
  }

  public updateSchema(schema: SchemaDefinition) {
    this.schema = schema
  }

  // private async handleNewQueryAdded(data: NewQueryAddedEvent) {
  //   // Only process LLM for initial detection (no configurationRules)
  //   // User-submitted operations will be handled through LLM_ANALYSIS_STARTED event
  //   if (data.configurationRules === undefined) {
  //     await this.processWithLLM({
  //       operationType: "query",
  //       operationName: data.operationName,
  //       functionName: data.functionName,
  //       prompt: data.prompt,
  //       file: data.file,
  //       lineNumber: data.lineNumber,
  //       configurationRules: data.configurationRules,
  //     });
  //   }
  // }

  // private async handleNewMutationAdded(data: NewMutationAddedEvent) {
  //   // Only process LLM for initial detection (no configurationRules)
  //   // User-submitted operations will be handled through LLM_ANALYSIS_STARTED event
  //   if (data.configurationRules === undefined) {
  //     await this.processWithLLM({
  //       operationType: "mutation",
  //       operationName: data.operationName,
  //       functionName: data.functionName,
  //       prompt: data.prompt,
  //       file: data.file,
  //       lineNumber: data.lineNumber,
  //       configurationRules: data.configurationRules,
  //     });
  //   }
  // }

  private async processWithLLM(operation: {
    operationType: 'query' | 'mutation'
    operationName: string
    functionName: string
    prompt: string
    file: string
    lineNumber: number
    configurationRules?: string
  }) {
    const schema = stateMachine.getSchema() || this.schema
    const cfg = loadConfig()

    const kebabName = toKebabCase(operation.operationName)
    const camelName = kebabToCamelCase(kebabName)
    const baseDir =
      operation.operationType === 'query'
        ? cfg.pathToCorsairFolder + '/queries'
        : cfg.pathToCorsairFolder + '/mutations'
    const rawPwd = `${baseDir}/${kebabName}.ts`
    const pwd = rawPwd.startsWith('./') ? rawPwd.slice(2) : rawPwd

    try {
      const prompt = promptBuilder({
        functionName: camelName,
        incomingSchema: schema as any,
        config: {
          dbType: cfg.dbType,
          framework: cfg.framework,
          operation: operation.operationType,
          orm: cfg.orm,
        },
        instructions: operation.configurationRules || operation.prompt,
      })

      const result = await promptAgent(pwd).generate({ prompt })

      eventBus.emit(CorsairEvent.LLM_ANALYSIS_COMPLETE, {
        operationName: operation.operationName,
        operationType: operation.operationType,
        response: {
          input_type: 'Generated by agent',
          output_type: 'Generated by agent',
          function: 'Generated by agent',
          notes: result.text || 'Agent completed generation',
          pseudocode: '',
          function_name: camelName,
        },
        operation,
        usage: result.usage ? {
          inputTokens: result.usage.inputTokens ?? 0,
          outputTokens: result.usage.outputTokens ?? 0,
          totalTokens: result.usage.totalTokens ?? 0,
        } : undefined,
      })
    } catch (error) {
      console.error('Agent processing error:', error)

      eventBus.emit(CorsairEvent.LLM_ANALYSIS_FAILED, {
        operationName: operation.operationName,
        operationType: operation.operationType,
        error: error instanceof Error ? error.message : 'Unknown error',
      })
    }
  }

  private async handleLLMAnalysisStarted(data: LLMAnalysisStartedEvent) {
    // This handler should only process user-initiated LLM analysis from the state machine
    // Auto-detected operations are handled directly by handleNewQueryAdded/handleNewMutationAdded

    // Get the current operation from state machine when LLM analysis is requested
    const currentState = stateMachine.getCurrentState()
    const newOperation = currentState.context.newOperation

    if (!newOperation) {
      console.warn('LLM analysis started but no operation found in state')
      return
    }

    // Only process if this is a user-submitted operation (has configurationRules or from state machine)
    if (
      newOperation.configurationRules !== undefined ||
      currentState.state === 'LLM_PROCESSING'
    ) {
      await this.processWithLLM({
        operationType: newOperation.operationType,
        operationName: newOperation.operationName,
        functionName: newOperation.functionName,
        prompt: newOperation.prompt,
        file: newOperation.file,
        lineNumber: newOperation.lineNumber,
        configurationRules: newOperation.configurationRules,
      })
    }
  }
}

// Initialize handler
export const queryGenerator = new QueryGenerator()
