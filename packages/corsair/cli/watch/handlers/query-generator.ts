import { eventBus } from "../core/event-bus.js";
import { CorsairEvent } from "../types/events.js";
import type {
  QueryDetectedEvent,
  NewQueryAddedEvent,
  NewMutationAddedEvent,
  LLMAnalysisStartedEvent,
} from "../types/events.js";
import { generateStub } from "../generators/stub-generator.js";
import { generateQueryWithLLM } from "../generators/llm-generator.js";
import { writeFile, getQueryOutputPath } from "../writers/file-writer.js";
import type { Query, SchemaDefinition } from "../types/state.js";
import { stateMachine } from "../core/state-machine.js";
import { llm } from "../../../llm/index.js";
import { z } from "zod";
import { operationGeneratorPrompt } from "../../../llm/prompts/operation-generator.js";

/**
 * Query Generator Handler
 *
 * Listens to: QUERY_DETECTED, NEW_QUERY_ADDED, NEW_MUTATION_ADDED
 * Emits: GENERATION_STARTED, GENERATION_PROGRESS, GENERATION_COMPLETE, GENERATION_FAILED
 */
class QueryGenerator {
  private schema: SchemaDefinition = { tables: [] };

  // Define the schema for LLM response
  public llmResponseSchema = z.object({
    input_type: z
      .string()
      .describe(
        "The input type of the function. This will be added to the input_type of the operation. This input type is what your function will receive as input."
      ),
    function: z
      .string()
      .describe(
        "The actual logic of the function. This will be added to the handler of the operation. The response type will be inferred from the function."
      ),
    notes: z
      .string()
      .describe(
        "Any additional notes or instructions for the function that you will receive later as configuration rules."
      ),
  });

  constructor() {
    this.setupListeners();
  }

  private setupListeners() {
    eventBus.on(
      CorsairEvent.QUERY_DETECTED,
      this.handleQueryDetected.bind(this)
    );

    // eventBus.on(
    //   CorsairEvent.NEW_QUERY_ADDED,
    //   this.handleNewQueryAdded.bind(this)
    // );

    // eventBus.on(
    //   CorsairEvent.NEW_MUTATION_ADDED,
    //   this.handleNewMutationAdded.bind(this)
    // );

    eventBus.on(
      CorsairEvent.LLM_ANALYSIS_STARTED,
      this.handleLLMAnalysisStarted.bind(this)
    );
  }

  private async handleQueryDetected(data: QueryDetectedEvent) {
    const query: Query = {
      id: data.id,
      nlQuery: data.nlQuery,
      sourceFile: data.sourceFile,
      params: data.params,
      lineNumber: data.lineNumber,
      timestamp: Date.now(),
    };

    try {
      // Emit generation started
      eventBus.emit(CorsairEvent.GENERATION_STARTED, { queryId: query.id });

      // Step 1: Generate and write stub immediately
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Creating stub",
        percentage: 10,
      });

      const stubContent = generateStub(query);
      const outputPath = getQueryOutputPath(query.id);

      writeFile(outputPath, stubContent, { createDirectories: true });

      // Step 2: Generate actual query with LLM (stub for now)
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Generating query logic",
        percentage: 40,
        message: "Analyzing schema...",
      });

      await new Promise((resolve) => setTimeout(resolve, 300));

      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Generating query logic",
        percentage: 60,
        message: "Creating Drizzle query...",
      });

      const generatedQuery = await generateQueryWithLLM(query, this.schema);

      // Step 3: Write final query
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Writing files",
        percentage: 80,
      });

      const finalContent = `// Auto-generated by Corsair
// Query: "${query.nlQuery}"
// Source: ${query.sourceFile}:${query.lineNumber}

${generatedQuery.types}

${generatedQuery.queryCode}

export default ${generatedQuery.functionName};
`;

      writeFile(outputPath, finalContent, { overwrite: true });

      // Step 4: Complete
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: "Complete",
        percentage: 100,
      });

      eventBus.emit(CorsairEvent.GENERATION_COMPLETE, {
        queryId: query.id,
        outputPath,
        generatedFiles: [outputPath],
      });
    } catch (error) {
      eventBus.emit(CorsairEvent.GENERATION_FAILED, {
        queryId: query.id,
        error: error instanceof Error ? error.message : "Unknown error",
        code: "GENERATION_ERROR",
      });
    }
  }

  public updateSchema(schema: SchemaDefinition) {
    this.schema = schema;
  }

  // private async handleNewQueryAdded(data: NewQueryAddedEvent) {
  //   // Only process LLM for initial detection (no configurationRules)
  //   // User-submitted operations will be handled through LLM_ANALYSIS_STARTED event
  //   if (data.configurationRules === undefined) {
  //     await this.processWithLLM({
  //       operationType: "query",
  //       operationName: data.operationName,
  //       functionName: data.functionName,
  //       prompt: data.prompt,
  //       file: data.file,
  //       lineNumber: data.lineNumber,
  //       configurationRules: data.configurationRules,
  //     });
  //   }
  // }

  // private async handleNewMutationAdded(data: NewMutationAddedEvent) {
  //   // Only process LLM for initial detection (no configurationRules)
  //   // User-submitted operations will be handled through LLM_ANALYSIS_STARTED event
  //   if (data.configurationRules === undefined) {
  //     await this.processWithLLM({
  //       operationType: "mutation",
  //       operationName: data.operationName,
  //       functionName: data.functionName,
  //       prompt: data.prompt,
  //       file: data.file,
  //       lineNumber: data.lineNumber,
  //       configurationRules: data.configurationRules,
  //     });
  //   }
  // }

  private async processWithLLM(operation: {
    operationType: "query" | "mutation";
    operationName: string;
    functionName: string;
    prompt: string;
    file: string;
    lineNumber: number;
    configurationRules?: string;
  }) {
    const schema = stateMachine.getSchema();
    if (!schema) {
      throw new Error("Schema not found");
    }
    try {
      // Create a detailed prompt for the LLM
      const message = operationGeneratorPrompt({
        schema,
        type: operation.operationType,
        name: operation.operationName,
      });

      // Get the provider from environment variable or default to "openai"
      const provider = "openai";

      // Call the LLM
      const response = await llm({
        provider,
        prompt: `You are a helpful assistant that analyzes Corsair operations and provides configuration suggestions.`,
        schema: this.llmResponseSchema,
        message,
      });

      if (response) {
        // Process successful LLM response
        eventBus.emit(CorsairEvent.LLM_ANALYSIS_COMPLETE, {
          operationName: operation.operationName,
          operationType: operation.operationType,
          response,
          operation,
        });
      } else {
        // Handle LLM failure
        eventBus.emit(CorsairEvent.LLM_ANALYSIS_FAILED, {
          operationName: operation.operationName,
          operationType: operation.operationType,
          error: "LLM analysis failed - no response received",
        });
      }
    } catch (error) {
      console.error("LLM processing error:", error);

      eventBus.emit(CorsairEvent.LLM_ANALYSIS_FAILED, {
        operationName: operation.operationName,
        operationType: operation.operationType,
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }

  private async handleLLMAnalysisStarted(data: LLMAnalysisStartedEvent) {
    // This handler should only process user-initiated LLM analysis from the state machine
    // Auto-detected operations are handled directly by handleNewQueryAdded/handleNewMutationAdded

    // Get the current operation from state machine when LLM analysis is requested
    const currentState = stateMachine.getCurrentState();
    const newOperation = currentState.context.newOperation;

    if (!newOperation) {
      console.warn("LLM analysis started but no operation found in state");
      return;
    }

    // Only process if this is a user-submitted operation (has configurationRules or from state machine)
    if (
      newOperation.configurationRules !== undefined ||
      currentState.state === "LLM_PROCESSING"
    ) {
      await this.processWithLLM({
        operationType: newOperation.operationType,
        operationName: newOperation.operationName,
        functionName: newOperation.functionName,
        prompt: newOperation.prompt,
        file: newOperation.file,
        lineNumber: newOperation.lineNumber,
        configurationRules: newOperation.configurationRules,
      });
    }
  }
}

// Initialize handler
export const queryGenerator = new QueryGenerator();
