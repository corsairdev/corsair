import axios from 'axios';
import { pick } from 'rambda';
import * as qs from 'qs';
import { generatePostgrestRequestHeaders, isArray, generatePostgrestFilterProperties } from '../util';
/**
 * Typeguard function that distinguishes PostgrestJsGetWithFetchParams object
 * @param o
 */
function isPostgrestJsGetWithFetchParams(o) {
    return o.fetch;
}
/**
 * Typeguard function that distinguishes PostgrestJsSelectParam object
 * @param o
 */
function isPostgrestJsSelectParam(o) {
    return !!o.identifier;
}
/**
 * Typeguard function that distinguishes PostgrestJsOrderParam object
 * @param o
 */
function isPostgrestJsOrderParam(o) {
    return !!o.column;
}
/**
 * Transforms a PostgrestJsSelectParam into its PostgREST-readable string representation
 * @param p
 */
function transformPostgrestJsSelectParamToString(p) {
    if (isPostgrestJsSelectParam(p)) {
        // Parse the children recursively
        const childrenStr = [];
        for (const cp of p.children) {
            childrenStr.push(transformPostgrestJsSelectParamToString(cp));
        }
        // Final string
        const finalStr = [
            p.alias ? `${p.alias}:` : '',
            p.identifier,
            '(',
            childrenStr.join(','),
            ')'
        ];
        // Return
        return finalStr.join('');
    }
    else {
        return `${p}`;
    }
}
export function get(model, params, config) {
    const path = `${config.endpoint}/${model}`;
    // === Handle simple params that are just passed into request
    // Currently handled params: limit, offset
    const requestParams = pick(['limit', 'offset'], params);
    // Handle filtering
    if (params.filters) {
        // If this is an Array of filters / groups, process it
        if (isArray(params.filters)) {
            const filterMap = generatePostgrestFilterProperties(params.filters);
            Object.keys(filterMap).map(key => {
                requestParams[key] = filterMap[key];
            });
        }
        // Otherwise, we need to parse string param to inject it into requestParams
        else {
            const parsedFilterParam = qs.parse(params.filters);
            Object.assign(requestParams, parsedFilterParam);
        }
    }
    // Handle vertical select
    if (params.select) {
        if (isArray(params.select)) {
            const selectParams = [];
            // Build the select params string by parsing each array element
            params.select.map(p => {
                if (isPostgrestJsSelectParam(p)) {
                    selectParams.push(transformPostgrestJsSelectParamToString(p));
                }
                else {
                    selectParams.push(p);
                }
            });
            requestParams['select'] = selectParams.join(',');
        }
        else {
            requestParams['select'] = params.select;
        }
    }
    // Handle ordering
    if (params.order) {
        const orderStrParts = [];
        if (isArray(params.order)) {
            for (const e of params.order) {
                if (isPostgrestJsOrderParam(e)) {
                    orderStrParts.push(`${e.column}.${e.isDesc ? 'desc' : 'asc'}`);
                }
                else {
                    orderStrParts.push(e);
                }
            }
        }
        else {
            if (isPostgrestJsOrderParam(params.order)) {
                orderStrParts.push(`${params.order.column}.${params.order.isDesc ? 'desc' : 'asc'}`);
            }
            else {
                orderStrParts.push(params.order);
            }
        }
        requestParams['order'] = orderStrParts.join(',');
    }
    // === Create headers
    const requestHeaders = generatePostgrestRequestHeaders(config);
    // === Add exact count header if requested
    if (params.count) {
        requestHeaders['Prefer'] = 'count=exact';
    }
    return axios.get(path, {
        params: requestParams,
        headers: requestHeaders
    })
        .then(res => {
        // If fetch was passed, return first record or undefined
        if (isPostgrestJsGetWithFetchParams(params)) {
            return (res.data[0] ? res.data[0] : undefined);
        }
        // Otherwise, return collection of items
        return {
            items: res.data,
            pagination: {
                total: res.headers['content-range'] ? res.headers['content-range'].split('/')[1] : undefined
            }
        };
    });
}
// ===
// === HELPER METHODS
// ===
/**
 * A shortcut to fetch only one row from model. Always returns either the row or undefined.
 * @param model
 * @param property
 * @param propertyValue
 * @param config
 */
export function fetch(model, column, columnValue, config) {
    return get(model, {
        fetch: true,
        filters: [
            { column: column, type: 'eq', value: columnValue }
        ]
    }, config);
}
/**
 * A shortcut to fetch only one row from model by the "id" column. Always returns either the row or undefined.
 * @param model
 * @param id
 * @param config
 */
export function fetchById(model, id, config) {
    return fetch(model, 'id', id, config);
}
//# sourceMappingURL=get.js.map