// ===
// === Typeguards
// ===
export function isString(v) {
    return typeof v === 'string' || v instanceof String;
}
export function isArray(v) {
    return Array.isArray(v);
}
export function isPostgrestJsFilterGroup(v) {
    return v.operation;
}
// ===
// === Filters
// ===
function generatePostgrestFilterValue(filter, namespace = false) {
    if (namespace) {
        return `${filter.column}.${filter.type}.${filter.value}`;
    }
    return `${filter.type}.${filter.value}`;
}
/**
 * This function processes an Array of filters (either params or and/or groups) and returns a string map
 * @param filters
 */
export function generatePostgrestFilterProperties(filters) {
    const props = {};
    for (const f of filters) {
        // This is a group
        if (isPostgrestJsFilterGroup(f)) {
            props[f.operation] = `(${f.params.map(p => generatePostgrestFilterValue(p, true)).join(',')})`;
        }
        // This is a simple parameter
        else {
            props[f.column] = generatePostgrestFilterValue(f);
        }
    }
    return props;
}
// ===
// === Request Headers
// ===
export function generatePostgrestRequestHeaders(config) {
    const headers = {};
    headers['X-Requested-With'] = 'PostgREST-JS';
    headers['Content-Type'] = 'application/json';
    // Optional parameters
    if (config.authorizationToken) {
        headers['Authorization'] = `Bearer ${config.authorizationToken}`;
    }
    return headers;
}
//# sourceMappingURL=util.js.map