import axios from 'axios';
import { pick } from 'rambda';
import { parse } from 'qs';

// ===
function isArray(v) {
    return Array.isArray(v);
}
function isPostgrestJsFilterGroup(v) {
    return v.operation;
}
// ===
// === Filters
// ===
function generatePostgrestFilterValue(filter, namespace = false) {
    if (namespace) {
        return `${filter.column}.${filter.type}.${filter.value}`;
    }
    return `${filter.type}.${filter.value}`;
}
/**
 * This function processes an Array of filters (either params or and/or groups) and returns a string map
 * @param filters
 */
function generatePostgrestFilterProperties(filters) {
    const props = {};
    for (const f of filters) {
        // This is a group
        if (isPostgrestJsFilterGroup(f)) {
            props[f.operation] = `(${f.params.map(p => generatePostgrestFilterValue(p, true)).join(',')})`;
        }
        // This is a simple parameter
        else {
            props[f.column] = generatePostgrestFilterValue(f);
        }
    }
    return props;
}
// ===
// === Request Headers
// ===
function generatePostgrestRequestHeaders(config) {
    const headers = {};
    headers['X-Requested-With'] = 'PostgREST-JS';
    headers['Content-Type'] = 'application/json';
    // Optional parameters
    if (config.authorizationToken) {
        headers['Authorization'] = `Bearer ${config.authorizationToken}`;
    }
    return headers;
}

/**
 * Typeguard function that distinguishes PostgrestJsGetWithFetchParams object
 * @param o
 */
function isPostgrestJsGetWithFetchParams(o) {
    return o.fetch;
}
/**
 * Typeguard function that distinguishes PostgrestJsSelectParam object
 * @param o
 */
function isPostgrestJsSelectParam(o) {
    return !!o.identifier;
}
/**
 * Typeguard function that distinguishes PostgrestJsOrderParam object
 * @param o
 */
function isPostgrestJsOrderParam(o) {
    return !!o.column;
}
/**
 * Transforms a PostgrestJsSelectParam into its PostgREST-readable string representation
 * @param p
 */
function transformPostgrestJsSelectParamToString(p) {
    if (isPostgrestJsSelectParam(p)) {
        // Parse the children recursively
        const childrenStr = [];
        for (const cp of p.children) {
            childrenStr.push(transformPostgrestJsSelectParamToString(cp));
        }
        // Final string
        const finalStr = [
            p.alias ? `${p.alias}:` : '',
            p.identifier,
            '(',
            childrenStr.join(','),
            ')'
        ];
        // Return
        return finalStr.join('');
    }
    else {
        return `${p}`;
    }
}
function get(model, params, config) {
    const path = `${config.endpoint}/${model}`;
    // === Handle simple params that are just passed into request
    // Currently handled params: limit, offset
    const requestParams = pick(['limit', 'offset'], params);
    // Handle filtering
    if (params.filters) {
        // If this is an Array of filters / groups, process it
        if (isArray(params.filters)) {
            const filterMap = generatePostgrestFilterProperties(params.filters);
            Object.keys(filterMap).map(key => {
                requestParams[key] = filterMap[key];
            });
        }
        // Otherwise, we need to parse string param to inject it into requestParams
        else {
            const parsedFilterParam = parse(params.filters);
            Object.assign(requestParams, parsedFilterParam);
        }
    }
    // Handle vertical select
    if (params.select) {
        if (isArray(params.select)) {
            const selectParams = [];
            // Build the select params string by parsing each array element
            params.select.map(p => {
                if (isPostgrestJsSelectParam(p)) {
                    selectParams.push(transformPostgrestJsSelectParamToString(p));
                }
                else {
                    selectParams.push(p);
                }
            });
            requestParams['select'] = selectParams.join(',');
        }
        else {
            requestParams['select'] = params.select;
        }
    }
    // Handle ordering
    if (params.order) {
        const orderStrParts = [];
        if (isArray(params.order)) {
            for (const e of params.order) {
                if (isPostgrestJsOrderParam(e)) {
                    orderStrParts.push(`${e.column}.${e.isDesc ? 'desc' : 'asc'}`);
                }
                else {
                    orderStrParts.push(e);
                }
            }
        }
        else {
            if (isPostgrestJsOrderParam(params.order)) {
                orderStrParts.push(`${params.order.column}.${params.order.isDesc ? 'desc' : 'asc'}`);
            }
            else {
                orderStrParts.push(params.order);
            }
        }
        requestParams['order'] = orderStrParts.join(',');
    }
    // === Create headers
    const requestHeaders = generatePostgrestRequestHeaders(config);
    // === Add exact count header if requested
    if (params.count) {
        requestHeaders['Prefer'] = 'count=exact';
    }
    return axios.get(path, {
        params: requestParams,
        headers: requestHeaders
    })
        .then(res => {
        // If fetch was passed, return first record or undefined
        if (isPostgrestJsGetWithFetchParams(params)) {
            return (res.data[0] ? res.data[0] : undefined);
        }
        // Otherwise, return collection of items
        return {
            items: res.data,
            pagination: {
                total: res.headers['content-range'] ? res.headers['content-range'].split('/')[1] : undefined
            }
        };
    });
}
// ===
// === HELPER METHODS
// ===
/**
 * A shortcut to fetch only one row from model. Always returns either the row or undefined.
 * @param model
 * @param property
 * @param propertyValue
 * @param config
 */
function fetch(model, column, columnValue, config) {
    return get(model, {
        fetch: true,
        filters: [
            { column: column, type: 'eq', value: columnValue }
        ]
    }, config);
}
/**
 * A shortcut to fetch only one row from model by the "id" column. Always returns either the row or undefined.
 * @param model
 * @param id
 * @param config
 */
function fetchById(model, id, config) {
    return fetch(model, 'id', id, config);
}

function create(model, payload, config, upsert = false) {
    const path = `${config.endpoint}/${model}`;
    const requestHeaders = generatePostgrestRequestHeaders(config);
    // If we are upserting, we need to attach a special header
    if (upsert) {
        requestHeaders['Prefer'] = 'resolution=merge-duplicates';
    }
    return axios.post(path, payload, {
        headers: requestHeaders
    })
        .then(res => {
        return {
            item: res.data,
            headers: res.headers
        };
    });
}
function createAndFetch(model, payload, config, upsert = false) {
    const requestHeaders = generatePostgrestRequestHeaders(config);
    return create(model, payload, config, upsert)
        .then(res => {
        const path = `${config.endpoint}${res.headers.location}`;
        return axios.get(path, {
            headers: requestHeaders
        });
    })
        .then(res => {
        return res.data[0];
    });
}

/**
 * Updates a model filtered by passed filters
 * @param model Model to update
 * @param filters An array of filter params or operations
 * @param payload Object with values to be updated
 * @param config Configuration object
 */
function update(model, filters, payload, config) {
    const path = `${config.endpoint}/${model}`;
    const requestParams = {};
    // Process filters
    const filterMap = generatePostgrestFilterProperties(filters);
    Object.keys(filterMap).map(key => {
        requestParams[key] = filterMap[key];
    });
    return axios.patch(path, payload, {
        params: requestParams,
        headers: generatePostgrestRequestHeaders(config)
    })
        .then(res => {
        return {
            item: res.data
        };
    });
}
/**
 * Updates a model filtering by specified column value
 * @param model Model to update
 * @param column Column to filter the update by
 * @param columnValue Column value to filter the update by
 * @param payload Object with values to be updated
 * @param config Configuration object
 */
function updateByColumn(model, column, columnValue, payload, config) {
    return update(model, [
        {
            column: column,
            type: 'eq',
            value: columnValue
        }
    ], payload, config);
}
/**
 * Updates a model by id column
 * @param model Model to update
 * @param id Id of the row to update
 * @param payload Object with values to be updated
 * @param config Configuration object
 */
function updateById(model, id, payload, config) {
    return updateByColumn(model, 'id', id, payload, config);
}

function remove(model, filters, config) {
    const path = `${config.endpoint}/${model}`;
    const requestParams = {};
    // Process filters
    const filterMap = generatePostgrestFilterProperties(filters);
    Object.keys(filterMap).map(key => {
        requestParams[key] = filterMap[key];
    });
    return axios.delete(path, {
        params: requestParams,
        headers: generatePostgrestRequestHeaders(config)
    })
        .then(res => {
        return {
            item: res.data
        };
    });
}
// ===
// === Helpers functions
// ===
/**
 * Removes a specific model by column value
 * @param model
 * @param column
 * @param columnValue
 * @param config
 */
function removeByColumn(model, column, columnValue, config) {
    return remove(model, [
        {
            column: column,
            type: 'eq',
            value: columnValue
        }
    ], config);
}
/**
 * Removes a specific model by 'id' column
 * @param model
 * @param id
 * @param config
 */
function removeById(model, id, config) {
    return removeByColumn(model, 'id', id, config);
}

function rpc(name, payload, config) {
    const path = `${config.endpoint}/rpc/${name}`;
    const requestHeaders = generatePostgrestRequestHeaders(config);
    return axios.post(path, payload, {
        headers: requestHeaders
    })
        .then(res => {
        return {
            response: res.data,
            headers: res.headers
        };
    });
}

/**
* postgrest.js
* JavaScript client for consuming PostgREST APIs
* Author: Andrej Sykora <as@andrejsykora.com>
* Repository:  https://github.com/neonerd/postgrest-js
*/
/**
 * Returns a valid PostgrestJsConfig object that can be used in all other functions
 * @param config Configuration parameters
 */
function createConfig(config) {
    if (!config.endpoint) {
        throw new Error('postgrest-js: PostgrestJsConfig has to contain "endpoint" property.');
    }
    return config;
}

export { create, createAndFetch, createConfig, fetch, fetchById, get, remove, removeByColumn, removeById, rpc, update, updateByColumn, updateById };
