/* 
 * Consolidated GitHub API Client
 * Generated from openapi-typescript-codegen
 * All models, services, and core functionality in one file
 */

/* tslint:disable */
/* eslint-disable */

// ============================================================================
// CORE FUNCTIONALITY
// ============================================================================


// From: core/ApiError.ts
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

export class ApiError extends Error {
    public readonly url: string;
    public readonly status: number;
    public readonly statusText: string;
    public readonly body: any;
    public readonly request: ApiRequestOptions;

    constructor(request: ApiRequestOptions, response: ApiResult, message: string) {
        super(message);

        this.name = 'ApiError';
        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
        this.request = request;
    }
}


// From: core/ApiRequestOptions.ts
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly url: string;
    readonly path?: Record<string, any>;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    readonly errors?: Record<number, string>;
};


// From: core/ApiResult.ts
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
};


// From: core/CancelablePromise.ts
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export class CancelError extends Error {

    constructor(message: string) {
        super(message);
        this.name = 'CancelError';
    }

    public get isCancelled(): boolean {
        return true;
    }
}

export interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;

    (cancelHandler: () => void): void;
}

export class CancelablePromise<T> implements Promise<T> {
    #isResolved: boolean;
    #isRejected: boolean;
    #isCancelled: boolean;
    readonly #cancelHandlers: (() => void)[];
    readonly #promise: Promise<T>;
    #resolve?: (value: T | PromiseLike<T>) => void;
    #reject?: (reason?: any) => void;

    constructor(
        executor: (
            resolve: (value: T | PromiseLike<T>) => void,
            reject: (reason?: any) => void,
            onCancel: OnCancel
        ) => void
    ) {
        this.#isResolved = false;
        this.#isRejected = false;
        this.#isCancelled = false;
        this.#cancelHandlers = [];
        this.#promise = new Promise<T>((resolve, reject) => {
            this.#resolve = resolve;
            this.#reject = reject;

            const onResolve = (value: T | PromiseLike<T>): void => {
                if (this.#isResolved || this.#isRejected || this.#isCancelled) {
                    return;
                }
                this.#isResolved = true;
                if (this.#resolve) this.#resolve(value);
            };

            const onReject = (reason?: any): void => {
                if (this.#isResolved || this.#isRejected || this.#isCancelled) {
                    return;
                }
                this.#isRejected = true;
                if (this.#reject) this.#reject(reason);
            };

            const onCancel = (cancelHandler: () => void): void => {
                if (this.#isResolved || this.#isRejected || this.#isCancelled) {
                    return;
                }
                this.#cancelHandlers.push(cancelHandler);
            };

            Object.defineProperty(onCancel, 'isResolved', {
                get: (): boolean => this.#isResolved,
            });

            Object.defineProperty(onCancel, 'isRejected', {
                get: (): boolean => this.#isRejected,
            });

            Object.defineProperty(onCancel, 'isCancelled', {
                get: (): boolean => this.#isCancelled,
            });

            return executor(onResolve, onReject, onCancel as OnCancel);
        });
    }

    get [Symbol.toStringTag]() {
        return "Cancellable Promise";
    }

    public then<TResult1 = T, TResult2 = never>(
        onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
        onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
    ): Promise<TResult1 | TResult2> {
        return this.#promise.then(onFulfilled, onRejected);
    }

    public catch<TResult = never>(
        onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null
    ): Promise<T | TResult> {
        return this.#promise.catch(onRejected);
    }

    public finally(onFinally?: (() => void) | null): Promise<T> {
        return this.#promise.finally(onFinally);
    }

    public cancel(): void {
        if (this.#isResolved || this.#isRejected || this.#isCancelled) {
            return;
        }
        this.#isCancelled = true;
        if (this.#cancelHandlers.length) {
            try {
                for (const cancelHandler of this.#cancelHandlers) {
                    cancelHandler();
                }
            } catch (error) {
                console.warn('Cancellation threw an error', error);
                return;
            }
        }
        this.#cancelHandlers.length = 0;
        if (this.#reject) this.#reject(new CancelError('Request aborted'));
    }

    public get isCancelled(): boolean {
        return this.#isCancelled;
    }
}


// From: core/OpenAPI.ts
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;

export type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    CREDENTIALS: 'include' | 'omit' | 'same-origin';
    TOKEN?: string | Resolver<string> | undefined;
    USERNAME?: string | Resolver<string> | undefined;
    PASSWORD?: string | Resolver<string> | undefined;
    HEADERS?: Headers | Resolver<Headers> | undefined;
    ENCODE_PATH?: ((path: string) => string) | undefined;
};

export const OpenAPI: OpenAPIConfig = {
    BASE: 'https://api.github.com',
    VERSION: '1.1.4',
    WITH_CREDENTIALS: false,
    CREDENTIALS: 'include',
    TOKEN: undefined,
    USERNAME: undefined,
    PASSWORD: undefined,
    HEADERS: undefined,
    ENCODE_PATH: undefined,
};


// From: core/request.ts
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

export const isDefined = <T>(value: T | null | undefined): value is Exclude<T, null | undefined> => {
    return value !== undefined && value !== null;
};

export const isString = (value: any): value is string => {
    return typeof value === 'string';
};

export const isStringWithValue = (value: any): value is string => {
    return isString(value) && value !== '';
};

export const isBlob = (value: any): value is Blob => {
    return (
        typeof value === 'object' &&
        typeof value.type === 'string' &&
        typeof value.stream === 'function' &&
        typeof value.arrayBuffer === 'function' &&
        typeof value.constructor === 'function' &&
        typeof value.constructor.name === 'string' &&
        /^(Blob|File)$/.test(value.constructor.name) &&
        /^(Blob|File)$/.test(value[Symbol.toStringTag])
    );
};

export const isFormData = (value: any): value is FormData => {
    return value instanceof FormData;
};

export const base64 = (str: string): string => {
    try {
        return btoa(str);
    } catch (err) {
        // @ts-ignore
        return Buffer.from(str).toString('base64');
    }
};

export const getQueryString = (params: Record<string, any>): string => {
    const qs: string[] = [];

    const append = (key: string, value: any) => {
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
    };

    const process = (key: string, value: any) => {
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(v => {
                    process(key, v);
                });
            } else if (typeof value === 'object') {
                Object.entries(value).forEach(([k, v]) => {
                    process(`${key}[${k}]`, v);
                });
            } else {
                append(key, value);
            }
        }
    };

    Object.entries(params).forEach(([key, value]) => {
        process(key, value);
    });

    if (qs.length > 0) {
        return `?${qs.join('&')}`;
    }

    return '';
};

const getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {
    const encoder = config.ENCODE_PATH || encodeURI;

    const path = options.url
        .replace('{api-version}', config.VERSION)
        .replace(/{(.*?)}/g, (substring: string, group: string) => {
            if (options.path?.hasOwnProperty(group)) {
                return encoder(String(options.path[group]));
            }
            return substring;
        });

    const url = `${config.BASE}${path}`;
    if (options.query) {
        return `${url}${getQueryString(options.query)}`;
    }
    return url;
};

export const getFormData = (options: ApiRequestOptions): FormData | undefined => {
    if (options.formData) {
        const formData = new FormData();

        const process = (key: string, value: any) => {
            if (isString(value) || isBlob(value)) {
                formData.append(key, value);
            } else {
                formData.append(key, JSON.stringify(value));
            }
        };

        Object.entries(options.formData)
            .filter(([_, value]) => isDefined(value))
            .forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    value.forEach(v => process(key, v));
                } else {
                    process(key, value);
                }
            });

        return formData;
    }
    return undefined;
};

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

export const resolve = async <T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> => {
    if (typeof resolver === 'function') {
        return (resolver as Resolver<T>)(options);
    }
    return resolver;
};

export const getHeaders = async (config: OpenAPIConfig, options: ApiRequestOptions): Promise<Headers> => {
    const [token, username, password, additionalHeaders] = await Promise.all([
        resolve(options, config.TOKEN),
        resolve(options, config.USERNAME),
        resolve(options, config.PASSWORD),
        resolve(options, config.HEADERS),
    ]);

    const headers = Object.entries({
        Accept: 'application/json',
        ...additionalHeaders,
        ...options.headers,
    })
        .filter(([_, value]) => isDefined(value))
        .reduce((headers, [key, value]) => ({
            ...headers,
            [key]: String(value),
        }), {} as Record<string, string>);

    if (isStringWithValue(token)) {
        headers['Authorization'] = `Bearer ${token}`;
    }

    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = base64(`${username}:${password}`);
        headers['Authorization'] = `Basic ${credentials}`;
    }

    if (options.body !== undefined) {
        if (options.mediaType) {
            headers['Content-Type'] = options.mediaType;
        } else if (isBlob(options.body)) {
            headers['Content-Type'] = options.body.type || 'application/octet-stream';
        } else if (isString(options.body)) {
            headers['Content-Type'] = 'text/plain';
        } else if (!isFormData(options.body)) {
            headers['Content-Type'] = 'application/json';
        }
    }

    return new Headers(headers);
};

export const getRequestBody = (options: ApiRequestOptions): any => {
    if (options.body !== undefined) {
        if (options.mediaType?.includes('/json')) {
            return JSON.stringify(options.body)
        } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {
            return options.body;
        } else {
            return JSON.stringify(options.body);
        }
    }
    return undefined;
};

export const sendRequest = async (
    config: OpenAPIConfig,
    options: ApiRequestOptions,
    url: string,
    body: any,
    formData: FormData | undefined,
    headers: Headers,
    onCancel: OnCancel
): Promise<Response> => {
    const controller = new AbortController();

    const request: RequestInit = {
        headers,
        body: body ?? formData,
        method: options.method,
        signal: controller.signal,
    };

    if (config.WITH_CREDENTIALS) {
        request.credentials = config.CREDENTIALS;
    }

    onCancel(() => controller.abort());

    return await fetch(url, request);
};

export const getResponseHeader = (response: Response, responseHeader?: string): string | undefined => {
    if (responseHeader) {
        const content = response.headers.get(responseHeader);
        if (isString(content)) {
            return content;
        }
    }
    return undefined;
};

export const getResponseBody = async (response: Response): Promise<any> => {
    if (response.status !== 204) {
        try {
            const contentType = response.headers.get('Content-Type');
            if (contentType) {
                const jsonTypes = ['application/json', 'application/problem+json']
                const isJSON = jsonTypes.some(type => contentType.toLowerCase().startsWith(type));
                if (isJSON) {
                    return await response.json();
                } else {
                    return await response.text();
                }
            }
        } catch (error) {
            console.error(error);
        }
    }
    return undefined;
};

export const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {
    const errors: Record<number, string> = {
        400: 'Bad Request',
        401: 'Unauthorized',
        403: 'Forbidden',
        404: 'Not Found',
        500: 'Internal Server Error',
        502: 'Bad Gateway',
        503: 'Service Unavailable',
        ...options.errors,
    }

    const error = errors[result.status];
    if (error) {
        throw new ApiError(options, result, error);
    }

    if (!result.ok) {
        const errorStatus = result.status ?? 'unknown';
        const errorStatusText = result.statusText ?? 'unknown';
        const errorBody = (() => {
            try {
                return JSON.stringify(result.body, null, 2);
            } catch (e) {
                return undefined;
            }
        })();

        throw new ApiError(options, result,
            `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`
        );
    }
};

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions): CancelablePromise<T> => {
    return new CancelablePromise(async (resolve, reject, onCancel) => {
        try {
            const url = getUrl(config, options);
            const formData = getFormData(options);
            const body = getRequestBody(options);
            const headers = await getHeaders(config, options);

            if (!onCancel.isCancelled) {
                const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
                const responseBody = await getResponseBody(response);
                const responseHeader = getResponseHeader(response, options.responseHeader);

                const result: ApiResult = {
                    url,
                    ok: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                    body: responseHeader ?? responseBody,
                };

                catchErrorCodes(options, result);

                resolve(result.body);
            }
        } catch (error) {
            reject(error);
        }
    });
};


// ============================================================================
// TYPE DEFINITIONS & MODELS
// ============================================================================

// From: actions_artifact_and_log_retention.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type actions_artifact_and_log_retention = {
    /**
     * The number of days to retain artifacts and logs
     */
    days: number;
};


// From: actions_artifact_and_log_retention_response.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type actions_artifact_and_log_retention_response = {
    /**
     * The number of days artifacts and logs are retained
     */
    days: number;
    /**
     * The maximum number of days that can be configured
     */
    maximum_allowed_days: number;
};


// From: actions_cache_list.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Repository actions caches
 */
export type actions_cache_list = {
    /**
     * Total number of caches
     */
    total_count: number;
    /**
     * Array of caches
     */
    actions_caches: Array<{
        id?: number;
        ref?: string;
        key?: string;
        version?: string;
        last_accessed_at?: string;
        created_at?: string;
        size_in_bytes?: number;
    }>;
};


// From: actions_cache_retention_limit_for_enterprise.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * GitHub Actions cache retention policy for an enterprise.
 */
export type actions_cache_retention_limit_for_enterprise = {
    /**
     * For repositories & organizations in an enterprise, the maximum duration, in days, for which caches in a repository may be retained.
     */
    max_cache_retention_days?: number;
};


// From: actions_cache_retention_limit_for_organization.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * GitHub Actions cache retention policy for an organization.
 */
export type actions_cache_retention_limit_for_organization = {
    /**
     * For repositories in this organization, the maximum duration, in days, for which caches in a repository may be retained.
     */
    max_cache_retention_days?: number;
};


// From: actions_cache_retention_limit_for_repository.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * GitHub Actions cache retention policy for a repository.
 */
export type actions_cache_retention_limit_for_repository = {
    /**
     * The maximum number of days to keep caches in this repository.
     */
    max_cache_retention_days?: number;
};


// From: actions_cache_storage_limit_for_enterprise.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * GitHub Actions cache storage policy for an enterprise.
 */
export type actions_cache_storage_limit_for_enterprise = {
    /**
     * For repositories & organizations in an enterprise, the maximum size limit for the sum of all caches in a repository, in gigabytes.
     */
    max_cache_size_gb?: number;
};


// From: actions_cache_storage_limit_for_organization.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * GitHub Actions cache storage policy for an organization.
 */
export type actions_cache_storage_limit_for_organization = {
    /**
     * For repositories in the organization, the maximum size limit for the sum of all caches in a repository, in gigabytes.
     */
    max_cache_size_gb?: number;
};


// From: actions_cache_storage_limit_for_repository.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * GitHub Actions cache storage policy for a repository.
 */
export type actions_cache_storage_limit_for_repository = {
    /**
     * The maximum total cache size for this repository, in gigabytes.
     */
    max_cache_size_gb?: number;
};


// From: actions_cache_usage_by_repository.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * GitHub Actions Cache Usage by repository.
 */
export type actions_cache_usage_by_repository = {
    /**
     * The repository owner and name for the cache usage being shown.
     */
    full_name: string;
    /**
     * The sum of the size in bytes of all the active cache items in the repository.
     */
    active_caches_size_in_bytes: number;
    /**
     * The number of active caches in the repository.
     */
    active_caches_count: number;
};


// From: actions_cache_usage_org_enterprise.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type actions_cache_usage_org_enterprise = {
    /**
     * The count of active caches across all repositories of an enterprise or an organization.
     */
    total_active_caches_count: number;
    /**
     * The total size in bytes of all active cache items across all repositories of an enterprise or an organization.
     */
    total_active_caches_size_in_bytes: number;
};


// From: actions_enabled.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Whether GitHub Actions is enabled on the repository.
 */
export type actions_enabled = boolean;

// From: actions_fork_pr_contributor_approval.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type actions_fork_pr_contributor_approval = {
    /**
     * The policy that controls when fork PR workflows require approval from a maintainer.
     */
    approval_policy: actions_fork_pr_contributor_approval.approval_policy;
};
export namespace actions_fork_pr_contributor_approval {
    /**
     * The policy that controls when fork PR workflows require approval from a maintainer.
     */
    export enum approval_policy {
        FIRST_TIME_CONTRIBUTORS_NEW_TO_GITHUB = 'first_time_contributors_new_to_github',
        FIRST_TIME_CONTRIBUTORS = 'first_time_contributors',
        ALL_EXTERNAL_CONTRIBUTORS = 'all_external_contributors',
    }
}


// From: actions_fork_pr_workflows_private_repos.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type actions_fork_pr_workflows_private_repos = {
    /**
     * Whether workflows triggered by pull requests from forks are allowed to run on private repositories.
     */
    run_workflows_from_fork_pull_requests: boolean;
    /**
     * Whether GitHub Actions can create pull requests or submit approving pull request reviews from a workflow triggered by a fork pull request.
     */
    send_write_tokens_to_workflows: boolean;
    /**
     * Whether to make secrets and variables available to workflows triggered by pull requests from forks.
     */
    send_secrets_and_variables: boolean;
    /**
     * Whether workflows triggered by pull requests from forks require approval from a repository administrator to run.
     */
    require_approval_for_fork_pr_workflows: boolean;
};


// From: actions_fork_pr_workflows_private_repos_request.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type actions_fork_pr_workflows_private_repos_request = {
    /**
     * Whether workflows triggered by pull requests from forks are allowed to run on private repositories.
     */
    run_workflows_from_fork_pull_requests: boolean;
    /**
     * Whether GitHub Actions can create pull requests or submit approving pull request reviews from a workflow triggered by a fork pull request.
     */
    send_write_tokens_to_workflows?: boolean;
    /**
     * Whether to make secrets and variables available to workflows triggered by pull requests from forks.
     */
    send_secrets_and_variables?: boolean;
    /**
     * Whether workflows triggered by pull requests from forks require approval from a repository administrator to run.
     */
    require_approval_for_fork_pr_workflows?: boolean;
};


// From: actions_get_default_workflow_permissions.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { actions_can_approve_pull_request_reviews } from './actions_can_approve_pull_request_reviews';
import type { actions_default_workflow_permissions } from './actions_default_workflow_permissions';
export type actions_get_default_workflow_permissions = {
    default_workflow_permissions: actions_default_workflow_permissions;
    can_approve_pull_request_reviews: actions_can_approve_pull_request_reviews;
};


// From: actions_hosted_runner.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { actions_hosted_runner_machine_spec } from './actions_hosted_runner_machine_spec';
import type { nullable_actions_hosted_runner_pool_image } from './nullable_actions_hosted_runner_pool_image';
import type { public_ip } from './public_ip';
/**
 * A Github-hosted hosted runner.
 */
export type actions_hosted_runner = {
    /**
     * The unique identifier of the hosted runner.
     */
    id: number;
    /**
     * The name of the hosted runner.
     */
    name: string;
    /**
     * The unique identifier of the group that the hosted runner belongs to.
     */
    runner_group_id?: number;
    image_details: nullable_actions_hosted_runner_pool_image;
    machine_size_details: actions_hosted_runner_machine_spec;
    /**
     * The status of the runner.
     */
    status: actions_hosted_runner.status;
    /**
     * The operating system of the image.
     */
    platform: string;
    /**
     * The maximum amount of hosted runners. Runners will not scale automatically above this number. Use this setting to limit your cost.
     */
    maximum_runners?: number;
    /**
     * Whether public IP is enabled for the hosted runners.
     */
    public_ip_enabled: boolean;
    /**
     * The public IP ranges when public IP is enabled for the hosted runners.
     */
    public_ips?: Array<public_ip>;
    /**
     * The time at which the runner was last used, in ISO 8601 format.
     */
    last_active_on?: string | null;
    /**
     * Whether custom image generation is enabled for the hosted runners.
     */
    image_gen?: boolean;
};
export namespace actions_hosted_runner {
    /**
     * The status of the runner.
     */
    export enum status {
        READY = 'Ready',
        PROVISIONING = 'Provisioning',
        SHUTDOWN = 'Shutdown',
        DELETING = 'Deleting',
        STUCK = 'Stuck',
    }
}


// From: actions_hosted_runner_curated_image.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Provides details of a hosted runner image
 */
export type actions_hosted_runner_curated_image = {
    /**
     * The ID of the image. Use this ID for the `image` parameter when creating a new larger runner.
     */
    id: string;
    /**
     * The operating system of the image.
     */
    platform: string;
    /**
     * Image size in GB.
     */
    size_gb: number;
    /**
     * Display name for this image.
     */
    display_name: string;
    /**
     * The image provider.
     */
    source: actions_hosted_runner_curated_image.source;
};
export namespace actions_hosted_runner_curated_image {
    /**
     * The image provider.
     */
    export enum source {
        GITHUB = 'github',
        PARTNER = 'partner',
        CUSTOM = 'custom',
    }
}


// From: actions_hosted_runner_custom_image.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Provides details of a custom runner image
 */
export type actions_hosted_runner_custom_image = {
    /**
     * The ID of the image. Use this ID for the `image` parameter when creating a new larger runner.
     */
    id: number;
    /**
     * The operating system of the image.
     */
    platform: string;
    /**
     * Total size of all the image versions in GB.
     */
    total_versions_size: number;
    /**
     * Display name for this image.
     */
    name: string;
    /**
     * The image provider.
     */
    source: string;
    /**
     * The number of image versions associated with the image.
     */
    versions_count: number;
    /**
     * The latest image version associated with the image.
     */
    latest_version: string;
    /**
     * The number of image versions associated with the image.
     */
    state: string;
};


// From: actions_hosted_runner_custom_image_version.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Provides details of a hosted runner custom image version
 */
export type actions_hosted_runner_custom_image_version = {
    /**
     * The version of image.
     */
    version: string;
    /**
     * The state of image version.
     */
    state: string;
    /**
     * Image version size in GB.
     */
    size_gb: number;
    /**
     * The creation date time of the image version.
     */
    created_on: string;
    /**
     * The image version status details.
     */
    state_details: string;
};


// From: actions_hosted_runner_limits.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type actions_hosted_runner_limits = {
    /**
     * Provides details of static public IP limits for GitHub-hosted Hosted Runners
     */
    public_ips: {
        /**
         * The maximum number of static public IP addresses that can be used for Hosted Runners.
         */
        maximum: number;
        /**
         * The current number of static public IP addresses in use by Hosted Runners.
         */
        current_usage: number;
    };
};


// From: actions_hosted_runner_machine_spec.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Provides details of a particular machine spec.
 */
export type actions_hosted_runner_machine_spec = {
    /**
     * The ID used for the `size` parameter when creating a new runner.
     */
    id: string;
    /**
     * The number of cores.
     */
    cpu_cores: number;
    /**
     * The available RAM for the machine spec.
     */
    memory_gb: number;
    /**
     * The available SSD storage for the machine spec.
     */
    storage_gb: number;
};


// From: actions_organization_permissions.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { allowed_actions } from './allowed_actions';
import type { enabled_repositories } from './enabled_repositories';
import type { selected_actions_url } from './selected_actions_url';
import type { sha_pinning_required } from './sha_pinning_required';
export type actions_organization_permissions = {
    enabled_repositories: enabled_repositories;
    /**
     * The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`.
     */
    selected_repositories_url?: string;
    allowed_actions?: allowed_actions;
    selected_actions_url?: selected_actions_url;
    sha_pinning_required?: sha_pinning_required;
};


// From: actions_public_key.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The public key used for setting Actions Secrets.
 */
export type actions_public_key = {
    /**
     * The identifier for the key.
     */
    key_id: string;
    /**
     * The Base64 encoded public key.
     */
    key: string;
    id?: number;
    url?: string;
    title?: string;
    created_at?: string;
};


// From: actions_repository_permissions.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { actions_enabled } from './actions_enabled';
import type { allowed_actions } from './allowed_actions';
import type { selected_actions_url } from './selected_actions_url';
import type { sha_pinning_required } from './sha_pinning_required';
export type actions_repository_permissions = {
    enabled: actions_enabled;
    allowed_actions?: allowed_actions;
    selected_actions_url?: selected_actions_url;
    sha_pinning_required?: sha_pinning_required;
};


// From: actions_secret.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Set secrets for GitHub Actions.
 */
export type actions_secret = {
    /**
     * The name of the secret.
     */
    name: string;
    created_at: string;
    updated_at: string;
};


// From: actions_set_default_workflow_permissions.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { actions_can_approve_pull_request_reviews } from './actions_can_approve_pull_request_reviews';
import type { actions_default_workflow_permissions } from './actions_default_workflow_permissions';
export type actions_set_default_workflow_permissions = {
    default_workflow_permissions?: actions_default_workflow_permissions;
    can_approve_pull_request_reviews?: actions_can_approve_pull_request_reviews;
};


// From: actions_variable.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type actions_variable = {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The value of the variable.
     */
    value: string;
    /**
     * The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
     */
    created_at: string;
    /**
     * The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
     */
    updated_at: string;
};


// From: actions_workflow_access_to_repository.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type actions_workflow_access_to_repository = {
    /**
     * Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the
     * repository.
     *
     * `none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization.
     */
    access_level: actions_workflow_access_to_repository.access_level;
};
export namespace actions_workflow_access_to_repository {
    /**
     * Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the
     * repository.
     *
     * `none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization.
     */
    export enum access_level {
        NONE = 'none',
        USER = 'user',
        ORGANIZATION = 'organization',
    }
}


// From: activity.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * Activity
 */
export type activity = {
    id: number;
    node_id: string;
    /**
     * The SHA of the commit before the activity.
     */
    before: string;
    /**
     * The SHA of the commit after the activity.
     */
    after: string;
    /**
     * The full Git reference, formatted as `refs/heads/<branch name>`.
     */
    ref: string;
    /**
     * The time when the activity occurred.
     */
    timestamp: string;
    /**
     * The type of the activity that was performed.
     */
    activity_type: activity.activity_type;
    actor: nullable_simple_user;
};
export namespace activity {
    /**
     * The type of the activity that was performed.
     */
    export enum activity_type {
        PUSH = 'push',
        FORCE_PUSH = 'force_push',
        BRANCH_DELETION = 'branch_deletion',
        BRANCH_CREATION = 'branch_creation',
        PR_MERGE = 'pr_merge',
        MERGE_QUEUE_MERGE = 'merge_queue_merge',
    }
}


// From: allowed_actions.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The permissions policy that controls the actions and reusable workflows that are allowed to run.
 */
export enum allowed_actions {
    ALL = 'all',
    LOCAL_ONLY = 'local_only',
    SELECTED = 'selected',
}

// From: api_insights_route_stats.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * API Insights usage route stats for an actor
 */
export type api_insights_route_stats = Array<{
    /**
     * The HTTP method
     */
    http_method?: string;
    /**
     * The API path's route template
     */
    api_route?: string;
    /**
     * The total number of requests within the queried time period
     */
    total_request_count?: number;
    /**
     * The total number of requests that were rate limited within the queried time period
     */
    rate_limited_request_count?: number;
    last_rate_limited_timestamp?: string | null;
    last_request_timestamp?: string;
}>;

// From: api_insights_subject_stats.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * API Insights usage subject stats for an organization
 */
export type api_insights_subject_stats = Array<{
    subject_type?: string;
    subject_name?: string;
    subject_id?: number;
    total_request_count?: number;
    rate_limited_request_count?: number;
    last_rate_limited_timestamp?: string | null;
    last_request_timestamp?: string;
}>;

// From: api_insights_summary_stats.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * API Insights usage summary stats for an organization
 */
export type api_insights_summary_stats = {
    /**
     * The total number of requests within the queried time period
     */
    total_request_count?: number;
    /**
     * The total number of requests that were rate limited within the queried time period
     */
    rate_limited_request_count?: number;
};


// From: api_insights_time_stats.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * API Insights usage time stats for an organization
 */
export type api_insights_time_stats = Array<{
    timestamp?: string;
    total_request_count?: number;
    rate_limited_request_count?: number;
}>;

// From: api_insights_user_stats.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * API Insights usage stats for a user
 */
export type api_insights_user_stats = Array<{
    actor_type?: string;
    actor_name?: string;
    actor_id?: number;
    integration_id?: number | null;
    oauth_application_id?: number | null;
    total_request_count?: number;
    rate_limited_request_count?: number;
    last_rate_limited_timestamp?: string | null;
    last_request_timestamp?: string;
}>;

// From: api_overview.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Api Overview
 */
export type api_overview = {
    verifiable_password_authentication: boolean;
    ssh_key_fingerprints?: {
        SHA256_RSA?: string;
        SHA256_DSA?: string;
        SHA256_ECDSA?: string;
        SHA256_ED25519?: string;
    };
    ssh_keys?: Array<string>;
    hooks?: Array<string>;
    github_enterprise_importer?: Array<string>;
    web?: Array<string>;
    api?: Array<string>;
    git?: Array<string>;
    packages?: Array<string>;
    pages?: Array<string>;
    importer?: Array<string>;
    actions?: Array<string>;
    actions_macos?: Array<string>;
    codespaces?: Array<string>;
    dependabot?: Array<string>;
    copilot?: Array<string>;
    domains?: {
        website?: Array<string>;
        codespaces?: Array<string>;
        copilot?: Array<string>;
        packages?: Array<string>;
        actions?: Array<string>;
        actions_inbound?: {
            full_domains?: Array<string>;
            wildcard_domains?: Array<string>;
        };
        artifact_attestations?: {
            trust_domain?: string;
            services?: Array<string>;
        };
    };
};


// From: artifact.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * An artifact
 */
export type artifact = {
    id: number;
    node_id: string;
    /**
     * The name of the artifact.
     */
    name: string;
    /**
     * The size in bytes of the artifact.
     */
    size_in_bytes: number;
    url: string;
    archive_download_url: string;
    /**
     * Whether or not the artifact has expired.
     */
    expired: boolean;
    created_at: string | null;
    expires_at: string | null;
    updated_at: string | null;
    /**
     * The SHA256 digest of the artifact. This field will only be populated on artifacts uploaded with upload-artifact v4 or newer. For older versions, this field will be null.
     */
    digest?: string | null;
    workflow_run?: {
        id?: number;
        repository_id?: number;
        head_repository_id?: number;
        head_branch?: string;
        head_sha?: string;
    } | null;
};


// From: artifact_deployment_record.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Artifact Metadata Deployment Record
 */
export type artifact_deployment_record = {
    id?: number;
    digest?: string;
    logical_environment?: string;
    physical_environment?: string;
    cluster?: string;
    deployment_name?: string;
    tags?: Record<string, string>;
    /**
     * A list of runtime risks associated with the deployment.
     */
    runtime_risks?: Array<'critical-resource' | 'internet-exposed' | 'lateral-movement' | 'sensitive-data'>;
    created_at?: string;
    updated_at?: string;
    /**
     * The ID of the provenance attestation associated with the deployment record.
     */
    attestation_id?: number | null;
};


// From: authentication_token.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { repository } from './repository';
/**
 * Authentication Token
 */
export type authentication_token = {
    /**
     * The token used for authentication
     */
    token: string;
    /**
     * The time this token expires
     */
    expires_at: string;
    permissions?: Record<string, any>;
    /**
     * The repositories this token has access to
     */
    repositories?: Array<repository>;
    single_file?: string | null;
    /**
     * Describe whether all repositories have been selected or there's a selection involved
     */
    repository_selection?: authentication_token.repository_selection;
};
export namespace authentication_token {
    /**
     * Describe whether all repositories have been selected or there's a selection involved
     */
    export enum repository_selection {
        ALL = 'all',
        SELECTED = 'selected',
    }
}


// From: autolink.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * An autolink reference.
 */
export type autolink = {
    id: number;
    /**
     * The prefix of a key that is linkified.
     */
    key_prefix: string;
    /**
     * A template for the target URL that is generated if a key was found.
     */
    url_template: string;
    /**
     * Whether this autolink reference matches alphanumeric characters. If false, this autolink reference only matches numeric characters.
     */
    is_alphanumeric: boolean;
    updated_at?: string | null;
};


// From: base_gist.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
import type { simple_user } from './simple_user';
/**
 * Base Gist
 */
export type base_gist = {
    url: string;
    forks_url: string;
    commits_url: string;
    id: string;
    node_id: string;
    git_pull_url: string;
    git_push_url: string;
    html_url: string;
    files: Record<string, {
        filename?: string;
        type?: string;
        language?: string;
        raw_url?: string;
        size?: number;
        /**
         * The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.
         */
        encoding?: string;
    }>;
    public: boolean;
    created_at: string;
    updated_at: string;
    description: string | null;
    comments: number;
    comments_enabled?: boolean;
    user: nullable_simple_user;
    comments_url: string;
    owner?: simple_user;
    truncated?: boolean;
    forks?: Array<any>;
    history?: Array<any>;
};


// From: branch_protection.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { branch_restriction_policy } from './branch_restriction_policy';
import type { protected_branch_admin_enforced } from './protected_branch_admin_enforced';
import type { protected_branch_pull_request_review } from './protected_branch_pull_request_review';
import type { protected_branch_required_status_check } from './protected_branch_required_status_check';
/**
 * Branch Protection
 */
export type branch_protection = {
    url?: string;
    enabled?: boolean;
    required_status_checks?: protected_branch_required_status_check;
    enforce_admins?: protected_branch_admin_enforced;
    required_pull_request_reviews?: protected_branch_pull_request_review;
    restrictions?: branch_restriction_policy;
    required_linear_history?: {
        enabled?: boolean;
    };
    allow_force_pushes?: {
        enabled?: boolean;
    };
    allow_deletions?: {
        enabled?: boolean;
    };
    block_creations?: {
        enabled?: boolean;
    };
    required_conversation_resolution?: {
        enabled?: boolean;
    };
    name?: string;
    protection_url?: string;
    required_signatures?: {
        url: string;
        enabled: boolean;
    };
    /**
     * Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
     */
    lock_branch?: {
        enabled?: boolean;
    };
    /**
     * Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
     */
    allow_fork_syncing?: {
        enabled?: boolean;
    };
};


// From: branch_restriction_policy.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { team } from './team';
/**
 * Branch Restriction Policy
 */
export type branch_restriction_policy = {
    url: string;
    users_url: string;
    teams_url: string;
    apps_url: string;
    users: Array<{
        login?: string;
        id?: number;
        node_id?: string;
        avatar_url?: string;
        gravatar_id?: string;
        url?: string;
        html_url?: string;
        followers_url?: string;
        following_url?: string;
        gists_url?: string;
        starred_url?: string;
        subscriptions_url?: string;
        organizations_url?: string;
        repos_url?: string;
        events_url?: string;
        received_events_url?: string;
        type?: string;
        site_admin?: boolean;
        user_view_type?: string;
    }>;
    teams: Array<team>;
    apps: Array<{
        id?: number;
        slug?: string;
        node_id?: string;
        owner?: {
            login?: string;
            id?: number;
            node_id?: string;
            url?: string;
            repos_url?: string;
            events_url?: string;
            hooks_url?: string;
            issues_url?: string;
            members_url?: string;
            public_members_url?: string;
            avatar_url?: string;
            description?: string;
            gravatar_id?: string;
            html_url?: string;
            followers_url?: string;
            following_url?: string;
            gists_url?: string;
            starred_url?: string;
            subscriptions_url?: string;
            organizations_url?: string;
            received_events_url?: string;
            type?: string;
            site_admin?: boolean;
            user_view_type?: string;
        };
        name?: string;
        client_id?: string;
        description?: string;
        external_url?: string;
        html_url?: string;
        created_at?: string;
        updated_at?: string;
        permissions?: {
            metadata?: string;
            contents?: string;
            issues?: string;
            single_file?: string;
        };
        events?: Array<string>;
    }>;
};


// From: branch_short.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Branch Short
 */
export type branch_short = {
    name: string;
    commit: {
        sha: string;
        url: string;
    };
    protected: boolean;
};


// From: branch_with_protection.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { branch_protection } from './branch_protection';
import type { commit } from './commit';
/**
 * Branch With Protection
 */
export type branch_with_protection = {
    name: string;
    commit: commit;
    _links: {
        html: string;
        self: string;
    };
    protected: boolean;
    protection: branch_protection;
    protection_url: string;
    pattern?: string;
    required_approving_review_count?: number;
};


// From: check_automated_security_fixes.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Check Dependabot security updates
 */
export type check_automated_security_fixes = {
    /**
     * Whether Dependabot security updates are enabled for the repository.
     */
    enabled: boolean;
    /**
     * Whether Dependabot security updates are paused for the repository.
     */
    paused: boolean;
};


// From: check_immutable_releases.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Check immutable releases
 */
export type check_immutable_releases = {
    /**
     * Whether immutable releases are enabled for the repository.
     */
    enabled: boolean;
    /**
     * Whether immutable releases are enforced by the repository owner.
     */
    enforced_by_owner: boolean;
};


// From: clone_traffic.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { traffic } from './traffic';
/**
 * Clone Traffic
 */
export type clone_traffic = {
    count: number;
    uniques: number;
    clones: Array<traffic>;
};


// From: code_frequency_stat.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Code Frequency Stat
 */
export type code_frequency_stat = Array<number>;

// From: codeowners_errors.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A list of errors found in a repo's CODEOWNERS file
 */
export type codeowners_errors = {
    errors: Array<{
        /**
         * The line number where this errors occurs.
         */
        line: number;
        /**
         * The column number where this errors occurs.
         */
        column: number;
        /**
         * The contents of the line where the error occurs.
         */
        source?: string;
        /**
         * The type of error.
         */
        kind: string;
        /**
         * Suggested action to fix the error. This will usually be `null`, but is provided for some common errors.
         */
        suggestion?: string | null;
        /**
         * A human-readable description of the error, combining information from multiple fields, laid out for display in a monospaced typeface (for example, a command-line setting).
         */
        message: string;
        /**
         * The path of the file where the error occured.
         */
        path: string;
    }>;
};


// From: collaborator.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Collaborator
 */
export type collaborator = {
    login: string;
    id: number;
    email?: string | null;
    name?: string | null;
    node_id: string;
    avatar_url: string;
    gravatar_id: string | null;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    permissions?: {
        pull: boolean;
        triage?: boolean;
        push: boolean;
        maintain?: boolean;
        admin: boolean;
    };
    role_name: string;
    user_view_type?: string;
};


// From: combined_commit_status.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { minimal_repository } from './minimal_repository';
import type { simple_commit_status } from './simple_commit_status';
/**
 * Combined Commit Status
 */
export type combined_commit_status = {
    state: string;
    statuses: Array<simple_commit_status>;
    sha: string;
    total_count: number;
    repository: minimal_repository;
    commit_url: string;
    url: string;
};


// From: commit.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { diff_entry } from './diff_entry';
import type { empty_object } from './empty_object';
import type { nullable_git_user } from './nullable_git_user';
import type { simple_user } from './simple_user';
import type { verification } from './verification';
/**
 * Commit
 */
export type commit = {
    url: string;
    sha: string;
    node_id: string;
    html_url: string;
    comments_url: string;
    commit: {
        url: string;
        author: nullable_git_user;
        committer: nullable_git_user;
        message: string;
        comment_count: number;
        tree: {
            sha: string;
            url: string;
        };
        verification?: verification;
    };
    author: (simple_user | empty_object) | null;
    committer: (simple_user | empty_object) | null;
    parents: Array<{
        sha: string;
        url: string;
        html_url?: string;
    }>;
    stats?: {
        additions?: number;
        deletions?: number;
        total?: number;
    };
    files?: Array<diff_entry>;
};


// From: commit_activity.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Commit Activity
 */
export type commit_activity = {
    days: Array<number>;
    total: number;
    week: number;
};


// From: commit_comment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { nullable_simple_user } from './nullable_simple_user';
import type { reaction_rollup } from './reaction_rollup';
/**
 * Commit Comment
 */
export type commit_comment = {
    html_url: string;
    url: string;
    id: number;
    node_id: string;
    body: string;
    path: string | null;
    position: number | null;
    line: number | null;
    commit_id: string;
    user: nullable_simple_user;
    created_at: string;
    updated_at: string;
    author_association: author_association;
    reactions?: reaction_rollup;
};


// From: commit_comparison.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { commit } from './commit';
import type { diff_entry } from './diff_entry';
/**
 * Commit Comparison
 */
export type commit_comparison = {
    url: string;
    html_url: string;
    permalink_url: string;
    diff_url: string;
    patch_url: string;
    base_commit: commit;
    merge_base_commit: commit;
    status: commit_comparison.status;
    ahead_by: number;
    behind_by: number;
    total_commits: number;
    commits: Array<commit>;
    files?: Array<diff_entry>;
};
export namespace commit_comparison {
    export enum status {
        DIVERGED = 'diverged',
        AHEAD = 'ahead',
        BEHIND = 'behind',
        IDENTICAL = 'identical',
    }
}


// From: community_profile.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_code_of_conduct_simple } from './nullable_code_of_conduct_simple';
import type { nullable_community_health_file } from './nullable_community_health_file';
import type { nullable_license_simple } from './nullable_license_simple';
/**
 * Community Profile
 */
export type community_profile = {
    health_percentage: number;
    description: string | null;
    documentation: string | null;
    files: {
        code_of_conduct: nullable_code_of_conduct_simple;
        code_of_conduct_file: nullable_community_health_file;
        license: nullable_license_simple;
        contributing: nullable_community_health_file;
        readme: nullable_community_health_file;
        issue_template: nullable_community_health_file;
        pull_request_template: nullable_community_health_file;
    };
    updated_at: string | null;
    content_reports_enabled?: boolean;
};


// From: content_directory.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A list of directory items
 */
export type content_directory = Array<{
    type: 'dir' | 'file' | 'submodule' | 'symlink';
    size: number;
    name: string;
    path: string;
    content?: string;
    sha: string;
    url: string;
    git_url: string | null;
    html_url: string | null;
    download_url: string | null;
    _links: {
        git: string | null;
        html: string | null;
        self: string;
    };
}>;

// From: content_file.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Content File
 */
export type content_file = {
    type: content_file.type;
    encoding: string;
    size: number;
    name: string;
    path: string;
    content: string;
    sha: string;
    url: string;
    git_url: string | null;
    html_url: string | null;
    download_url: string | null;
    _links: {
        git: string | null;
        html: string | null;
        self: string;
    };
    target?: string;
    submodule_git_url?: string;
};
export namespace content_file {
    export enum type {
        FILE = 'file',
    }
}


// From: content_submodule.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * An object describing a submodule
 */
export type content_submodule = {
    type: content_submodule.type;
    submodule_git_url: string;
    size: number;
    name: string;
    path: string;
    sha: string;
    url: string;
    git_url: string | null;
    html_url: string | null;
    download_url: string | null;
    _links: {
        git: string | null;
        html: string | null;
        self: string;
    };
};
export namespace content_submodule {
    export enum type {
        SUBMODULE = 'submodule',
    }
}


// From: content_symlink.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * An object describing a symlink
 */
export type content_symlink = {
    type: content_symlink.type;
    target: string;
    size: number;
    name: string;
    path: string;
    sha: string;
    url: string;
    git_url: string | null;
    html_url: string | null;
    download_url: string | null;
    _links: {
        git: string | null;
        html: string | null;
        self: string;
    };
};
export namespace content_symlink {
    export enum type {
        SYMLINK = 'symlink',
    }
}


// From: content_traffic.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Content Traffic
 */
export type content_traffic = {
    path: string;
    title: string;
    count: number;
    uniques: number;
};


// From: contributor.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Contributor
 */
export type contributor = {
    login?: string;
    id?: number;
    node_id?: string;
    avatar_url?: string;
    gravatar_id?: string | null;
    url?: string;
    html_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    organizations_url?: string;
    repos_url?: string;
    events_url?: string;
    received_events_url?: string;
    type: string;
    site_admin?: boolean;
    contributions: number;
    email?: string;
    name?: string;
    user_view_type?: string;
};


// From: contributor_activity.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * Contributor Activity
 */
export type contributor_activity = {
    author: nullable_simple_user;
    total: number;
    weeks: Array<{
        'w'?: number;
        'a'?: number;
        'd'?: number;
        'c'?: number;
    }>;
};


// From: custom_deployment_rule_app.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A GitHub App that is providing a custom deployment protection rule.
 */
export type custom_deployment_rule_app = {
    /**
     * The unique identifier of the deployment protection rule integration.
     */
    id: number;
    /**
     * The slugified name of the deployment protection rule integration.
     */
    slug: string;
    /**
     * The URL for the endpoint to get details about the app.
     */
    integration_url: string;
    /**
     * The node ID for the deployment protection rule integration.
     */
    node_id: string;
};


// From: custom_property.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Custom property defined on an organization
 */
export type custom_property = {
    /**
     * The name of the property
     */
    property_name: string;
    /**
     * The URL that can be used to fetch, update, or delete info about this property via the API.
     */
    url?: string;
    /**
     * The source type of the property
     */
    source_type?: custom_property.source_type;
    /**
     * The type of the value for the property
     */
    value_type: custom_property.value_type;
    /**
     * Whether the property is required.
     */
    required?: boolean;
    /**
     * Default value of the property
     */
    default_value?: (string | Array<string>) | null;
    /**
     * Short description of the property
     */
    description?: string | null;
    /**
     * An ordered list of the allowed values of the property.
     * The property can have up to 200 allowed values.
     */
    allowed_values?: Array<string> | null;
    /**
     * Who can edit the values of the property
     */
    values_editable_by?: custom_property.values_editable_by | null;
};
export namespace custom_property {
    /**
     * The source type of the property
     */
    export enum source_type {
        ORGANIZATION = 'organization',
        ENTERPRISE = 'enterprise',
    }
    /**
     * The type of the value for the property
     */
    export enum value_type {
        STRING = 'string',
        SINGLE_SELECT = 'single_select',
        MULTI_SELECT = 'multi_select',
        TRUE_FALSE = 'true_false',
        URL = 'url',
    }
    /**
     * Who can edit the values of the property
     */
    export enum values_editable_by {
        ORG_ACTORS = 'org_actors',
        ORG_AND_REPO_ACTORS = 'org_and_repo_actors',
    }
}


// From: custom_property_set_payload.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Custom property set payload
 */
export type custom_property_set_payload = {
    /**
     * The type of the value for the property
     */
    value_type: custom_property_set_payload.value_type;
    /**
     * Whether the property is required.
     */
    required?: boolean;
    /**
     * Default value of the property
     */
    default_value?: (string | Array<string>) | null;
    /**
     * Short description of the property
     */
    description?: string | null;
    /**
     * An ordered list of the allowed values of the property.
     * The property can have up to 200 allowed values.
     */
    allowed_values?: Array<string> | null;
    /**
     * Who can edit the values of the property
     */
    values_editable_by?: custom_property_set_payload.values_editable_by | null;
};
export namespace custom_property_set_payload {
    /**
     * The type of the value for the property
     */
    export enum value_type {
        STRING = 'string',
        SINGLE_SELECT = 'single_select',
        MULTI_SELECT = 'multi_select',
        TRUE_FALSE = 'true_false',
        URL = 'url',
    }
    /**
     * Who can edit the values of the property
     */
    export enum values_editable_by {
        ORG_ACTORS = 'org_actors',
        ORG_AND_REPO_ACTORS = 'org_and_repo_actors',
    }
}


// From: custom_property_value.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Custom property name and associated value
 */
export type custom_property_value = {
    /**
     * The name of the property
     */
    property_name: string;
    /**
     * The value assigned to the property
     */
    value: (string | Array<string>) | null;
};


// From: deploy_key.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * An SSH key granting access to a single repository.
 */
export type deploy_key = {
    id: number;
    key: string;
    url: string;
    title: string;
    verified: boolean;
    created_at: string;
    read_only: boolean;
    added_by?: string | null;
    last_used?: string | null;
    enabled?: boolean;
};


// From: deployment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_integration } from './nullable_integration';
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * A request for a specific ref(branch,sha,tag) to be deployed
 */
export type deployment = {
    url: string;
    /**
     * Unique identifier of the deployment
     */
    id: number;
    node_id: string;
    sha: string;
    /**
     * The ref to deploy. This can be a branch, tag, or sha.
     */
    ref: string;
    /**
     * Parameter to specify a task to execute
     */
    task: string;
    payload: (Record<string, any> | string);
    original_environment?: string;
    /**
     * Name for the target deployment environment.
     */
    environment: string;
    description: string | null;
    creator: nullable_simple_user;
    created_at: string;
    updated_at: string;
    statuses_url: string;
    repository_url: string;
    /**
     * Specifies if the given environment is will no longer exist at some point in the future. Default: false.
     */
    transient_environment?: boolean;
    /**
     * Specifies if the given environment is one that end-users directly interact with. Default: false.
     */
    production_environment?: boolean;
    performed_via_github_app?: nullable_integration;
};


// From: deployment_branch_policy.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Details of a deployment branch or tag policy.
 */
export type deployment_branch_policy = {
    /**
     * The unique identifier of the branch or tag policy.
     */
    id?: number;
    node_id?: string;
    /**
     * The name pattern that branches or tags must match in order to deploy to the environment.
     */
    name?: string;
    /**
     * Whether this rule targets a branch or tag.
     */
    type?: deployment_branch_policy.type;
};
export namespace deployment_branch_policy {
    /**
     * Whether this rule targets a branch or tag.
     */
    export enum type {
        BRANCH = 'branch',
        TAG = 'tag',
    }
}


// From: deployment_branch_policy_name_pattern.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type deployment_branch_policy_name_pattern = {
    /**
     * The name pattern that branches must match in order to deploy to the environment.
     *
     * Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release**`.
     * For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).
     */
    name: string;
};


// From: deployment_branch_policy_name_pattern_with_type.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type deployment_branch_policy_name_pattern_with_type = {
    /**
     * The name pattern that branches or tags must match in order to deploy to the environment.
     *
     * Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release**`.
     * For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).
     */
    name: string;
    /**
     * Whether this rule targets a branch or tag
     */
    type?: deployment_branch_policy_name_pattern_with_type.type;
};
export namespace deployment_branch_policy_name_pattern_with_type {
    /**
     * Whether this rule targets a branch or tag
     */
    export enum type {
        BRANCH = 'branch',
        TAG = 'tag',
    }
}


// From: deployment_branch_policy_settings.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
 */
export type deployment_branch_policy_settings = {
    /**
     * Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.
     */
    protected_branches: boolean;
    /**
     * Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.
     */
    custom_branch_policies: boolean;
};


// From: deployment_protection_rule.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { custom_deployment_rule_app } from './custom_deployment_rule_app';
/**
 * Deployment protection rule
 */
export type deployment_protection_rule = {
    /**
     * The unique identifier for the deployment protection rule.
     */
    id: number;
    /**
     * The node ID for the deployment protection rule.
     */
    node_id: string;
    /**
     * Whether the deployment protection rule is enabled for the environment.
     */
    enabled: boolean;
    app: custom_deployment_rule_app;
};


// From: deployment_reviewer_type.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The type of reviewer.
 */
export enum deployment_reviewer_type {
    USER = 'User',
    TEAM = 'Team',
}

// From: deployment_status.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_integration } from './nullable_integration';
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * The status of a deployment.
 */
export type deployment_status = {
    url: string;
    id: number;
    node_id: string;
    /**
     * The state of the status.
     */
    state: deployment_status.state;
    creator: nullable_simple_user;
    /**
     * A short description of the status.
     */
    description: string;
    /**
     * The environment of the deployment that the status is for.
     */
    environment?: string;
    /**
     * Closing down notice: the URL to associate with this status.
     */
    target_url: string;
    created_at: string;
    updated_at: string;
    deployment_url: string;
    repository_url: string;
    /**
     * The URL for accessing your environment.
     */
    environment_url?: string;
    /**
     * The URL to associate with this status.
     */
    log_url?: string;
    performed_via_github_app?: nullable_integration;
};
export namespace deployment_status {
    /**
     * The state of the status.
     */
    export enum state {
        ERROR = 'error',
        FAILURE = 'failure',
        INACTIVE = 'inactive',
        PENDING = 'pending',
        SUCCESS = 'success',
        QUEUED = 'queued',
        IN_PROGRESS = 'in_progress',
    }
}


// From: diff_entry.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Diff Entry
 */
export type diff_entry = {
    sha: string | null;
    filename: string;
    status: diff_entry.status;
    additions: number;
    deletions: number;
    changes: number;
    blob_url: string;
    raw_url: string;
    contents_url: string;
    patch?: string;
    previous_filename?: string;
};
export namespace diff_entry {
    export enum status {
        ADDED = 'added',
        REMOVED = 'removed',
        MODIFIED = 'modified',
        RENAMED = 'renamed',
        COPIED = 'copied',
        CHANGED = 'changed',
        UNCHANGED = 'unchanged',
    }
}


// From: email.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Email
 */
export type email = {
    email: string;
    primary: boolean;
    verified: boolean;
    visibility: string | null;
};


// From: empty_object.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * An object without any properties.
 */
export type empty_object = {
};


// From: enabled_repositories.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The policy that controls the repositories in the organization that are allowed to run GitHub Actions.
 */
export enum enabled_repositories {
    ALL = 'all',
    NONE = 'none',
    SELECTED = 'selected',
}

// From: environment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { deployment_branch_policy_settings } from './deployment_branch_policy_settings';
import type { deployment_reviewer_type } from './deployment_reviewer_type';
import type { simple_user } from './simple_user';
import type { team } from './team';
import type { wait_timer } from './wait_timer';
/**
 * Details of a deployment environment
 */
export type environment = {
    /**
     * The id of the environment.
     */
    id: number;
    node_id: string;
    /**
     * The name of the environment.
     */
    name: string;
    url: string;
    html_url: string;
    /**
     * The time that the environment was created, in ISO 8601 format.
     */
    created_at: string;
    /**
     * The time that the environment was last updated, in ISO 8601 format.
     */
    updated_at: string;
    /**
     * Built-in deployment protection rules for the environment.
     */
    protection_rules?: Array<({
        id: number;
        node_id: string;
        type: string;
        wait_timer?: wait_timer;
    } | {
        id: number;
        node_id: string;
        /**
         * Whether deployments to this environment can be approved by the user who created the deployment.
         */
        prevent_self_review?: boolean;
        type: string;
        /**
         * The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
         */
        reviewers?: Array<{
            type?: deployment_reviewer_type;
            reviewer?: (simple_user | team);
        }>;
    } | {
        id: number;
        node_id: string;
        type: string;
    })>;
    deployment_branch_policy?: deployment_branch_policy_settings;
};


// From: environment_approvals.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { simple_user } from './simple_user';
/**
 * An entry in the reviews log for environment deployments
 */
export type environment_approvals = {
    /**
     * The list of environments that were approved or rejected
     */
    environments: Array<{
        /**
         * The id of the environment.
         */
        id?: number;
        node_id?: string;
        /**
         * The name of the environment.
         */
        name?: string;
        url?: string;
        html_url?: string;
        /**
         * The time that the environment was created, in ISO 8601 format.
         */
        created_at?: string;
        /**
         * The time that the environment was last updated, in ISO 8601 format.
         */
        updated_at?: string;
    }>;
    /**
     * Whether deployment to the environment(s) was approved or rejected or pending (with comments)
     */
    state: environment_approvals.state;
    user: simple_user;
    /**
     * The comment submitted with the deployment review
     */
    comment: string;
};
export namespace environment_approvals {
    /**
     * Whether deployment to the environment(s) was approved or rejected or pending (with comments)
     */
    export enum state {
        APPROVED = 'approved',
        REJECTED = 'rejected',
        PENDING = 'pending',
    }
}


// From: event.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
 */
export type event = string;

// From: feed.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { link_with_type } from './link_with_type';
/**
 * Feed
 */
export type feed = {
    timeline_url: string;
    user_url: string;
    current_user_public_url?: string;
    current_user_url?: string;
    current_user_actor_url?: string;
    current_user_organization_url?: string;
    current_user_organization_urls?: Array<string>;
    security_advisories_url?: string;
    /**
     * A feed of discussions for a given repository.
     */
    repository_discussions_url?: string;
    /**
     * A feed of discussions for a given repository and category.
     */
    repository_discussions_category_url?: string;
    _links: {
        timeline: link_with_type;
        user: link_with_type;
        security_advisories?: link_with_type;
        current_user?: link_with_type;
        current_user_public?: link_with_type;
        current_user_actor?: link_with_type;
        current_user_organization?: link_with_type;
        current_user_organizations?: Array<link_with_type>;
        repository_discussions?: link_with_type;
        repository_discussions_category?: link_with_type;
    };
};


// From: file_commit.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * File Commit
 */
export type file_commit = {
    content: {
        name?: string;
        path?: string;
        sha?: string;
        size?: number;
        url?: string;
        html_url?: string;
        git_url?: string;
        download_url?: string;
        type?: string;
        _links?: {
            self?: string;
            git?: string;
            html?: string;
        };
    } | null;
    commit: {
        sha?: string;
        node_id?: string;
        url?: string;
        html_url?: string;
        author?: {
            date?: string;
            name?: string;
            email?: string;
        };
        committer?: {
            date?: string;
            name?: string;
            email?: string;
        };
        message?: string;
        tree?: {
            url?: string;
            sha?: string;
        };
        parents?: Array<{
            url?: string;
            html_url?: string;
            sha?: string;
        }>;
        verification?: {
            verified?: boolean;
            reason?: string;
            signature?: string | null;
            payload?: string | null;
            verified_at?: string | null;
        };
    };
};


// From: full_repository.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { code_of_conduct_simple } from './code_of_conduct_simple';
import type { nullable_license_simple } from './nullable_license_simple';
import type { nullable_repository } from './nullable_repository';
import type { nullable_simple_user } from './nullable_simple_user';
import type { repository } from './repository';
import type { security_and_analysis } from './security_and_analysis';
import type { simple_user } from './simple_user';
/**
 * Full Repository
 */
export type full_repository = {
    id: number;
    node_id: string;
    name: string;
    full_name: string;
    owner: simple_user;
    private: boolean;
    html_url: string;
    description: string | null;
    fork: boolean;
    url: string;
    archive_url: string;
    assignees_url: string;
    blobs_url: string;
    branches_url: string;
    collaborators_url: string;
    comments_url: string;
    commits_url: string;
    compare_url: string;
    contents_url: string;
    contributors_url: string;
    deployments_url: string;
    downloads_url: string;
    events_url: string;
    forks_url: string;
    git_commits_url: string;
    git_refs_url: string;
    git_tags_url: string;
    git_url: string;
    issue_comment_url: string;
    issue_events_url: string;
    issues_url: string;
    keys_url: string;
    labels_url: string;
    languages_url: string;
    merges_url: string;
    milestones_url: string;
    notifications_url: string;
    pulls_url: string;
    releases_url: string;
    ssh_url: string;
    stargazers_url: string;
    statuses_url: string;
    subscribers_url: string;
    subscription_url: string;
    tags_url: string;
    teams_url: string;
    trees_url: string;
    clone_url: string;
    mirror_url: string | null;
    hooks_url: string;
    svn_url: string;
    homepage: string | null;
    language: string | null;
    forks_count: number;
    stargazers_count: number;
    watchers_count: number;
    /**
     * The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
     */
    size: number;
    default_branch: string;
    open_issues_count: number;
    is_template?: boolean;
    topics?: Array<string>;
    has_issues: boolean;
    has_projects: boolean;
    has_wiki: boolean;
    has_pages: boolean;
    has_downloads?: boolean;
    has_discussions: boolean;
    archived: boolean;
    /**
     * Returns whether or not this repository disabled.
     */
    disabled: boolean;
    /**
     * The repository visibility: public, private, or internal.
     */
    visibility?: string;
    pushed_at: string;
    created_at: string;
    updated_at: string;
    permissions?: {
        admin: boolean;
        maintain?: boolean;
        push: boolean;
        triage?: boolean;
        pull: boolean;
    };
    allow_rebase_merge?: boolean;
    template_repository?: nullable_repository;
    temp_clone_token?: string | null;
    allow_squash_merge?: boolean;
    allow_auto_merge?: boolean;
    delete_branch_on_merge?: boolean;
    allow_merge_commit?: boolean;
    allow_update_branch?: boolean;
    use_squash_pr_title_as_default?: boolean;
    /**
     * The default value for a squash merge commit title:
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
     */
    squash_merge_commit_title?: full_repository.squash_merge_commit_title;
    /**
     * The default value for a squash merge commit message:
     *
     * - `PR_BODY` - default to the pull request's body.
     * - `COMMIT_MESSAGES` - default to the branch's commit messages.
     * - `BLANK` - default to a blank commit message.
     */
    squash_merge_commit_message?: full_repository.squash_merge_commit_message;
    /**
     * The default value for a merge commit title.
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
     */
    merge_commit_title?: full_repository.merge_commit_title;
    /**
     * The default value for a merge commit message.
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `PR_BODY` - default to the pull request's body.
     * - `BLANK` - default to a blank commit message.
     */
    merge_commit_message?: full_repository.merge_commit_message;
    allow_forking?: boolean;
    web_commit_signoff_required?: boolean;
    subscribers_count: number;
    network_count: number;
    license: nullable_license_simple;
    organization?: nullable_simple_user;
    parent?: repository;
    source?: repository;
    forks: number;
    master_branch?: string;
    open_issues: number;
    watchers: number;
    /**
     * Whether anonymous git access is allowed.
     */
    anonymous_access_enabled?: boolean;
    code_of_conduct?: code_of_conduct_simple;
    security_and_analysis?: security_and_analysis;
    /**
     * The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
     */
    custom_properties?: Record<string, any>;
};
export namespace full_repository {
    /**
     * The default value for a squash merge commit title:
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
     */
    export enum squash_merge_commit_title {
        PR_TITLE = 'PR_TITLE',
        COMMIT_OR_PR_TITLE = 'COMMIT_OR_PR_TITLE',
    }
    /**
     * The default value for a squash merge commit message:
     *
     * - `PR_BODY` - default to the pull request's body.
     * - `COMMIT_MESSAGES` - default to the branch's commit messages.
     * - `BLANK` - default to a blank commit message.
     */
    export enum squash_merge_commit_message {
        PR_BODY = 'PR_BODY',
        COMMIT_MESSAGES = 'COMMIT_MESSAGES',
        BLANK = 'BLANK',
    }
    /**
     * The default value for a merge commit title.
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
     */
    export enum merge_commit_title {
        PR_TITLE = 'PR_TITLE',
        MERGE_MESSAGE = 'MERGE_MESSAGE',
    }
    /**
     * The default value for a merge commit message.
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `PR_BODY` - default to the pull request's body.
     * - `BLANK` - default to a blank commit message.
     */
    export enum merge_commit_message {
        PR_BODY = 'PR_BODY',
        PR_TITLE = 'PR_TITLE',
        BLANK = 'BLANK',
    }
}


// From: gist_comment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * A comment made to a gist.
 */
export type gist_comment = {
    id: number;
    node_id: string;
    url: string;
    /**
     * The comment text.
     */
    body: string;
    user: nullable_simple_user;
    created_at: string;
    updated_at: string;
    author_association: author_association;
};


// From: gist_commit.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * Gist Commit
 */
export type gist_commit = {
    url: string;
    version: string;
    user: nullable_simple_user;
    change_status: {
        total?: number;
        additions?: number;
        deletions?: number;
    };
    committed_at: string;
};


// From: gist_simple.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { gist_history } from './gist_history';
import type { nullable_simple_user } from './nullable_simple_user';
import type { public_user } from './public_user';
import type { simple_user } from './simple_user';
/**
 * Gist Simple
 */
export type gist_simple = {
    /**
     * @deprecated
     */
    forks?: Array<{
        id?: string;
        url?: string;
        user?: public_user;
        created_at?: string;
        updated_at?: string;
    }> | null;
    /**
     * @deprecated
     */
    history?: Array<gist_history> | null;
    /**
     * Gist
     */
    fork_of?: {
        url: string;
        forks_url: string;
        commits_url: string;
        id: string;
        node_id: string;
        git_pull_url: string;
        git_push_url: string;
        html_url: string;
        files: Record<string, {
            filename?: string;
            type?: string;
            language?: string;
            raw_url?: string;
            size?: number;
        }>;
        public: boolean;
        created_at: string;
        updated_at: string;
        description: string | null;
        comments: number;
        comments_enabled?: boolean;
        user: nullable_simple_user;
        comments_url: string;
        owner?: nullable_simple_user;
        truncated?: boolean;
        forks?: Array<any>;
        history?: Array<any>;
    } | null;
    url?: string;
    forks_url?: string;
    commits_url?: string;
    id?: string;
    node_id?: string;
    git_pull_url?: string;
    git_push_url?: string;
    html_url?: string;
    files?: Record<string, {
        filename?: string;
        type?: string;
        language?: string;
        raw_url?: string;
        size?: number;
        truncated?: boolean;
        content?: string;
        /**
         * The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.
         */
        encoding?: string;
    } | null>;
    public?: boolean;
    created_at?: string;
    updated_at?: string;
    description?: string | null;
    comments?: number;
    comments_enabled?: boolean;
    user?: string | null;
    comments_url?: string;
    owner?: simple_user;
    truncated?: boolean;
};


// From: gpg_key.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A unique encryption key
 */
export type gpg_key = {
    id: number;
    name?: string | null;
    primary_key_id: number | null;
    key_id: string;
    public_key: string;
    emails: Array<{
        email?: string;
        verified?: boolean;
    }>;
    subkeys: Array<{
        id?: number;
        primary_key_id?: number;
        key_id?: string;
        public_key?: string;
        emails?: Array<{
            email?: string;
            verified?: boolean;
        }>;
        subkeys?: Array<any>;
        can_sign?: boolean;
        can_encrypt_comms?: boolean;
        can_encrypt_storage?: boolean;
        can_certify?: boolean;
        created_at?: string;
        expires_at?: string | null;
        raw_key?: string | null;
        revoked?: boolean;
    }>;
    can_sign: boolean;
    can_encrypt_comms: boolean;
    can_encrypt_storage: boolean;
    can_certify: boolean;
    created_at: string;
    expires_at: string | null;
    revoked: boolean;
    raw_key: string | null;
};


// From: hook.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { hook_response } from './hook_response';
import type { webhook_config } from './webhook_config';
/**
 * Webhooks for repositories.
 */
export type hook = {
    type: string;
    /**
     * Unique identifier of the webhook.
     */
    id: number;
    /**
     * The name of a valid service, use 'web' for a webhook.
     */
    name: string;
    /**
     * Determines whether the hook is actually triggered on pushes.
     */
    active: boolean;
    /**
     * Determines what events the hook is triggered for. Default: ['push'].
     */
    events: Array<string>;
    config: webhook_config;
    updated_at: string;
    created_at: string;
    url: string;
    test_url: string;
    ping_url: string;
    deliveries_url?: string;
    last_response: hook_response;
};


// From: hook_delivery.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Delivery made by a webhook.
 */
export type hook_delivery = {
    /**
     * Unique identifier of the delivery.
     */
    id: number;
    /**
     * Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
     */
    guid: string;
    /**
     * Time when the delivery was delivered.
     */
    delivered_at: string;
    /**
     * Whether the delivery is a redelivery.
     */
    redelivery: boolean;
    /**
     * Time spent delivering.
     */
    duration: number;
    /**
     * Description of the status of the attempted delivery
     */
    status: string;
    /**
     * Status code received when delivery was made.
     */
    status_code: number;
    /**
     * The event that triggered the delivery.
     */
    event: string;
    /**
     * The type of activity for the event that triggered the delivery.
     */
    action: string | null;
    /**
     * The id of the GitHub App installation associated with this event.
     */
    installation_id: number | null;
    /**
     * The id of the repository associated with this event.
     */
    repository_id: number | null;
    /**
     * Time when the webhook delivery was throttled.
     */
    throttled_at?: string | null;
    /**
     * The URL target of the delivery.
     */
    url?: string;
    request: {
        /**
         * The request headers sent with the webhook delivery.
         */
        headers: Record<string, any> | null;
        /**
         * The webhook payload.
         */
        payload: Record<string, any> | null;
    };
    response: {
        /**
         * The response headers received when the delivery was made.
         */
        headers: Record<string, any> | null;
        /**
         * The response payload received.
         */
        payload: string | null;
    };
};


// From: hook_delivery_item.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Delivery made by a webhook, without request and response information.
 */
export type hook_delivery_item = {
    /**
     * Unique identifier of the webhook delivery.
     */
    id: number;
    /**
     * Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
     */
    guid: string;
    /**
     * Time when the webhook delivery occurred.
     */
    delivered_at: string;
    /**
     * Whether the webhook delivery is a redelivery.
     */
    redelivery: boolean;
    /**
     * Time spent delivering.
     */
    duration: number;
    /**
     * Describes the response returned after attempting the delivery.
     */
    status: string;
    /**
     * Status code received when delivery was made.
     */
    status_code: number;
    /**
     * The event that triggered the delivery.
     */
    event: string;
    /**
     * The type of activity for the event that triggered the delivery.
     */
    action: string | null;
    /**
     * The id of the GitHub App installation associated with this event.
     */
    installation_id: number | null;
    /**
     * The id of the repository associated with this event.
     */
    repository_id: number | null;
    /**
     * Time when the webhook delivery was throttled.
     */
    throttled_at?: string | null;
};


// From: hovercard.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Hovercard
 */
export type hovercard = {
    contexts: Array<{
        message: string;
        octicon: string;
    }>;
};


// From: immutable_releases_organization_settings.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Check immutable releases settings for an organization.
 */
export type immutable_releases_organization_settings = {
    /**
     * The policy that controls how immutable releases are enforced in the organization.
     */
    enforced_repositories: immutable_releases_organization_settings.enforced_repositories;
    /**
     * The API URL to use to get or set the selected repositories for immutable releases enforcement, when `enforced_repositories` is set to `selected`.
     */
    selected_repositories_url?: string;
};
export namespace immutable_releases_organization_settings {
    /**
     * The policy that controls how immutable releases are enforced in the organization.
     */
    export enum enforced_repositories {
        ALL = 'all',
        NONE = 'none',
        SELECTED = 'selected',
    }
}


// From: installation.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { app_permissions } from './app_permissions';
import type { enterprise } from './enterprise';
import type { nullable_simple_user } from './nullable_simple_user';
import type { simple_user } from './simple_user';
/**
 * Installation
 */
export type installation = {
    /**
     * The ID of the installation.
     */
    id: number;
    account: (simple_user | enterprise) | null;
    /**
     * Describe whether all repositories have been selected or there's a selection involved
     */
    repository_selection: installation.repository_selection;
    access_tokens_url: string;
    repositories_url: string;
    html_url: string;
    app_id: number;
    client_id?: string;
    /**
     * The ID of the user or organization this token is being scoped to.
     */
    target_id: number;
    target_type: string;
    permissions: app_permissions;
    events: Array<string>;
    created_at: string;
    updated_at: string;
    single_file_name: string | null;
    has_multiple_single_files?: boolean;
    single_file_paths?: Array<string>;
    app_slug: string;
    suspended_by: nullable_simple_user;
    suspended_at: string | null;
    contact_email?: string | null;
};
export namespace installation {
    /**
     * Describe whether all repositories have been selected or there's a selection involved
     */
    export enum repository_selection {
        ALL = 'all',
        SELECTED = 'selected',
    }
}


// From: integration.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { enterprise } from './enterprise';
import type { simple_user } from './simple_user';
/**
 * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
 */
export type integration = {
    /**
     * Unique identifier of the GitHub app
     */
    id: number;
    /**
     * The slug name of the GitHub app
     */
    slug?: string;
    node_id: string;
    client_id?: string;
    owner: (simple_user | enterprise);
    /**
     * The name of the GitHub app
     */
    name: string;
    description: string | null;
    external_url: string;
    html_url: string;
    created_at: string;
    updated_at: string;
    /**
     * The set of permissions for the GitHub app
     */
    permissions: Record<string, string>;
    /**
     * The list of events for the GitHub app. Note that the `installation_target`, `security_advisory`, and `meta` events are not included because they are global events and not specific to an installation.
     */
    events: Array<string>;
    /**
     * The number of installations associated with the GitHub app. Only returned when the integration is requesting details about itself.
     */
    installations_count?: number;
};


// From: issue.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { issue_dependencies_summary } from './issue_dependencies_summary';
import type { issue_field_value } from './issue_field_value';
import type { issue_type } from './issue_type';
import type { nullable_integration } from './nullable_integration';
import type { nullable_milestone } from './nullable_milestone';
import type { nullable_simple_user } from './nullable_simple_user';
import type { reaction_rollup } from './reaction_rollup';
import type { repository } from './repository';
import type { simple_user } from './simple_user';
import type { sub_issues_summary } from './sub_issues_summary';
/**
 * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
 */
export type issue = {
    id: number;
    node_id: string;
    /**
     * URL for the issue
     */
    url: string;
    repository_url: string;
    labels_url: string;
    comments_url: string;
    events_url: string;
    html_url: string;
    /**
     * Number uniquely identifying the issue within its repository
     */
    number: number;
    /**
     * State of the issue; either 'open' or 'closed'
     */
    state: string;
    /**
     * The reason for the current state
     */
    state_reason?: issue.state_reason | null;
    /**
     * Title of the issue
     */
    title: string;
    /**
     * Contents of the issue
     */
    body?: string | null;
    user: nullable_simple_user;
    /**
     * Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository
     */
    labels: Array<(string | {
        id?: number;
        node_id?: string;
        url?: string;
        name?: string;
        description?: string | null;
        color?: string | null;
        default?: boolean;
    })>;
    assignee: nullable_simple_user;
    assignees?: Array<simple_user> | null;
    milestone: nullable_milestone;
    locked: boolean;
    active_lock_reason?: string | null;
    comments: number;
    pull_request?: {
        merged_at?: string | null;
        diff_url: string | null;
        html_url: string | null;
        patch_url: string | null;
        url: string | null;
    };
    closed_at: string | null;
    created_at: string;
    updated_at: string;
    draft?: boolean;
    closed_by?: nullable_simple_user;
    body_html?: string;
    body_text?: string;
    timeline_url?: string;
    type?: issue_type;
    repository?: repository;
    performed_via_github_app?: nullable_integration;
    author_association?: author_association;
    reactions?: reaction_rollup;
    sub_issues_summary?: sub_issues_summary;
    /**
     * URL to get the parent issue of this issue, if it is a sub-issue
     */
    parent_issue_url?: string | null;
    issue_dependencies_summary?: issue_dependencies_summary;
    issue_field_values?: Array<issue_field_value>;
};
export namespace issue {
    /**
     * The reason for the current state
     */
    export enum state_reason {
        COMPLETED = 'completed',
        REOPENED = 'reopened',
        NOT_PLANNED = 'not_planned',
        DUPLICATE = 'duplicate',
    }
}


// From: issue_comment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { nullable_integration } from './nullable_integration';
import type { nullable_simple_user } from './nullable_simple_user';
import type { reaction_rollup } from './reaction_rollup';
/**
 * Comments provide a way for people to collaborate on an issue.
 */
export type issue_comment = {
    /**
     * Unique identifier of the issue comment
     */
    id: number;
    node_id: string;
    /**
     * URL for the issue comment
     */
    url: string;
    /**
     * Contents of the issue comment
     */
    body?: string;
    body_text?: string;
    body_html?: string;
    html_url: string;
    user: nullable_simple_user;
    created_at: string;
    updated_at: string;
    issue_url: string;
    author_association?: author_association;
    performed_via_github_app?: nullable_integration;
    reactions?: reaction_rollup;
};


// From: issue_event.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { issue_event_dismissed_review } from './issue_event_dismissed_review';
import type { issue_event_label } from './issue_event_label';
import type { issue_event_milestone } from './issue_event_milestone';
import type { issue_event_project_card } from './issue_event_project_card';
import type { issue_event_rename } from './issue_event_rename';
import type { nullable_integration } from './nullable_integration';
import type { nullable_issue } from './nullable_issue';
import type { nullable_simple_user } from './nullable_simple_user';
import type { team } from './team';
/**
 * Issue Event
 */
export type issue_event = {
    id: number;
    node_id: string;
    url: string;
    actor: nullable_simple_user;
    event: string;
    commit_id: string | null;
    commit_url: string | null;
    created_at: string;
    issue?: nullable_issue;
    label?: issue_event_label;
    assignee?: nullable_simple_user;
    assigner?: nullable_simple_user;
    review_requester?: nullable_simple_user;
    requested_reviewer?: nullable_simple_user;
    requested_team?: team;
    dismissed_review?: issue_event_dismissed_review;
    milestone?: issue_event_milestone;
    project_card?: issue_event_project_card;
    rename?: issue_event_rename;
    author_association?: author_association;
    lock_reason?: string | null;
    performed_via_github_app?: nullable_integration;
};


// From: issue_event_for_issue.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { added_to_project_issue_event } from './added_to_project_issue_event';
import type { assigned_issue_event } from './assigned_issue_event';
import type { converted_note_to_issue_issue_event } from './converted_note_to_issue_issue_event';
import type { demilestoned_issue_event } from './demilestoned_issue_event';
import type { labeled_issue_event } from './labeled_issue_event';
import type { locked_issue_event } from './locked_issue_event';
import type { milestoned_issue_event } from './milestoned_issue_event';
import type { moved_column_in_project_issue_event } from './moved_column_in_project_issue_event';
import type { removed_from_project_issue_event } from './removed_from_project_issue_event';
import type { renamed_issue_event } from './renamed_issue_event';
import type { review_dismissed_issue_event } from './review_dismissed_issue_event';
import type { review_request_removed_issue_event } from './review_request_removed_issue_event';
import type { review_requested_issue_event } from './review_requested_issue_event';
import type { unassigned_issue_event } from './unassigned_issue_event';
import type { unlabeled_issue_event } from './unlabeled_issue_event';
/**
 * Issue Event for Issue
 */
export type issue_event_for_issue = (labeled_issue_event | unlabeled_issue_event | assigned_issue_event | unassigned_issue_event | milestoned_issue_event | demilestoned_issue_event | renamed_issue_event | review_requested_issue_event | review_request_removed_issue_event | review_dismissed_issue_event | locked_issue_event | added_to_project_issue_event | moved_column_in_project_issue_event | removed_from_project_issue_event | converted_note_to_issue_issue_event);


// From: issue_type.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The type of issue.
 */
export type issue_type = {
    /**
     * The unique identifier of the issue type.
     */
    id: number;
    /**
     * The node identifier of the issue type.
     */
    node_id: string;
    /**
     * The name of the issue type.
     */
    name: string;
    /**
     * The description of the issue type.
     */
    description: string | null;
    /**
     * The color of the issue type.
     */
    color?: issue_type.color | null;
    /**
     * The time the issue type created.
     */
    created_at?: string;
    /**
     * The time the issue type last updated.
     */
    updated_at?: string;
    /**
     * The enabled state of the issue type.
     */
    is_enabled?: boolean;
};
export namespace issue_type {
    /**
     * The color of the issue type.
     */
    export enum color {
        GRAY = 'gray',
        BLUE = 'blue',
        GREEN = 'green',
        YELLOW = 'yellow',
        ORANGE = 'orange',
        RED = 'red',
        PINK = 'pink',
        PURPLE = 'purple',
    }
}


// From: job.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Information of a job execution in a workflow run
 */
export type job = {
    /**
     * The id of the job.
     */
    id: number;
    /**
     * The id of the associated workflow run.
     */
    run_id: number;
    run_url: string;
    /**
     * Attempt number of the associated workflow run, 1 for first attempt and higher if the workflow was re-run.
     */
    run_attempt?: number;
    node_id: string;
    /**
     * The SHA of the commit that is being run.
     */
    head_sha: string;
    url: string;
    html_url: string | null;
    /**
     * The phase of the lifecycle that the job is currently in.
     */
    status: job.status;
    /**
     * The outcome of the job.
     */
    conclusion: job.conclusion | null;
    /**
     * The time that the job created, in ISO 8601 format.
     */
    created_at: string;
    /**
     * The time that the job started, in ISO 8601 format.
     */
    started_at: string;
    /**
     * The time that the job finished, in ISO 8601 format.
     */
    completed_at: string | null;
    /**
     * The name of the job.
     */
    name: string;
    /**
     * Steps in this job.
     */
    steps?: Array<{
        /**
         * The phase of the lifecycle that the job is currently in.
         */
        status: 'queued' | 'in_progress' | 'completed';
        /**
         * The outcome of the job.
         */
        conclusion: string | null;
        /**
         * The name of the job.
         */
        name: string;
        number: number;
        /**
         * The time that the step started, in ISO 8601 format.
         */
        started_at?: string | null;
        /**
         * The time that the job finished, in ISO 8601 format.
         */
        completed_at?: string | null;
    }>;
    check_run_url: string;
    /**
     * Labels for the workflow job. Specified by the "runs_on" attribute in the action's workflow file.
     */
    labels: Array<string>;
    /**
     * The ID of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
     */
    runner_id: number | null;
    /**
     * The name of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
     */
    runner_name: string | null;
    /**
     * The ID of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
     */
    runner_group_id: number | null;
    /**
     * The name of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
     */
    runner_group_name: string | null;
    /**
     * The name of the workflow.
     */
    workflow_name: string | null;
    /**
     * The name of the current branch.
     */
    head_branch: string | null;
};
export namespace job {
    /**
     * The phase of the lifecycle that the job is currently in.
     */
    export enum status {
        QUEUED = 'queued',
        IN_PROGRESS = 'in_progress',
        COMPLETED = 'completed',
        WAITING = 'waiting',
        REQUESTED = 'requested',
        PENDING = 'pending',
    }
    /**
     * The outcome of the job.
     */
    export enum conclusion {
        SUCCESS = 'success',
        FAILURE = 'failure',
        NEUTRAL = 'neutral',
        CANCELLED = 'cancelled',
        SKIPPED = 'skipped',
        TIMED_OUT = 'timed_out',
        ACTION_REQUIRED = 'action_required',
    }
}


// From: key.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Key
 */
export type key = {
    key: string;
    id: number;
    url: string;
    title: string;
    created_at: string;
    verified: boolean;
    read_only: boolean;
    last_used?: string | null;
};


// From: key_simple.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Key Simple
 */
export type key_simple = {
    id: number;
    key: string;
    created_at?: string;
    last_used?: string | null;
};


// From: label.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Color-coded labels help you categorize and filter your issues (just like labels in Gmail).
 */
export type label = {
    /**
     * Unique identifier for the label.
     */
    id: number;
    node_id: string;
    /**
     * URL for the label
     */
    url: string;
    /**
     * The name of the label.
     */
    name: string;
    /**
     * Optional description of the label, such as its purpose.
     */
    description: string | null;
    /**
     * 6-character hex code, without the leading #, identifying the color
     */
    color: string;
    /**
     * Whether this label comes by default in a new repository.
     */
    default: boolean;
};


// From: language.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Language
 */
export type language = Record<string, number>;

// From: merged_upstream.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Results of a successful merge upstream request
 */
export type merged_upstream = {
    message?: string;
    merge_type?: merged_upstream.merge_type;
    base_branch?: string;
};
export namespace merged_upstream {
    export enum merge_type {
        MERGE = 'merge',
        FAST_FORWARD = 'fast-forward',
        NONE = 'none',
    }
}


// From: milestone.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * A collection of related issues and pull requests.
 */
export type milestone = {
    url: string;
    html_url: string;
    labels_url: string;
    id: number;
    node_id: string;
    /**
     * The number of the milestone.
     */
    number: number;
    /**
     * The state of the milestone.
     */
    state: milestone.state;
    /**
     * The title of the milestone.
     */
    title: string;
    description: string | null;
    creator: nullable_simple_user;
    open_issues: number;
    closed_issues: number;
    created_at: string;
    updated_at: string;
    closed_at: string | null;
    due_on: string | null;
};
export namespace milestone {
    /**
     * The state of the milestone.
     */
    export enum state {
        OPEN = 'open',
        CLOSED = 'closed',
    }
}


// From: minimal_repository.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { code_of_conduct } from './code_of_conduct';
import type { security_and_analysis } from './security_and_analysis';
import type { simple_user } from './simple_user';
/**
 * Minimal Repository
 */
export type minimal_repository = {
    id: number;
    node_id: string;
    name: string;
    full_name: string;
    owner: simple_user;
    private: boolean;
    html_url: string;
    description: string | null;
    fork: boolean;
    url: string;
    archive_url: string;
    assignees_url: string;
    blobs_url: string;
    branches_url: string;
    collaborators_url: string;
    comments_url: string;
    commits_url: string;
    compare_url: string;
    contents_url: string;
    contributors_url: string;
    deployments_url: string;
    downloads_url: string;
    events_url: string;
    forks_url: string;
    git_commits_url: string;
    git_refs_url: string;
    git_tags_url: string;
    git_url?: string;
    issue_comment_url: string;
    issue_events_url: string;
    issues_url: string;
    keys_url: string;
    labels_url: string;
    languages_url: string;
    merges_url: string;
    milestones_url: string;
    notifications_url: string;
    pulls_url: string;
    releases_url: string;
    ssh_url?: string;
    stargazers_url: string;
    statuses_url: string;
    subscribers_url: string;
    subscription_url: string;
    tags_url: string;
    teams_url: string;
    trees_url: string;
    clone_url?: string;
    mirror_url?: string | null;
    hooks_url: string;
    svn_url?: string;
    homepage?: string | null;
    language?: string | null;
    forks_count?: number;
    stargazers_count?: number;
    watchers_count?: number;
    /**
     * The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
     */
    size?: number;
    default_branch?: string;
    open_issues_count?: number;
    is_template?: boolean;
    topics?: Array<string>;
    has_issues?: boolean;
    has_projects?: boolean;
    has_wiki?: boolean;
    has_pages?: boolean;
    has_downloads?: boolean;
    has_discussions?: boolean;
    archived?: boolean;
    disabled?: boolean;
    visibility?: string;
    pushed_at?: string | null;
    created_at?: string | null;
    updated_at?: string | null;
    permissions?: {
        admin?: boolean;
        maintain?: boolean;
        push?: boolean;
        triage?: boolean;
        pull?: boolean;
    };
    role_name?: string;
    temp_clone_token?: string;
    delete_branch_on_merge?: boolean;
    subscribers_count?: number;
    network_count?: number;
    code_of_conduct?: code_of_conduct;
    license?: {
        key?: string;
        name?: string;
        spdx_id?: string;
        url?: string;
        node_id?: string;
    } | null;
    forks?: number;
    open_issues?: number;
    watchers?: number;
    allow_forking?: boolean;
    web_commit_signoff_required?: boolean;
    security_and_analysis?: security_and_analysis;
    /**
     * The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
     */
    custom_properties?: Record<string, any>;
};


// From: oidc_custom_sub_repo.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Actions OIDC subject customization for a repository
 */
export type oidc_custom_sub_repo = {
    /**
     * Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.
     */
    use_default: boolean;
    /**
     * Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.
     */
    include_claim_keys?: Array<string>;
};


// From: org_hook.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Org Hook
 */
export type org_hook = {
    id: number;
    url: string;
    ping_url: string;
    deliveries_url?: string;
    name: string;
    events: Array<string>;
    active: boolean;
    config: {
        url?: string;
        insecure_ssl?: string;
        content_type?: string;
        secret?: string;
    };
    updated_at: string;
    created_at: string;
    type: string;
};


// From: org_membership.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
import type { organization_simple } from './organization_simple';
/**
 * Org Membership
 */
export type org_membership = {
    url: string;
    /**
     * The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
     */
    state: org_membership.state;
    /**
     * The user's membership type in the organization.
     */
    role: org_membership.role;
    /**
     * Whether the user has direct membership in the organization.
     */
    direct_membership?: boolean;
    /**
     * The slugs of the enterprise teams providing the user with indirect membership in the organization.
     * A limit of 100 enterprise team slugs is returned.
     */
    enterprise_teams_providing_indirect_membership?: Array<string>;
    organization_url: string;
    organization: organization_simple;
    user: nullable_simple_user;
    permissions?: {
        can_create_repository: boolean;
    };
};
export namespace org_membership {
    /**
     * The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
     */
    export enum state {
        ACTIVE = 'active',
        PENDING = 'pending',
    }
    /**
     * The user's membership type in the organization.
     */
    export enum role {
        ADMIN = 'admin',
        MEMBER = 'member',
        BILLING_MANAGER = 'billing_manager',
    }
}


// From: org_repo_custom_property_values.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { custom_property_value } from './custom_property_value';
/**
 * List of custom property values for a repository
 */
export type org_repo_custom_property_values = {
    repository_id: number;
    repository_name: string;
    repository_full_name: string;
    /**
     * List of custom property names and associated values
     */
    properties: Array<custom_property_value>;
};


// From: org_rules.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { repository_rule_branch_name_pattern } from './repository_rule_branch_name_pattern';
import type { repository_rule_code_scanning } from './repository_rule_code_scanning';
import type { repository_rule_commit_author_email_pattern } from './repository_rule_commit_author_email_pattern';
import type { repository_rule_commit_message_pattern } from './repository_rule_commit_message_pattern';
import type { repository_rule_committer_email_pattern } from './repository_rule_committer_email_pattern';
import type { repository_rule_copilot_code_review } from './repository_rule_copilot_code_review';
import type { repository_rule_creation } from './repository_rule_creation';
import type { repository_rule_deletion } from './repository_rule_deletion';
import type { repository_rule_file_extension_restriction } from './repository_rule_file_extension_restriction';
import type { repository_rule_file_path_restriction } from './repository_rule_file_path_restriction';
import type { repository_rule_max_file_path_length } from './repository_rule_max_file_path_length';
import type { repository_rule_max_file_size } from './repository_rule_max_file_size';
import type { repository_rule_non_fast_forward } from './repository_rule_non_fast_forward';
import type { repository_rule_pull_request } from './repository_rule_pull_request';
import type { repository_rule_required_deployments } from './repository_rule_required_deployments';
import type { repository_rule_required_linear_history } from './repository_rule_required_linear_history';
import type { repository_rule_required_signatures } from './repository_rule_required_signatures';
import type { repository_rule_required_status_checks } from './repository_rule_required_status_checks';
import type { repository_rule_tag_name_pattern } from './repository_rule_tag_name_pattern';
import type { repository_rule_update } from './repository_rule_update';
import type { repository_rule_workflows } from './repository_rule_workflows';
/**
 * A repository rule.
 */
export type org_rules = (repository_rule_creation | repository_rule_update | repository_rule_deletion | repository_rule_required_linear_history | repository_rule_required_deployments | repository_rule_required_signatures | repository_rule_pull_request | repository_rule_required_status_checks | repository_rule_non_fast_forward | repository_rule_commit_message_pattern | repository_rule_commit_author_email_pattern | repository_rule_committer_email_pattern | repository_rule_branch_name_pattern | repository_rule_tag_name_pattern | repository_rule_file_path_restriction | repository_rule_max_file_path_length | repository_rule_file_extension_restriction | repository_rule_max_file_size | repository_rule_workflows | repository_rule_code_scanning | repository_rule_copilot_code_review);


// From: org_ruleset_conditions.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { repository_ruleset_conditions } from './repository_ruleset_conditions';
import type { repository_ruleset_conditions_repository_id_target } from './repository_ruleset_conditions_repository_id_target';
import type { repository_ruleset_conditions_repository_name_target } from './repository_ruleset_conditions_repository_name_target';
import type { repository_ruleset_conditions_repository_property_target } from './repository_ruleset_conditions_repository_property_target';
/**
 * Conditions for an organization ruleset.
 * The branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.
 * The push rulesets conditions object does not require the `ref_name` property.
 * For repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.
 */
export type org_ruleset_conditions = ((repository_ruleset_conditions & repository_ruleset_conditions_repository_name_target) | (repository_ruleset_conditions & repository_ruleset_conditions_repository_id_target) | (repository_ruleset_conditions & repository_ruleset_conditions_repository_property_target));


// From: organization_actions_secret.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Secrets for GitHub Actions for an organization.
 */
export type organization_actions_secret = {
    /**
     * The name of the secret.
     */
    name: string;
    created_at: string;
    updated_at: string;
    /**
     * Visibility of a secret
     */
    visibility: organization_actions_secret.visibility;
    selected_repositories_url?: string;
};
export namespace organization_actions_secret {
    /**
     * Visibility of a secret
     */
    export enum visibility {
        ALL = 'all',
        PRIVATE = 'private',
        SELECTED = 'selected',
    }
}


// From: organization_actions_variable.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Organization variable for GitHub Actions.
 */
export type organization_actions_variable = {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The value of the variable.
     */
    value: string;
    /**
     * The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
     */
    created_at: string;
    /**
     * The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
     */
    updated_at: string;
    /**
     * Visibility of a variable
     */
    visibility: organization_actions_variable.visibility;
    selected_repositories_url?: string;
};
export namespace organization_actions_variable {
    /**
     * Visibility of a variable
     */
    export enum visibility {
        ALL = 'all',
        PRIVATE = 'private',
        SELECTED = 'selected',
    }
}


// From: organization_create_issue_type.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type organization_create_issue_type = {
    /**
     * Name of the issue type.
     */
    name: string;
    /**
     * Whether or not the issue type is enabled at the organization level.
     */
    is_enabled: boolean;
    /**
     * Description of the issue type.
     */
    description?: string | null;
    /**
     * Color for the issue type.
     */
    color?: organization_create_issue_type.color | null;
};
export namespace organization_create_issue_type {
    /**
     * Color for the issue type.
     */
    export enum color {
        GRAY = 'gray',
        BLUE = 'blue',
        GREEN = 'green',
        YELLOW = 'yellow',
        ORANGE = 'orange',
        RED = 'red',
        PINK = 'pink',
        PURPLE = 'purple',
    }
}


// From: organization_full.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Organization Full
 */
export type organization_full = {
    login: string;
    id: number;
    node_id: string;
    url: string;
    repos_url: string;
    events_url: string;
    hooks_url: string;
    issues_url: string;
    members_url: string;
    public_members_url: string;
    avatar_url: string;
    description: string | null;
    name?: string;
    company?: string;
    blog?: string;
    location?: string;
    email?: string;
    twitter_username?: string | null;
    is_verified?: boolean;
    has_organization_projects: boolean;
    has_repository_projects: boolean;
    public_repos: number;
    public_gists: number;
    followers: number;
    following: number;
    html_url: string;
    type: string;
    total_private_repos?: number;
    owned_private_repos?: number;
    private_gists?: number | null;
    disk_usage?: number | null;
    /**
     * The number of collaborators on private repositories.
     *
     * This field may be null if the number of private repositories is over 50,000.
     */
    collaborators?: number | null;
    billing_email?: string | null;
    plan?: {
        name: string;
        space: number;
        private_repos: number;
        filled_seats?: number;
        seats?: number;
    };
    default_repository_permission?: string | null;
    /**
     * The default branch for repositories created in this organization.
     */
    default_repository_branch?: string | null;
    members_can_create_repositories?: boolean | null;
    two_factor_requirement_enabled?: boolean | null;
    members_allowed_repository_creation_type?: string;
    members_can_create_public_repositories?: boolean;
    members_can_create_private_repositories?: boolean;
    members_can_create_internal_repositories?: boolean;
    members_can_create_pages?: boolean;
    members_can_create_public_pages?: boolean;
    members_can_create_private_pages?: boolean;
    members_can_delete_repositories?: boolean;
    members_can_change_repo_visibility?: boolean;
    members_can_invite_outside_collaborators?: boolean;
    members_can_delete_issues?: boolean;
    display_commenter_full_name_setting_enabled?: boolean;
    readers_can_create_discussions?: boolean;
    members_can_create_teams?: boolean;
    members_can_view_dependency_insights?: boolean;
    members_can_fork_private_repositories?: boolean | null;
    web_commit_signoff_required?: boolean;
    /**
     * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
     *
     * Whether GitHub Advanced Security is enabled for new repositories and repositories transferred to this organization.
     *
     * This field is only visible to organization owners or members of a team with the security manager role.
     * @deprecated
     */
    advanced_security_enabled_for_new_repositories?: boolean;
    /**
     * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
     *
     * Whether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.
     *
     * This field is only visible to organization owners or members of a team with the security manager role.
     * @deprecated
     */
    dependabot_alerts_enabled_for_new_repositories?: boolean;
    /**
     * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
     *
     * Whether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.
     *
     * This field is only visible to organization owners or members of a team with the security manager role.
     * @deprecated
     */
    dependabot_security_updates_enabled_for_new_repositories?: boolean;
    /**
     * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
     *
     * Whether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.
     *
     * This field is only visible to organization owners or members of a team with the security manager role.
     * @deprecated
     */
    dependency_graph_enabled_for_new_repositories?: boolean;
    /**
     * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
     *
     * Whether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.
     *
     * This field is only visible to organization owners or members of a team with the security manager role.
     * @deprecated
     */
    secret_scanning_enabled_for_new_repositories?: boolean;
    /**
     * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
     *
     * Whether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.
     *
     * This field is only visible to organization owners or members of a team with the security manager role.
     * @deprecated
     */
    secret_scanning_push_protection_enabled_for_new_repositories?: boolean;
    /**
     * Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.
     */
    secret_scanning_push_protection_custom_link_enabled?: boolean;
    /**
     * An optional URL string to display to contributors who are blocked from pushing a secret.
     */
    secret_scanning_push_protection_custom_link?: string | null;
    created_at: string;
    updated_at: string;
    archived_at: string | null;
    /**
     * Controls whether or not deploy keys may be added and used for repositories in the organization.
     */
    deploy_keys_enabled_for_repositories?: boolean;
};


// From: organization_invitation.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { simple_user } from './simple_user';
/**
 * Organization Invitation
 */
export type organization_invitation = {
    id: number;
    login: string | null;
    email: string | null;
    role: string;
    created_at: string;
    failed_at?: string | null;
    failed_reason?: string | null;
    inviter: simple_user;
    team_count: number;
    node_id: string;
    invitation_teams_url: string;
    invitation_source?: string;
};


// From: organization_programmatic_access_grant.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { simple_user } from './simple_user';
/**
 * Minimal representation of an organization programmatic access grant for enumerations
 */
export type organization_programmatic_access_grant = {
    /**
     * Unique identifier of the fine-grained personal access token grant. The `pat_id` used to get details about an approved fine-grained personal access token.
     */
    id: number;
    owner: simple_user;
    /**
     * Type of repository selection requested.
     */
    repository_selection: organization_programmatic_access_grant.repository_selection;
    /**
     * URL to the list of repositories the fine-grained personal access token can access. Only follow when `repository_selection` is `subset`.
     */
    repositories_url: string;
    /**
     * Permissions requested, categorized by type of permission.
     */
    permissions: {
        organization?: Record<string, string>;
        repository?: Record<string, string>;
        other?: Record<string, string>;
    };
    /**
     * Date and time when the fine-grained personal access token was approved to access the organization.
     */
    access_granted_at: string;
    /**
     * Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants.
     */
    token_id: number;
    /**
     * The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens.
     */
    token_name: string;
    /**
     * Whether the associated fine-grained personal access token has expired.
     */
    token_expired: boolean;
    /**
     * Date and time when the associated fine-grained personal access token expires.
     */
    token_expires_at: string | null;
    /**
     * Date and time when the associated fine-grained personal access token was last used for authentication.
     */
    token_last_used_at: string | null;
};
export namespace organization_programmatic_access_grant {
    /**
     * Type of repository selection requested.
     */
    export enum repository_selection {
        NONE = 'none',
        ALL = 'all',
        SUBSET = 'subset',
    }
}


// From: organization_programmatic_access_grant_request.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { simple_user } from './simple_user';
/**
 * Minimal representation of an organization programmatic access grant request for enumerations
 */
export type organization_programmatic_access_grant_request = {
    /**
     * Unique identifier of the request for access via fine-grained personal access token. The `pat_request_id` used to review PAT requests.
     */
    id: number;
    /**
     * Reason for requesting access.
     */
    reason: string | null;
    owner: simple_user;
    /**
     * Type of repository selection requested.
     */
    repository_selection: organization_programmatic_access_grant_request.repository_selection;
    /**
     * URL to the list of repositories requested to be accessed via fine-grained personal access token. Should only be followed when `repository_selection` is `subset`.
     */
    repositories_url: string;
    /**
     * Permissions requested, categorized by type of permission.
     */
    permissions: {
        organization?: Record<string, string>;
        repository?: Record<string, string>;
        other?: Record<string, string>;
    };
    /**
     * Date and time when the request for access was created.
     */
    created_at: string;
    /**
     * Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants.
     */
    token_id: number;
    /**
     * The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens.
     */
    token_name: string;
    /**
     * Whether the associated fine-grained personal access token has expired.
     */
    token_expired: boolean;
    /**
     * Date and time when the associated fine-grained personal access token expires.
     */
    token_expires_at: string | null;
    /**
     * Date and time when the associated fine-grained personal access token was last used for authentication.
     */
    token_last_used_at: string | null;
};
export namespace organization_programmatic_access_grant_request {
    /**
     * Type of repository selection requested.
     */
    export enum repository_selection {
        NONE = 'none',
        ALL = 'all',
        SUBSET = 'subset',
    }
}


// From: organization_role.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * Organization roles
 */
export type organization_role = {
    /**
     * The unique identifier of the role.
     */
    id: number;
    /**
     * The name of the role.
     */
    name: string;
    /**
     * A short description about who this role is for or what permissions it grants.
     */
    description?: string | null;
    /**
     * The system role from which this role inherits permissions.
     */
    base_role?: organization_role.base_role | null;
    /**
     * Source answers the question, "where did this role come from?"
     */
    source?: organization_role.source | null;
    /**
     * A list of permissions included in this role.
     */
    permissions: Array<string>;
    organization: nullable_simple_user;
    /**
     * The date and time the role was created.
     */
    created_at: string;
    /**
     * The date and time the role was last updated.
     */
    updated_at: string;
};
export namespace organization_role {
    /**
     * The system role from which this role inherits permissions.
     */
    export enum base_role {
        READ = 'read',
        TRIAGE = 'triage',
        WRITE = 'write',
        MAINTAIN = 'maintain',
        ADMIN = 'admin',
    }
    /**
     * Source answers the question, "where did this role come from?"
     */
    export enum source {
        ORGANIZATION = 'Organization',
        ENTERPRISE = 'Enterprise',
        PREDEFINED = 'Predefined',
    }
}


// From: organization_simple.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A GitHub organization.
 */
export type organization_simple = {
    login: string;
    id: number;
    node_id: string;
    url: string;
    repos_url: string;
    events_url: string;
    hooks_url: string;
    issues_url: string;
    members_url: string;
    public_members_url: string;
    avatar_url: string;
    description: string | null;
};


// From: organization_update_issue_type.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type organization_update_issue_type = {
    /**
     * Name of the issue type.
     */
    name: string;
    /**
     * Whether or not the issue type is enabled at the organization level.
     */
    is_enabled: boolean;
    /**
     * Description of the issue type.
     */
    description?: string | null;
    /**
     * Color for the issue type.
     */
    color?: organization_update_issue_type.color | null;
};
export namespace organization_update_issue_type {
    /**
     * Color for the issue type.
     */
    export enum color {
        GRAY = 'gray',
        BLUE = 'blue',
        GREEN = 'green',
        YELLOW = 'yellow',
        ORANGE = 'orange',
        RED = 'red',
        PINK = 'pink',
        PURPLE = 'purple',
    }
}


// From: page.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
 */
export type page = number;

// From: page_build.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * Page Build
 */
export type page_build = {
    url: string;
    status: string;
    error: {
        message: string | null;
    };
    pusher: nullable_simple_user;
    commit: string;
    duration: number;
    created_at: string;
    updated_at: string;
};


// From: page_build_status.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Page Build Status
 */
export type page_build_status = {
    url: string;
    status: string;
};


// From: page_deployment.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The GitHub Pages deployment status.
 */
export type page_deployment = {
    /**
     * The ID of the GitHub Pages deployment. This is the Git SHA of the deployed commit.
     */
    id: (number | string);
    /**
     * The URI to monitor GitHub Pages deployment status.
     */
    status_url: string;
    /**
     * The URI to the deployed GitHub Pages.
     */
    page_url: string;
    /**
     * The URI to the deployed GitHub Pages preview.
     */
    preview_url?: string;
};


// From: pages_deployment_status.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type pages_deployment_status = {
    /**
     * The current status of the deployment.
     */
    status?: pages_deployment_status.status;
};
export namespace pages_deployment_status {
    /**
     * The current status of the deployment.
     */
    export enum status {
        DEPLOYMENT_IN_PROGRESS = 'deployment_in_progress',
        SYNCING_FILES = 'syncing_files',
        FINISHED_FILE_SYNC = 'finished_file_sync',
        UPDATING_PAGES = 'updating_pages',
        PURGING_CDN = 'purging_cdn',
        DEPLOYMENT_CANCELLED = 'deployment_cancelled',
        DEPLOYMENT_FAILED = 'deployment_failed',
        DEPLOYMENT_CONTENT_FAILED = 'deployment_content_failed',
        DEPLOYMENT_ATTEMPT_ERROR = 'deployment_attempt_error',
        DEPLOYMENT_LOST = 'deployment_lost',
        SUCCEED = 'succeed',
    }
}


// From: pages_health_check.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Pages Health Check Status
 */
export type pages_health_check = {
    domain?: {
        host?: string;
        uri?: string;
        nameservers?: string;
        dns_resolves?: boolean;
        is_proxied?: boolean | null;
        is_cloudflare_ip?: boolean | null;
        is_fastly_ip?: boolean | null;
        is_old_ip_address?: boolean | null;
        is_a_record?: boolean | null;
        has_cname_record?: boolean | null;
        has_mx_records_present?: boolean | null;
        is_valid_domain?: boolean;
        is_apex_domain?: boolean;
        should_be_a_record?: boolean | null;
        is_cname_to_github_user_domain?: boolean | null;
        is_cname_to_pages_dot_github_dot_com?: boolean | null;
        is_cname_to_fastly?: boolean | null;
        is_pointed_to_github_pages_ip?: boolean | null;
        is_non_github_pages_ip_present?: boolean | null;
        is_pages_domain?: boolean;
        is_served_by_pages?: boolean | null;
        is_valid?: boolean;
        reason?: string | null;
        responds_to_https?: boolean;
        enforces_https?: boolean;
        https_error?: string | null;
        is_https_eligible?: boolean | null;
        caa_error?: string | null;
    };
    alt_domain?: {
        host?: string;
        uri?: string;
        nameservers?: string;
        dns_resolves?: boolean;
        is_proxied?: boolean | null;
        is_cloudflare_ip?: boolean | null;
        is_fastly_ip?: boolean | null;
        is_old_ip_address?: boolean | null;
        is_a_record?: boolean | null;
        has_cname_record?: boolean | null;
        has_mx_records_present?: boolean | null;
        is_valid_domain?: boolean;
        is_apex_domain?: boolean;
        should_be_a_record?: boolean | null;
        is_cname_to_github_user_domain?: boolean | null;
        is_cname_to_pages_dot_github_dot_com?: boolean | null;
        is_cname_to_fastly?: boolean | null;
        is_pointed_to_github_pages_ip?: boolean | null;
        is_non_github_pages_ip_present?: boolean | null;
        is_pages_domain?: boolean;
        is_served_by_pages?: boolean | null;
        is_valid?: boolean;
        reason?: string | null;
        responds_to_https?: boolean;
        enforces_https?: boolean;
        https_error?: string | null;
        is_https_eligible?: boolean | null;
        caa_error?: string | null;
    } | null;
};


// From: participation_stats.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type participation_stats = {
    all: Array<number>;
    owner: Array<number>;
};


// From: pending_deployment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { deployment_reviewer_type } from './deployment_reviewer_type';
import type { simple_user } from './simple_user';
import type { team } from './team';
/**
 * Details of a deployment that is waiting for protection rules to pass
 */
export type pending_deployment = {
    environment: {
        /**
         * The id of the environment.
         */
        id?: number;
        node_id?: string;
        /**
         * The name of the environment.
         */
        name?: string;
        url?: string;
        html_url?: string;
    };
    /**
     * The set duration of the wait timer
     */
    wait_timer: number;
    /**
     * The time that the wait timer began.
     */
    wait_timer_started_at: string | null;
    /**
     * Whether the currently authenticated user can approve the deployment
     */
    current_user_can_approve: boolean;
    /**
     * The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
     */
    reviewers: Array<{
        type?: deployment_reviewer_type;
        reviewer?: (simple_user | team);
    }>;
};


// From: prevent_self_review.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Whether or not a user who created the job is prevented from approving their own job.
 */
export type prevent_self_review = boolean;

// From: private_user.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Private User
 */
export type private_user = {
    login: string;
    id: number;
    user_view_type?: string;
    node_id: string;
    avatar_url: string;
    gravatar_id: string | null;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    name: string | null;
    company: string | null;
    blog: string | null;
    location: string | null;
    email: string | null;
    notification_email?: string | null;
    hireable: boolean | null;
    bio: string | null;
    twitter_username?: string | null;
    public_repos: number;
    public_gists: number;
    followers: number;
    following: number;
    created_at: string;
    updated_at: string;
    private_gists: number;
    total_private_repos: number;
    owned_private_repos: number;
    disk_usage: number;
    collaborators: number;
    two_factor_authentication: boolean;
    plan?: {
        collaborators: number;
        name: string;
        space: number;
        private_repos: number;
    };
    business_plus?: boolean;
    ldap_dn?: string;
};


// From: protected_branch.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { branch_restriction_policy } from './branch_restriction_policy';
import type { integration } from './integration';
import type { simple_user } from './simple_user';
import type { status_check_policy } from './status_check_policy';
import type { team } from './team';
/**
 * Branch protections protect branches
 */
export type protected_branch = {
    url: string;
    required_status_checks?: status_check_policy;
    required_pull_request_reviews?: {
        url: string;
        dismiss_stale_reviews?: boolean;
        require_code_owner_reviews?: boolean;
        required_approving_review_count?: number;
        /**
         * Whether the most recent push must be approved by someone other than the person who pushed it.
         */
        require_last_push_approval?: boolean;
        dismissal_restrictions?: {
            url: string;
            users_url: string;
            teams_url: string;
            users: Array<simple_user>;
            teams: Array<team>;
            apps?: Array<integration>;
        };
        bypass_pull_request_allowances?: {
            users: Array<simple_user>;
            teams: Array<team>;
            apps?: Array<integration>;
        };
    };
    required_signatures?: {
        url: string;
        enabled: boolean;
    };
    enforce_admins?: {
        url: string;
        enabled: boolean;
    };
    required_linear_history?: {
        enabled: boolean;
    };
    allow_force_pushes?: {
        enabled: boolean;
    };
    allow_deletions?: {
        enabled: boolean;
    };
    restrictions?: branch_restriction_policy;
    required_conversation_resolution?: {
        enabled?: boolean;
    };
    block_creations?: {
        enabled: boolean;
    };
    /**
     * Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
     */
    lock_branch?: {
        enabled?: boolean;
    };
    /**
     * Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
     */
    allow_fork_syncing?: {
        enabled?: boolean;
    };
};


// From: protected_branch_admin_enforced.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Protected Branch Admin Enforced
 */
export type protected_branch_admin_enforced = {
    url: string;
    enabled: boolean;
};


// From: protected_branch_pull_request_review.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { integration } from './integration';
import type { simple_user } from './simple_user';
import type { team } from './team';
/**
 * Protected Branch Pull Request Review
 */
export type protected_branch_pull_request_review = {
    url?: string;
    dismissal_restrictions?: {
        /**
         * The list of users with review dismissal access.
         */
        users?: Array<simple_user>;
        /**
         * The list of teams with review dismissal access.
         */
        teams?: Array<team>;
        /**
         * The list of apps with review dismissal access.
         */
        apps?: Array<integration>;
        url?: string;
        users_url?: string;
        teams_url?: string;
    };
    /**
     * Allow specific users, teams, or apps to bypass pull request requirements.
     */
    bypass_pull_request_allowances?: {
        /**
         * The list of users allowed to bypass pull request requirements.
         */
        users?: Array<simple_user>;
        /**
         * The list of teams allowed to bypass pull request requirements.
         */
        teams?: Array<team>;
        /**
         * The list of apps allowed to bypass pull request requirements.
         */
        apps?: Array<integration>;
    };
    dismiss_stale_reviews: boolean;
    require_code_owner_reviews: boolean;
    required_approving_review_count?: number;
    /**
     * Whether the most recent push must be approved by someone other than the person who pushed it.
     */
    require_last_push_approval?: boolean;
};


// From: public_user.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Public User
 */
export type public_user = {
    login: string;
    id: number;
    user_view_type?: string;
    node_id: string;
    avatar_url: string;
    gravatar_id: string | null;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    name: string | null;
    company: string | null;
    blog: string | null;
    location: string | null;
    email: string | null;
    notification_email?: string | null;
    hireable: boolean | null;
    bio: string | null;
    twitter_username?: string | null;
    public_repos: number;
    public_gists: number;
    followers: number;
    following: number;
    created_at: string;
    updated_at: string;
    plan?: {
        collaborators: number;
        name: string;
        space: number;
        private_repos: number;
    };
    private_gists?: number;
    total_private_repos?: number;
    owned_private_repos?: number;
    disk_usage?: number;
    collaborators?: number;
};


// From: pull_request.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { auto_merge } from './auto_merge';
import type { link } from './link';
import type { nullable_milestone } from './nullable_milestone';
import type { nullable_simple_user } from './nullable_simple_user';
import type { repository } from './repository';
import type { simple_user } from './simple_user';
import type { team_simple } from './team_simple';
/**
 * Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
 */
export type pull_request = {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    /**
     * Number uniquely identifying the pull request within its repository.
     */
    number: number;
    /**
     * State of this Pull Request. Either `open` or `closed`.
     */
    state: pull_request.state;
    locked: boolean;
    /**
     * The title of the pull request.
     */
    title: string;
    user: simple_user;
    body: string | null;
    labels: Array<{
        id: number;
        node_id: string;
        url: string;
        name: string;
        description: string | null;
        color: string;
        default: boolean;
    }>;
    milestone: nullable_milestone;
    active_lock_reason?: string | null;
    created_at: string;
    updated_at: string;
    closed_at: string | null;
    merged_at: string | null;
    merge_commit_sha: string | null;
    assignee: nullable_simple_user;
    assignees?: Array<simple_user> | null;
    requested_reviewers?: Array<simple_user> | null;
    requested_teams?: Array<team_simple> | null;
    head: {
        label: string;
        ref: string;
        repo: repository;
        sha: string;
        user: simple_user;
    };
    base: {
        label: string;
        ref: string;
        repo: repository;
        sha: string;
        user: simple_user;
    };
    _links: {
        comments: link;
        commits: link;
        statuses: link;
        html: link;
        issue: link;
        review_comments: link;
        review_comment: link;
        self: link;
    };
    author_association: author_association;
    auto_merge: auto_merge;
    /**
     * Indicates whether or not the pull request is a draft.
     */
    draft?: boolean;
    merged: boolean;
    mergeable: boolean | null;
    rebaseable?: boolean | null;
    mergeable_state: string;
    merged_by: nullable_simple_user;
    comments: number;
    review_comments: number;
    /**
     * Indicates whether maintainers can modify the pull request.
     */
    maintainer_can_modify: boolean;
    commits: number;
    additions: number;
    deletions: number;
    changed_files: number;
};
export namespace pull_request {
    /**
     * State of this Pull Request. Either `open` or `closed`.
     */
    export enum state {
        OPEN = 'open',
        CLOSED = 'closed',
    }
}


// From: pull_request_merge_result.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Pull Request Merge Result
 */
export type pull_request_merge_result = {
    sha: string;
    merged: boolean;
    message: string;
};


// From: pull_request_review.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * Pull Request Reviews are reviews on pull requests.
 */
export type pull_request_review = {
    /**
     * Unique identifier of the review
     */
    id: number;
    node_id: string;
    user: nullable_simple_user;
    /**
     * The text of the review.
     */
    body: string;
    state: string;
    html_url: string;
    pull_request_url: string;
    _links: {
        html: {
            href: string;
        };
        pull_request: {
            href: string;
        };
    };
    submitted_at?: string;
    /**
     * A commit SHA for the review. If the commit object was garbage collected or forcibly deleted, then it no longer exists in Git and this value will be `null`.
     */
    commit_id: string | null;
    body_html?: string;
    body_text?: string;
    author_association: author_association;
};


// From: pull_request_review_comment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { reaction_rollup } from './reaction_rollup';
import type { simple_user } from './simple_user';
/**
 * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
 */
export type pull_request_review_comment = {
    /**
     * URL for the pull request review comment
     */
    url: string;
    /**
     * The ID of the pull request review to which the comment belongs.
     */
    pull_request_review_id: number | null;
    /**
     * The ID of the pull request review comment.
     */
    id: number;
    /**
     * The node ID of the pull request review comment.
     */
    node_id: string;
    /**
     * The diff of the line that the comment refers to.
     */
    diff_hunk: string;
    /**
     * The relative path of the file to which the comment applies.
     */
    path: string;
    /**
     * The line index in the diff to which the comment applies. This field is closing down; use `line` instead.
     */
    position?: number;
    /**
     * The index of the original line in the diff to which the comment applies. This field is closing down; use `original_line` instead.
     */
    original_position?: number;
    /**
     * The SHA of the commit to which the comment applies.
     */
    commit_id: string;
    /**
     * The SHA of the original commit to which the comment applies.
     */
    original_commit_id: string;
    /**
     * The comment ID to reply to.
     */
    in_reply_to_id?: number;
    user: simple_user;
    /**
     * The text of the comment.
     */
    body: string;
    created_at: string;
    updated_at: string;
    /**
     * HTML URL for the pull request review comment.
     */
    html_url: string;
    /**
     * URL for the pull request that the review comment belongs to.
     */
    pull_request_url: string;
    author_association: author_association;
    _links: {
        self: {
            href: string;
        };
        html: {
            href: string;
        };
        pull_request: {
            href: string;
        };
    };
    /**
     * The first line of the range for a multi-line comment.
     */
    start_line?: number | null;
    /**
     * The first line of the range for a multi-line comment.
     */
    original_start_line?: number | null;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    start_side?: pull_request_review_comment.start_side | null;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    line?: number;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    original_line?: number;
    /**
     * The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment
     */
    side?: pull_request_review_comment.side;
    /**
     * The level at which the comment is targeted, can be a diff line or a file.
     */
    subject_type?: pull_request_review_comment.subject_type;
    reactions?: reaction_rollup;
    body_html?: string;
    body_text?: string;
};
export namespace pull_request_review_comment {
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    export enum start_side {
        LEFT = 'LEFT',
        RIGHT = 'RIGHT',
    }
    /**
     * The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment
     */
    export enum side {
        LEFT = 'LEFT',
        RIGHT = 'RIGHT',
    }
    /**
     * The level at which the comment is targeted, can be a diff line or a file.
     */
    export enum subject_type {
        LINE = 'line',
        FILE = 'file',
    }
}


// From: pull_request_review_request.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { simple_user } from './simple_user';
import type { team } from './team';
/**
 * Pull Request Review Request
 */
export type pull_request_review_request = {
    users: Array<simple_user>;
    teams: Array<team>;
};


// From: pull_request_simple.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { auto_merge } from './auto_merge';
import type { link } from './link';
import type { nullable_milestone } from './nullable_milestone';
import type { nullable_simple_user } from './nullable_simple_user';
import type { repository } from './repository';
import type { simple_user } from './simple_user';
import type { team } from './team';
/**
 * Pull Request Simple
 */
export type pull_request_simple = {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    number: number;
    state: string;
    locked: boolean;
    title: string;
    user: nullable_simple_user;
    body: string | null;
    labels: Array<{
        id: number;
        node_id: string;
        url: string;
        name: string;
        description: string;
        color: string;
        default: boolean;
    }>;
    milestone: nullable_milestone;
    active_lock_reason?: string | null;
    created_at: string;
    updated_at: string;
    closed_at: string | null;
    merged_at: string | null;
    merge_commit_sha: string | null;
    assignee: nullable_simple_user;
    assignees?: Array<simple_user> | null;
    requested_reviewers?: Array<simple_user> | null;
    requested_teams?: Array<team> | null;
    head: {
        label: string;
        ref: string;
        repo: repository;
        sha: string;
        user: nullable_simple_user;
    };
    base: {
        label: string;
        ref: string;
        repo: repository;
        sha: string;
        user: nullable_simple_user;
    };
    _links: {
        comments: link;
        commits: link;
        statuses: link;
        html: link;
        issue: link;
        review_comments: link;
        review_comment: link;
        self: link;
    };
    author_association: author_association;
    auto_merge: auto_merge;
    /**
     * Indicates whether or not the pull request is a draft.
     */
    draft?: boolean;
};


// From: referrer_traffic.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Referrer Traffic
 */
export type referrer_traffic = {
    referrer: string;
    count: number;
    uniques: number;
};


// From: release.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { reaction_rollup } from './reaction_rollup';
import type { release_asset } from './release_asset';
import type { simple_user } from './simple_user';
/**
 * A release.
 */
export type release = {
    url: string;
    html_url: string;
    assets_url: string;
    upload_url: string;
    tarball_url: string | null;
    zipball_url: string | null;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: string | null;
    body?: string | null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    /**
     * Whether to identify the release as a prerelease or a full release.
     */
    prerelease: boolean;
    /**
     * Whether or not the release is immutable.
     */
    immutable?: boolean;
    created_at: string;
    published_at: string | null;
    updated_at?: string | null;
    author: simple_user;
    assets: Array<release_asset>;
    body_html?: string;
    body_text?: string;
    mentions_count?: number;
    /**
     * The URL of the release discussion.
     */
    discussion_url?: string;
    reactions?: reaction_rollup;
};


// From: release_asset.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * Data related to a release.
 */
export type release_asset = {
    url: string;
    browser_download_url: string;
    id: number;
    node_id: string;
    /**
     * The file name of the asset.
     */
    name: string;
    label: string | null;
    /**
     * State of the release asset.
     */
    state: release_asset.state;
    content_type: string;
    size: number;
    digest: string | null;
    download_count: number;
    created_at: string;
    updated_at: string;
    uploader: nullable_simple_user;
};
export namespace release_asset {
    /**
     * State of the release asset.
     */
    export enum state {
        UPLOADED = 'uploaded',
        OPEN = 'open',
    }
}


// From: release_notes_content.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Generated name and body describing a release
 */
export type release_notes_content = {
    /**
     * The generated name of the release
     */
    name: string;
    /**
     * The generated body describing the contents of the release supporting markdown formatting
     */
    body: string;
};


// From: repository.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_license_simple } from './nullable_license_simple';
import type { simple_user } from './simple_user';
/**
 * A repository on GitHub.
 */
export type repository = {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    license: nullable_license_simple;
    forks: number;
    permissions?: {
        admin: boolean;
        pull: boolean;
        triage?: boolean;
        push: boolean;
        maintain?: boolean;
    };
    owner: simple_user;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
    html_url: string;
    description: string | null;
    fork: boolean;
    url: string;
    archive_url: string;
    assignees_url: string;
    blobs_url: string;
    branches_url: string;
    collaborators_url: string;
    comments_url: string;
    commits_url: string;
    compare_url: string;
    contents_url: string;
    contributors_url: string;
    deployments_url: string;
    downloads_url: string;
    events_url: string;
    forks_url: string;
    git_commits_url: string;
    git_refs_url: string;
    git_tags_url: string;
    git_url: string;
    issue_comment_url: string;
    issue_events_url: string;
    issues_url: string;
    keys_url: string;
    labels_url: string;
    languages_url: string;
    merges_url: string;
    milestones_url: string;
    notifications_url: string;
    pulls_url: string;
    releases_url: string;
    ssh_url: string;
    stargazers_url: string;
    statuses_url: string;
    subscribers_url: string;
    subscription_url: string;
    tags_url: string;
    teams_url: string;
    trees_url: string;
    clone_url: string;
    mirror_url: string | null;
    hooks_url: string;
    svn_url: string;
    homepage: string | null;
    language: string | null;
    forks_count: number;
    stargazers_count: number;
    watchers_count: number;
    /**
     * The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
     */
    size: number;
    /**
     * The default branch of the repository.
     */
    default_branch: string;
    open_issues_count: number;
    /**
     * Whether this repository acts as a template that can be used to generate new repositories.
     */
    is_template?: boolean;
    topics?: Array<string>;
    /**
     * Whether issues are enabled.
     */
    has_issues: boolean;
    /**
     * Whether projects are enabled.
     */
    has_projects: boolean;
    /**
     * Whether the wiki is enabled.
     */
    has_wiki: boolean;
    has_pages: boolean;
    /**
     * Whether downloads are enabled.
     * @deprecated
     */
    has_downloads: boolean;
    /**
     * Whether discussions are enabled.
     */
    has_discussions?: boolean;
    /**
     * Whether the repository is archived.
     */
    archived: boolean;
    /**
     * Returns whether or not this repository disabled.
     */
    disabled: boolean;
    /**
     * The repository visibility: public, private, or internal.
     */
    visibility?: string;
    pushed_at: string | null;
    created_at: string | null;
    updated_at: string | null;
    /**
     * Whether to allow rebase merges for pull requests.
     */
    allow_rebase_merge?: boolean;
    temp_clone_token?: string;
    /**
     * Whether to allow squash merges for pull requests.
     */
    allow_squash_merge?: boolean;
    /**
     * Whether to allow Auto-merge to be used on pull requests.
     */
    allow_auto_merge?: boolean;
    /**
     * Whether to delete head branches when pull requests are merged
     */
    delete_branch_on_merge?: boolean;
    /**
     * Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
     */
    allow_update_branch?: boolean;
    /**
     * Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
     * @deprecated
     */
    use_squash_pr_title_as_default?: boolean;
    /**
     * The default value for a squash merge commit title:
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
     */
    squash_merge_commit_title?: repository.squash_merge_commit_title;
    /**
     * The default value for a squash merge commit message:
     *
     * - `PR_BODY` - default to the pull request's body.
     * - `COMMIT_MESSAGES` - default to the branch's commit messages.
     * - `BLANK` - default to a blank commit message.
     */
    squash_merge_commit_message?: repository.squash_merge_commit_message;
    /**
     * The default value for a merge commit title.
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
     */
    merge_commit_title?: repository.merge_commit_title;
    /**
     * The default value for a merge commit message.
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `PR_BODY` - default to the pull request's body.
     * - `BLANK` - default to a blank commit message.
     */
    merge_commit_message?: repository.merge_commit_message;
    /**
     * Whether to allow merge commits for pull requests.
     */
    allow_merge_commit?: boolean;
    /**
     * Whether to allow forking this repo
     */
    allow_forking?: boolean;
    /**
     * Whether to require contributors to sign off on web-based commits
     */
    web_commit_signoff_required?: boolean;
    open_issues: number;
    watchers: number;
    master_branch?: string;
    starred_at?: string;
    /**
     * Whether anonymous git access is enabled for this repository
     */
    anonymous_access_enabled?: boolean;
    /**
     * The status of the code search index for this repository
     */
    code_search_index_status?: {
        lexical_search_ok?: boolean;
        lexical_commit_sha?: string;
    };
};
export namespace repository {
    /**
     * The default value for a squash merge commit title:
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
     */
    export enum squash_merge_commit_title {
        PR_TITLE = 'PR_TITLE',
        COMMIT_OR_PR_TITLE = 'COMMIT_OR_PR_TITLE',
    }
    /**
     * The default value for a squash merge commit message:
     *
     * - `PR_BODY` - default to the pull request's body.
     * - `COMMIT_MESSAGES` - default to the branch's commit messages.
     * - `BLANK` - default to a blank commit message.
     */
    export enum squash_merge_commit_message {
        PR_BODY = 'PR_BODY',
        COMMIT_MESSAGES = 'COMMIT_MESSAGES',
        BLANK = 'BLANK',
    }
    /**
     * The default value for a merge commit title.
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
     */
    export enum merge_commit_title {
        PR_TITLE = 'PR_TITLE',
        MERGE_MESSAGE = 'MERGE_MESSAGE',
    }
    /**
     * The default value for a merge commit message.
     *
     * - `PR_TITLE` - default to the pull request's title.
     * - `PR_BODY` - default to the pull request's body.
     * - `BLANK` - default to a blank commit message.
     */
    export enum merge_commit_message {
        PR_BODY = 'PR_BODY',
        PR_TITLE = 'PR_TITLE',
        BLANK = 'BLANK',
    }
}


// From: repository_collaborator_permission.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_collaborator } from './nullable_collaborator';
/**
 * Repository Collaborator Permission
 */
export type repository_collaborator_permission = {
    permission: string;
    role_name: string;
    user: nullable_collaborator;
};


// From: repository_invitation.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { minimal_repository } from './minimal_repository';
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * Repository invitations let you manage who you collaborate with.
 */
export type repository_invitation = {
    /**
     * Unique identifier of the repository invitation.
     */
    id: number;
    repository: minimal_repository;
    invitee: nullable_simple_user;
    inviter: nullable_simple_user;
    /**
     * The permission associated with the invitation.
     */
    permissions: repository_invitation.permissions;
    created_at: string;
    /**
     * Whether or not the invitation has expired
     */
    expired?: boolean;
    /**
     * URL for the repository invitation
     */
    url: string;
    html_url: string;
    node_id: string;
};
export namespace repository_invitation {
    /**
     * The permission associated with the invitation.
     */
    export enum permissions {
        READ = 'read',
        WRITE = 'write',
        ADMIN = 'admin',
        TRIAGE = 'triage',
        MAINTAIN = 'maintain',
    }
}


// From: repository_rule.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { repository_rule_branch_name_pattern } from './repository_rule_branch_name_pattern';
import type { repository_rule_code_scanning } from './repository_rule_code_scanning';
import type { repository_rule_commit_author_email_pattern } from './repository_rule_commit_author_email_pattern';
import type { repository_rule_commit_message_pattern } from './repository_rule_commit_message_pattern';
import type { repository_rule_committer_email_pattern } from './repository_rule_committer_email_pattern';
import type { repository_rule_copilot_code_review } from './repository_rule_copilot_code_review';
import type { repository_rule_creation } from './repository_rule_creation';
import type { repository_rule_deletion } from './repository_rule_deletion';
import type { repository_rule_file_extension_restriction } from './repository_rule_file_extension_restriction';
import type { repository_rule_file_path_restriction } from './repository_rule_file_path_restriction';
import type { repository_rule_max_file_path_length } from './repository_rule_max_file_path_length';
import type { repository_rule_max_file_size } from './repository_rule_max_file_size';
import type { repository_rule_merge_queue } from './repository_rule_merge_queue';
import type { repository_rule_non_fast_forward } from './repository_rule_non_fast_forward';
import type { repository_rule_pull_request } from './repository_rule_pull_request';
import type { repository_rule_required_deployments } from './repository_rule_required_deployments';
import type { repository_rule_required_linear_history } from './repository_rule_required_linear_history';
import type { repository_rule_required_signatures } from './repository_rule_required_signatures';
import type { repository_rule_required_status_checks } from './repository_rule_required_status_checks';
import type { repository_rule_tag_name_pattern } from './repository_rule_tag_name_pattern';
import type { repository_rule_update } from './repository_rule_update';
import type { repository_rule_workflows } from './repository_rule_workflows';
/**
 * A repository rule.
 */
export type repository_rule = (repository_rule_creation | repository_rule_update | repository_rule_deletion | repository_rule_required_linear_history | repository_rule_merge_queue | repository_rule_required_deployments | repository_rule_required_signatures | repository_rule_pull_request | repository_rule_required_status_checks | repository_rule_non_fast_forward | repository_rule_commit_message_pattern | repository_rule_commit_author_email_pattern | repository_rule_committer_email_pattern | repository_rule_branch_name_pattern | repository_rule_tag_name_pattern | repository_rule_file_path_restriction | repository_rule_max_file_path_length | repository_rule_file_extension_restriction | repository_rule_max_file_size | repository_rule_workflows | repository_rule_code_scanning | repository_rule_copilot_code_review);


// From: repository_rule_detailed.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { repository_rule_branch_name_pattern } from './repository_rule_branch_name_pattern';
import type { repository_rule_code_scanning } from './repository_rule_code_scanning';
import type { repository_rule_commit_author_email_pattern } from './repository_rule_commit_author_email_pattern';
import type { repository_rule_commit_message_pattern } from './repository_rule_commit_message_pattern';
import type { repository_rule_committer_email_pattern } from './repository_rule_committer_email_pattern';
import type { repository_rule_copilot_code_review } from './repository_rule_copilot_code_review';
import type { repository_rule_creation } from './repository_rule_creation';
import type { repository_rule_deletion } from './repository_rule_deletion';
import type { repository_rule_file_extension_restriction } from './repository_rule_file_extension_restriction';
import type { repository_rule_file_path_restriction } from './repository_rule_file_path_restriction';
import type { repository_rule_max_file_path_length } from './repository_rule_max_file_path_length';
import type { repository_rule_max_file_size } from './repository_rule_max_file_size';
import type { repository_rule_merge_queue } from './repository_rule_merge_queue';
import type { repository_rule_non_fast_forward } from './repository_rule_non_fast_forward';
import type { repository_rule_pull_request } from './repository_rule_pull_request';
import type { repository_rule_required_deployments } from './repository_rule_required_deployments';
import type { repository_rule_required_linear_history } from './repository_rule_required_linear_history';
import type { repository_rule_required_signatures } from './repository_rule_required_signatures';
import type { repository_rule_required_status_checks } from './repository_rule_required_status_checks';
import type { repository_rule_ruleset_info } from './repository_rule_ruleset_info';
import type { repository_rule_tag_name_pattern } from './repository_rule_tag_name_pattern';
import type { repository_rule_update } from './repository_rule_update';
import type { repository_rule_workflows } from './repository_rule_workflows';
/**
 * A repository rule with ruleset details.
 */
export type repository_rule_detailed = ((repository_rule_creation & repository_rule_ruleset_info) | (repository_rule_update & repository_rule_ruleset_info) | (repository_rule_deletion & repository_rule_ruleset_info) | (repository_rule_required_linear_history & repository_rule_ruleset_info) | (repository_rule_merge_queue & repository_rule_ruleset_info) | (repository_rule_required_deployments & repository_rule_ruleset_info) | (repository_rule_required_signatures & repository_rule_ruleset_info) | (repository_rule_pull_request & repository_rule_ruleset_info) | (repository_rule_required_status_checks & repository_rule_ruleset_info) | (repository_rule_non_fast_forward & repository_rule_ruleset_info) | (repository_rule_commit_message_pattern & repository_rule_ruleset_info) | (repository_rule_commit_author_email_pattern & repository_rule_ruleset_info) | (repository_rule_committer_email_pattern & repository_rule_ruleset_info) | (repository_rule_branch_name_pattern & repository_rule_ruleset_info) | (repository_rule_tag_name_pattern & repository_rule_ruleset_info) | (repository_rule_file_path_restriction & repository_rule_ruleset_info) | (repository_rule_max_file_path_length & repository_rule_ruleset_info) | (repository_rule_file_extension_restriction & repository_rule_ruleset_info) | (repository_rule_max_file_size & repository_rule_ruleset_info) | (repository_rule_workflows & repository_rule_ruleset_info) | (repository_rule_code_scanning & repository_rule_ruleset_info) | (repository_rule_copilot_code_review & repository_rule_ruleset_info));


// From: repository_rule_enforcement.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
 */
export enum repository_rule_enforcement {
    DISABLED = 'disabled',
    ACTIVE = 'active',
    EVALUATE = 'evaluate',
}

// From: repository_ruleset.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { org_ruleset_conditions } from './org_ruleset_conditions';
import type { repository_rule } from './repository_rule';
import type { repository_rule_enforcement } from './repository_rule_enforcement';
import type { repository_ruleset_bypass_actor } from './repository_ruleset_bypass_actor';
import type { repository_ruleset_conditions } from './repository_ruleset_conditions';
/**
 * A set of rules to apply when specified conditions are met.
 */
export type repository_ruleset = {
    /**
     * The ID of the ruleset
     */
    id: number;
    /**
     * The name of the ruleset
     */
    name: string;
    /**
     * The target of the ruleset
     */
    target?: repository_ruleset.target;
    /**
     * The type of the source of the ruleset
     */
    source_type?: repository_ruleset.source_type;
    /**
     * The name of the source
     */
    source: string;
    enforcement: repository_rule_enforcement;
    /**
     * The actors that can bypass the rules in this ruleset
     */
    bypass_actors?: Array<repository_ruleset_bypass_actor>;
    /**
     * The bypass type of the user making the API request for this ruleset. This field is only returned when
     * querying the repository-level endpoint.
     */
    current_user_can_bypass?: repository_ruleset.current_user_can_bypass;
    node_id?: string;
    _links?: {
        self?: {
            /**
             * The URL of the ruleset
             */
            href?: string;
        };
        html?: {
            /**
             * The html URL of the ruleset
             */
            href?: string;
        } | null;
    };
    conditions?: (repository_ruleset_conditions | org_ruleset_conditions) | null;
    rules?: Array<repository_rule>;
    created_at?: string;
    updated_at?: string;
};
export namespace repository_ruleset {
    /**
     * The target of the ruleset
     */
    export enum target {
        BRANCH = 'branch',
        TAG = 'tag',
        PUSH = 'push',
        REPOSITORY = 'repository',
    }
    /**
     * The type of the source of the ruleset
     */
    export enum source_type {
        REPOSITORY = 'Repository',
        ORGANIZATION = 'Organization',
        ENTERPRISE = 'Enterprise',
    }
    /**
     * The bypass type of the user making the API request for this ruleset. This field is only returned when
     * querying the repository-level endpoint.
     */
    export enum current_user_can_bypass {
        ALWAYS = 'always',
        PULL_REQUESTS_ONLY = 'pull_requests_only',
        NEVER = 'never',
        EXEMPT = 'exempt',
    }
}


// From: repository_ruleset_bypass_actor.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * An actor that can bypass rules in a ruleset
 */
export type repository_ruleset_bypass_actor = {
    /**
     * The ID of the actor that can bypass a ruleset. Required for `Integration`, `RepositoryRole`, and `Team` actor types. If `actor_type` is `OrganizationAdmin`, this should be `1`. If `actor_type` is `DeployKey`, this should be null. `OrganizationAdmin` is not applicable for personal repositories.
     */
    actor_id?: number | null;
    /**
     * The type of actor that can bypass a ruleset.
     */
    actor_type: repository_ruleset_bypass_actor.actor_type;
    /**
     * When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests. `pull_request` is not applicable for the `DeployKey` actor type. Also, `pull_request` is only applicable to branch rulesets. When `bypass_mode` is `exempt`, rules will not be run for that actor and a bypass audit entry will not be created.
     */
    bypass_mode?: repository_ruleset_bypass_actor.bypass_mode;
};
export namespace repository_ruleset_bypass_actor {
    /**
     * The type of actor that can bypass a ruleset.
     */
    export enum actor_type {
        INTEGRATION = 'Integration',
        ORGANIZATION_ADMIN = 'OrganizationAdmin',
        REPOSITORY_ROLE = 'RepositoryRole',
        TEAM = 'Team',
        DEPLOY_KEY = 'DeployKey',
    }
    /**
     * When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests. `pull_request` is not applicable for the `DeployKey` actor type. Also, `pull_request` is only applicable to branch rulesets. When `bypass_mode` is `exempt`, rules will not be run for that actor and a bypass audit entry will not be created.
     */
    export enum bypass_mode {
        ALWAYS = 'always',
        PULL_REQUEST = 'pull_request',
        EXEMPT = 'exempt',
    }
}


// From: repository_ruleset_conditions.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Parameters for a repository ruleset ref name condition
 */
export type repository_ruleset_conditions = {
    ref_name?: {
        /**
         * Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
         */
        include?: Array<string>;
        /**
         * Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
         */
        exclude?: Array<string>;
    };
};


// From: repository_subscription.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Repository invitations let you manage who you collaborate with.
 */
export type repository_subscription = {
    /**
     * Determines if notifications should be received from this repository.
     */
    subscribed: boolean;
    /**
     * Determines if all notifications should be blocked from this repository.
     */
    ignored: boolean;
    reason: string | null;
    created_at: string;
    url: string;
    repository_url: string;
};


// From: review_comment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { author_association } from './author_association';
import type { link } from './link';
import type { nullable_simple_user } from './nullable_simple_user';
import type { reaction_rollup } from './reaction_rollup';
/**
 * Legacy Review Comment
 */
export type review_comment = {
    url: string;
    pull_request_review_id: number | null;
    id: number;
    node_id: string;
    diff_hunk: string;
    path: string;
    position: number | null;
    original_position: number;
    commit_id: string;
    original_commit_id: string;
    in_reply_to_id?: number;
    user: nullable_simple_user;
    body: string;
    created_at: string;
    updated_at: string;
    html_url: string;
    pull_request_url: string;
    author_association: author_association;
    _links: {
        self: link;
        html: link;
        pull_request: link;
    };
    body_text?: string;
    body_html?: string;
    reactions?: reaction_rollup;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    side?: review_comment.side;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    start_side?: review_comment.start_side | null;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    line?: number;
    /**
     * The original line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    original_line?: number;
    /**
     * The first line of the range for a multi-line comment.
     */
    start_line?: number | null;
    /**
     * The original first line of the range for a multi-line comment.
     */
    original_start_line?: number | null;
    /**
     * The level at which the comment is targeted, can be a diff line or a file.
     */
    subject_type?: review_comment.subject_type;
};
export namespace review_comment {
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    export enum side {
        LEFT = 'LEFT',
        RIGHT = 'RIGHT',
    }
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    export enum start_side {
        LEFT = 'LEFT',
        RIGHT = 'RIGHT',
    }
    /**
     * The level at which the comment is targeted, can be a diff line or a file.
     */
    export enum subject_type {
        LINE = 'line',
        FILE = 'file',
    }
}


// From: review_custom_gates_comment_required.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type review_custom_gates_comment_required = {
    /**
     * The name of the environment to approve or reject.
     */
    environment_name: string;
    /**
     * Comment associated with the pending deployment protection rule. **Required when state is not provided.**
     */
    comment: string;
};


// From: review_custom_gates_state_required.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type review_custom_gates_state_required = {
    /**
     * The name of the environment to approve or reject.
     */
    environment_name: string;
    /**
     * Whether to approve or reject deployment to the specified environments.
     */
    state: review_custom_gates_state_required.state;
    /**
     * Optional comment to include with the review.
     */
    comment?: string;
};
export namespace review_custom_gates_state_required {
    /**
     * Whether to approve or reject deployment to the specified environments.
     */
    export enum state {
        APPROVED = 'approved',
        REJECTED = 'rejected',
    }
}


// From: root.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type root = {
    current_user_url: string;
    current_user_authorizations_html_url: string;
    authorizations_url: string;
    code_search_url: string;
    commit_search_url: string;
    emails_url: string;
    emojis_url: string;
    events_url: string;
    feeds_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    /**
     * @deprecated
     */
    hub_url?: string;
    issue_search_url: string;
    issues_url: string;
    keys_url: string;
    label_search_url: string;
    notifications_url: string;
    organization_url: string;
    organization_repositories_url: string;
    organization_teams_url: string;
    public_gists_url: string;
    rate_limit_url: string;
    repository_url: string;
    repository_search_url: string;
    current_user_repositories_url: string;
    starred_url: string;
    starred_gists_url: string;
    topic_search_url?: string;
    user_url: string;
    user_organizations_url: string;
    user_repositories_url: string;
    user_search_url: string;
};


// From: rule_suite.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Response
 */
export type rule_suite = {
    /**
     * The unique identifier of the rule insight.
     */
    id?: number;
    /**
     * The number that identifies the user.
     */
    actor_id?: number | null;
    /**
     * The handle for the GitHub user account.
     */
    actor_name?: string | null;
    /**
     * The previous commit SHA of the ref.
     */
    before_sha?: string;
    /**
     * The new commit SHA of the ref.
     */
    after_sha?: string;
    /**
     * The ref name that the evaluation ran on.
     */
    ref?: string;
    /**
     * The ID of the repository associated with the rule evaluation.
     */
    repository_id?: number;
    /**
     * The name of the repository without the `.git` extension.
     */
    repository_name?: string;
    pushed_at?: string;
    /**
     * The result of the rule evaluations for rules with the `active` enforcement status.
     */
    result?: rule_suite.result;
    /**
     * The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`. Null if no rules with `evaluate` enforcement status were run.
     */
    evaluation_result?: rule_suite.evaluation_result | null;
    /**
     * Details on the evaluated rules.
     */
    rule_evaluations?: Array<{
        rule_source?: {
            /**
             * The type of rule source.
             */
            type?: string;
            /**
             * The ID of the rule source.
             */
            id?: number | null;
            /**
             * The name of the rule source.
             */
            name?: string | null;
        };
        /**
         * The enforcement level of this rule source.
         */
        enforcement?: 'active' | 'evaluate' | 'deleted ruleset';
        /**
         * The result of the evaluation of the individual rule.
         */
        result?: 'pass' | 'fail';
        /**
         * The type of rule.
         */
        rule_type?: string;
        /**
         * The detailed failure message for the rule. Null if the rule passed.
         */
        details?: string | null;
    }>;
};
export namespace rule_suite {
    /**
     * The result of the rule evaluations for rules with the `active` enforcement status.
     */
    export enum result {
        PASS = 'pass',
        FAIL = 'fail',
        BYPASS = 'bypass',
    }
    /**
     * The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`. Null if no rules with `evaluate` enforcement status were run.
     */
    export enum evaluation_result {
        PASS = 'pass',
        FAIL = 'fail',
        BYPASS = 'bypass',
    }
}


// From: rule_suites.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Response
 */
export type rule_suites = Array<{
    /**
     * The unique identifier of the rule insight.
     */
    id?: number;
    /**
     * The number that identifies the user.
     */
    actor_id?: number;
    /**
     * The handle for the GitHub user account.
     */
    actor_name?: string;
    /**
     * The first commit sha before the push evaluation.
     */
    before_sha?: string;
    /**
     * The last commit sha in the push evaluation.
     */
    after_sha?: string;
    /**
     * The ref name that the evaluation ran on.
     */
    ref?: string;
    /**
     * The ID of the repository associated with the rule evaluation.
     */
    repository_id?: number;
    /**
     * The name of the repository without the `.git` extension.
     */
    repository_name?: string;
    pushed_at?: string;
    /**
     * The result of the rule evaluations for rules with the `active` enforcement status.
     */
    result?: 'pass' | 'fail' | 'bypass';
    /**
     * The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.
     */
    evaluation_result?: 'pass' | 'fail' | 'bypass';
}>;

// From: ruleset_version.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The historical version of a ruleset
 */
export type ruleset_version = {
    /**
     * The ID of the previous version of the ruleset
     */
    version_id: number;
    /**
     * The actor who updated the ruleset
     */
    actor: {
        id?: number;
        type?: string;
    };
    updated_at: string;
};


// From: ruleset_version_with_state.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { ruleset_version } from './ruleset_version';
export type ruleset_version_with_state = (ruleset_version & {
    /**
     * The state of the ruleset version
     */
    state: Record<string, any>;
});


// From: runner.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { runner_label } from './runner_label';
/**
 * A self hosted runner
 */
export type runner = {
    /**
     * The ID of the runner.
     */
    id: number;
    /**
     * The ID of the runner group.
     */
    runner_group_id?: number;
    /**
     * The name of the runner.
     */
    name: string;
    /**
     * The Operating System of the runner.
     */
    os: string;
    /**
     * The status of the runner.
     */
    status: string;
    busy: boolean;
    labels: Array<runner_label>;
    ephemeral?: boolean;
};


// From: runner_application.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Runner Application
 */
export type runner_application = {
    os: string;
    architecture: string;
    download_url: string;
    filename: string;
    /**
     * A short lived bearer token used to download the runner, if needed.
     */
    temp_download_token?: string;
    sha256_checksum?: string;
};


// From: runner_groups_org.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type runner_groups_org = {
    id: number;
    name: string;
    visibility: string;
    default: boolean;
    /**
     * Link to the selected repositories resource for this runner group. Not present unless visibility was set to `selected`
     */
    selected_repositories_url?: string;
    runners_url: string;
    hosted_runners_url?: string;
    /**
     * The identifier of a hosted compute network configuration.
     */
    network_configuration_id?: string;
    inherited: boolean;
    inherited_allows_public_repositories?: boolean;
    allows_public_repositories: boolean;
    /**
     * If `true`, the `restricted_to_workflows` and `selected_workflows` fields cannot be modified.
     */
    workflow_restrictions_read_only?: boolean;
    /**
     * If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
     */
    restricted_to_workflows?: boolean;
    /**
     * List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
     */
    selected_workflows?: Array<string>;
};


// From: runner_label.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A label for a self hosted runner
 */
export type runner_label = {
    /**
     * Unique identifier of the label.
     */
    id?: number;
    /**
     * Name of the label.
     */
    name: string;
    /**
     * The type of label. Read-only labels are applied automatically when the runner is configured.
     */
    type?: runner_label.type;
};
export namespace runner_label {
    /**
     * The type of label. Read-only labels are applied automatically when the runner is configured.
     */
    export enum type {
        READ_ONLY = 'read-only',
        CUSTOM = 'custom',
    }
}


// From: selected_actions.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type selected_actions = {
    /**
     * Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.
     */
    github_owned_allowed?: boolean;
    /**
     * Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.
     */
    verified_allowed?: boolean;
    /**
     * Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa*`.
     *
     * > [!NOTE]
     * > The `patterns_allowed` setting only applies to public repositories.
     */
    patterns_allowed?: Array<string>;
};


// From: self_hosted_runners_settings.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type self_hosted_runners_settings = {
    /**
     * The policy that controls whether self-hosted runners can be used by repositories in the organization
     */
    enabled_repositories: self_hosted_runners_settings.enabled_repositories;
    /**
     * The URL to the endpoint for managing selected repositories for self-hosted runners in the organization
     */
    selected_repositories_url?: string;
};
export namespace self_hosted_runners_settings {
    /**
     * The policy that controls whether self-hosted runners can be used by repositories in the organization
     */
    export enum enabled_repositories {
        ALL = 'all',
        SELECTED = 'selected',
        NONE = 'none',
    }
}


// From: sha_pinning_required.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Whether actions must be pinned to a full-length commit SHA.
 */
export type sha_pinning_required = boolean;

// From: short_branch.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { branch_protection } from './branch_protection';
/**
 * Short Branch
 */
export type short_branch = {
    name: string;
    commit: {
        sha: string;
        url: string;
    };
    protected: boolean;
    protection?: branch_protection;
    protection_url?: string;
};


// From: simple_user.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A GitHub user.
 */
export type simple_user = {
    name?: string | null;
    email?: string | null;
    login: string;
    id: number;
    node_id: string;
    avatar_url: string;
    gravatar_id: string | null;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    starred_at?: string;
    user_view_type?: string;
};


// From: social_account.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Social media account
 */
export type social_account = {
    provider: string;
    url: string;
};


// From: ssh_signing_key.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A public SSH key used to sign Git commits
 */
export type ssh_signing_key = {
    key: string;
    id: number;
    title: string;
    created_at: string;
};


// From: stargazer.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_simple_user } from './nullable_simple_user';
/**
 * Stargazer
 */
export type stargazer = {
    starred_at: string;
    user: nullable_simple_user;
};


// From: starred_repository.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { repository } from './repository';
/**
 * Starred Repository
 */
export type starred_repository = {
    starred_at: string;
    repo: repository;
};


// From: status.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Returns check runs with the specified `status`.
 */
export enum status {
    QUEUED = 'queued',
    IN_PROGRESS = 'in_progress',
    COMPLETED = 'completed',
}

// From: status_check_policy.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Status Check Policy
 */
export type status_check_policy = {
    url: string;
    strict: boolean;
    contexts: Array<string>;
    checks: Array<{
        context: string;
        app_id: number | null;
    }>;
    contexts_url: string;
};


// From: tag.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Tag
 */
export type tag = {
    name: string;
    commit: {
        sha: string;
        url: string;
    };
    zipball_url: string;
    tarball_url: string;
    node_id: string;
};


// From: tag_protection.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Tag protection
 */
export type tag_protection = {
    id?: number;
    created_at?: string;
    updated_at?: string;
    enabled?: boolean;
    pattern: string;
};


// From: team.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_team_simple } from './nullable_team_simple';
/**
 * Groups of organization members that gives permissions on specified repositories.
 */
export type team = {
    id: number;
    node_id: string;
    name: string;
    slug: string;
    description: string | null;
    privacy?: string;
    notification_setting?: string;
    permission: string;
    permissions?: {
        pull: boolean;
        triage: boolean;
        push: boolean;
        maintain: boolean;
        admin: boolean;
    };
    url: string;
    html_url: string;
    members_url: string;
    repositories_url: string;
    /**
     * The ownership type of the team
     */
    type: team.type;
    /**
     * Unique identifier of the organization to which this team belongs
     */
    organization_id?: number;
    /**
     * Unique identifier of the enterprise to which this team belongs
     */
    enterprise_id?: number;
    parent: nullable_team_simple;
};
export namespace team {
    /**
     * The ownership type of the team
     */
    export enum type {
        ENTERPRISE = 'enterprise',
        ORGANIZATION = 'organization',
    }
}


// From: team_role_assignment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { nullable_team_simple } from './nullable_team_simple';
/**
 * The Relationship a Team has with a role.
 */
export type team_role_assignment = {
    /**
     * Determines if the team has a direct, indirect, or mixed relationship to a role
     */
    assignment?: team_role_assignment.assignment;
    id: number;
    node_id: string;
    name: string;
    slug: string;
    description: string | null;
    privacy?: string;
    notification_setting?: string;
    permission: string;
    permissions?: {
        pull: boolean;
        triage: boolean;
        push: boolean;
        maintain: boolean;
        admin: boolean;
    };
    url: string;
    html_url: string;
    members_url: string;
    repositories_url: string;
    parent: nullable_team_simple;
    /**
     * The ownership type of the team
     */
    type: team_role_assignment.type;
    /**
     * Unique identifier of the organization to which this team belongs
     */
    organization_id?: number;
    /**
     * Unique identifier of the enterprise to which this team belongs
     */
    enterprise_id?: number;
};
export namespace team_role_assignment {
    /**
     * Determines if the team has a direct, indirect, or mixed relationship to a role
     */
    export enum assignment {
        DIRECT = 'direct',
        INDIRECT = 'indirect',
        MIXED = 'mixed',
    }
    /**
     * The ownership type of the team
     */
    export enum type {
        ENTERPRISE = 'enterprise',
        ORGANIZATION = 'organization',
    }
}


// From: team_simple.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Groups of organization members that gives permissions on specified repositories.
 */
export type team_simple = {
    /**
     * Unique identifier of the team
     */
    id: number;
    node_id: string;
    /**
     * URL for the team
     */
    url: string;
    members_url: string;
    /**
     * Name of the team
     */
    name: string;
    /**
     * Description of the team
     */
    description: string | null;
    /**
     * Permission that the team will have for its repositories
     */
    permission: string;
    /**
     * The level of privacy this team should have
     */
    privacy?: string;
    /**
     * The notification setting the team has set
     */
    notification_setting?: string;
    html_url: string;
    repositories_url: string;
    slug: string;
    /**
     * Distinguished Name (DN) that team maps to within LDAP environment
     */
    ldap_dn?: string;
    /**
     * The ownership type of the team
     */
    type: team_simple.type;
    /**
     * Unique identifier of the organization to which this team belongs
     */
    organization_id?: number;
    /**
     * Unique identifier of the enterprise to which this team belongs
     */
    enterprise_id?: number;
};
export namespace team_simple {
    /**
     * The ownership type of the team
     */
    export enum type {
        ENTERPRISE = 'enterprise',
        ORGANIZATION = 'organization',
    }
}


// From: thread.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { minimal_repository } from './minimal_repository';
/**
 * Thread
 */
export type thread = {
    id: string;
    repository: minimal_repository;
    subject: {
        title: string;
        url: string;
        latest_comment_url: string;
        type: string;
    };
    reason: string;
    unread: boolean;
    updated_at: string;
    last_read_at: string | null;
    url: string;
    subscription_url: string;
};


// From: thread_subscription.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Thread Subscription
 */
export type thread_subscription = {
    subscribed: boolean;
    ignored: boolean;
    reason: string | null;
    created_at: string | null;
    url: string;
    thread_url?: string;
    repository_url?: string;
};


// From: timeline_issue_events.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { added_to_project_issue_event } from './added_to_project_issue_event';
import type { converted_note_to_issue_issue_event } from './converted_note_to_issue_issue_event';
import type { demilestoned_issue_event } from './demilestoned_issue_event';
import type { labeled_issue_event } from './labeled_issue_event';
import type { locked_issue_event } from './locked_issue_event';
import type { milestoned_issue_event } from './milestoned_issue_event';
import type { moved_column_in_project_issue_event } from './moved_column_in_project_issue_event';
import type { removed_from_project_issue_event } from './removed_from_project_issue_event';
import type { renamed_issue_event } from './renamed_issue_event';
import type { review_dismissed_issue_event } from './review_dismissed_issue_event';
import type { review_request_removed_issue_event } from './review_request_removed_issue_event';
import type { review_requested_issue_event } from './review_requested_issue_event';
import type { state_change_issue_event } from './state_change_issue_event';
import type { timeline_assigned_issue_event } from './timeline_assigned_issue_event';
import type { timeline_comment_event } from './timeline_comment_event';
import type { timeline_commit_commented_event } from './timeline_commit_commented_event';
import type { timeline_committed_event } from './timeline_committed_event';
import type { timeline_cross_referenced_event } from './timeline_cross_referenced_event';
import type { timeline_line_commented_event } from './timeline_line_commented_event';
import type { timeline_reviewed_event } from './timeline_reviewed_event';
import type { timeline_unassigned_issue_event } from './timeline_unassigned_issue_event';
import type { unlabeled_issue_event } from './unlabeled_issue_event';
/**
 * Timeline Event
 */
export type timeline_issue_events = (labeled_issue_event | unlabeled_issue_event | milestoned_issue_event | demilestoned_issue_event | renamed_issue_event | review_requested_issue_event | review_request_removed_issue_event | review_dismissed_issue_event | locked_issue_event | added_to_project_issue_event | moved_column_in_project_issue_event | removed_from_project_issue_event | converted_note_to_issue_issue_event | timeline_comment_event | timeline_cross_referenced_event | timeline_committed_event | timeline_reviewed_event | timeline_line_commented_event | timeline_commit_commented_event | timeline_assigned_issue_event | timeline_unassigned_issue_event | state_change_issue_event);


// From: topic.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A topic aggregates entities that are related to a subject.
 */
export type topic = {
    names: Array<string>;
};


// From: user_role_assignment.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { team_simple } from './team_simple';
/**
 * The Relationship a User has with a role.
 */
export type user_role_assignment = {
    /**
     * Determines if the user has a direct, indirect, or mixed relationship to a role
     */
    assignment?: user_role_assignment.assignment;
    /**
     * Team the user has gotten the role through
     */
    inherited_from?: Array<team_simple>;
    name?: string | null;
    email?: string | null;
    login: string;
    id: number;
    node_id: string;
    avatar_url: string;
    gravatar_id: string | null;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    starred_at?: string;
    user_view_type?: string;
};
export namespace user_role_assignment {
    /**
     * Determines if the user has a direct, indirect, or mixed relationship to a role
     */
    export enum assignment {
        DIRECT = 'direct',
        INDIRECT = 'indirect',
        MIXED = 'mixed',
    }
}


// From: view_traffic.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { traffic } from './traffic';
/**
 * View Traffic
 */
export type view_traffic = {
    count: number;
    uniques: number;
    views: Array<traffic>;
};


// From: wait_timer.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).
 */
export type wait_timer = number;

// From: webhook_config.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { webhook_config_content_type } from './webhook_config_content_type';
import type { webhook_config_insecure_ssl } from './webhook_config_insecure_ssl';
import type { webhook_config_secret } from './webhook_config_secret';
import type { webhook_config_url } from './webhook_config_url';
/**
 * Configuration object of the webhook
 */
export type webhook_config = {
    url?: webhook_config_url;
    content_type?: webhook_config_content_type;
    secret?: webhook_config_secret;
    insecure_ssl?: webhook_config_insecure_ssl;
};


// From: webhook_config_content_type.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
 */
export type webhook_config_content_type = string;

// From: webhook_config_insecure_ssl.ts
/* generated using openapi-typescript-codegen -- do not edit */
export type webhook_config_insecure_ssl = (string | number);


// From: webhook_config_secret.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).
 */
export type webhook_config_secret = string;

// From: webhook_config_url.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * The URL to which the payloads will be delivered.
 */
export type webhook_config_url = string;

// From: workflow.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * A GitHub Actions workflow
 */
export type workflow = {
    id: number;
    node_id: string;
    name: string;
    path: string;
    state: workflow.state;
    created_at: string;
    updated_at: string;
    url: string;
    html_url: string;
    badge_url: string;
    deleted_at?: string;
};
export namespace workflow {
    export enum state {
        ACTIVE = 'active',
        DELETED = 'deleted',
        DISABLED_FORK = 'disabled_fork',
        DISABLED_INACTIVITY = 'disabled_inactivity',
        DISABLED_MANUALLY = 'disabled_manually',
    }
}


// From: workflow_run.ts
/* generated using openapi-typescript-codegen -- do not edit */
import type { minimal_repository } from './minimal_repository';
import type { nullable_simple_commit } from './nullable_simple_commit';
import type { pull_request_minimal } from './pull_request_minimal';
import type { referenced_workflow } from './referenced_workflow';
import type { simple_user } from './simple_user';
/**
 * An invocation of a workflow
 */
export type workflow_run = {
    /**
     * The ID of the workflow run.
     */
    id: number;
    /**
     * The name of the workflow run.
     */
    name?: string | null;
    node_id: string;
    /**
     * The ID of the associated check suite.
     */
    check_suite_id?: number;
    /**
     * The node ID of the associated check suite.
     */
    check_suite_node_id?: string;
    head_branch: string | null;
    /**
     * The SHA of the head commit that points to the version of the workflow being run.
     */
    head_sha: string;
    /**
     * The full path of the workflow
     */
    path: string;
    /**
     * The auto incrementing run number for the workflow run.
     */
    run_number: number;
    /**
     * Attempt number of the run, 1 for first attempt and higher if the workflow was re-run.
     */
    run_attempt?: number;
    referenced_workflows?: Array<referenced_workflow> | null;
    event: string;
    status: string | null;
    conclusion: string | null;
    /**
     * The ID of the parent workflow.
     */
    workflow_id: number;
    /**
     * The URL to the workflow run.
     */
    url: string;
    html_url: string;
    /**
     * Pull requests that are open with a `head_sha` or `head_branch` that matches the workflow run. The returned pull requests do not necessarily indicate pull requests that triggered the run.
     */
    pull_requests: Array<pull_request_minimal> | null;
    created_at: string;
    updated_at: string;
    actor?: simple_user;
    triggering_actor?: simple_user;
    /**
     * The start time of the latest run. Resets on re-run.
     */
    run_started_at?: string;
    /**
     * The URL to the jobs for the workflow run.
     */
    jobs_url: string;
    /**
     * The URL to download the logs for the workflow run.
     */
    logs_url: string;
    /**
     * The URL to the associated check suite.
     */
    check_suite_url: string;
    /**
     * The URL to the artifacts for the workflow run.
     */
    artifacts_url: string;
    /**
     * The URL to cancel the workflow run.
     */
    cancel_url: string;
    /**
     * The URL to rerun the workflow run.
     */
    rerun_url: string;
    /**
     * The URL to the previous attempted run of this workflow, if one exists.
     */
    previous_attempt_url?: string | null;
    /**
     * The URL to the workflow.
     */
    workflow_url: string;
    head_commit: nullable_simple_commit;
    repository: minimal_repository;
    head_repository: minimal_repository;
    head_repository_id?: number;
    /**
     * The event-specific title associated with the run or the run-name if set, or the value of `run-name` if it is set in the workflow.
     */
    display_title: string;
};


// From: workflow_run_usage.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Workflow Run Usage
 */
export type workflow_run_usage = {
    billable: {
        UBUNTU?: {
            total_ms: number;
            jobs: number;
            job_runs?: Array<{
                job_id: number;
                duration_ms: number;
            }>;
        };
        MACOS?: {
            total_ms: number;
            jobs: number;
            job_runs?: Array<{
                job_id: number;
                duration_ms: number;
            }>;
        };
        WINDOWS?: {
            total_ms: number;
            jobs: number;
            job_runs?: Array<{
                job_id: number;
                duration_ms: number;
            }>;
        };
    };
    run_duration_ms?: number;
};


// From: workflow_usage.ts
/* generated using openapi-typescript-codegen -- do not edit */
/**
 * Workflow Usage
 */
export type workflow_usage = {
    billable: {
        UBUNTU?: {
            total_ms?: number;
        };
        MACOS?: {
            total_ms?: number;
        };
        WINDOWS?: {
            total_ms?: number;
        };
    };
};



// ============================================================================
// API SERVICES
// ============================================================================

// From: ActionsService.ts
export class ActionsService {
    /**
     * Get GitHub Actions cache retention limit for an enterprise
     * Gets GitHub Actions cache retention limit for an enterprise. All organizations and repositories under this
     * enterprise may not set a higher cache retention limit.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
     * @param enterprise The slug version of the enterprise name.
     * @returns actions_cache_retention_limit_for_enterprise Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheRetentionLimitForEnterprise(
        enterprise: string,
    ): CancelablePromise<actions_cache_retention_limit_for_enterprise> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/enterprises/{enterprise}/actions/cache/retention-limit',
            path: {
                'enterprise': enterprise,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set GitHub Actions cache retention limit for an enterprise
     * Sets GitHub Actions cache retention limit for an enterprise. All organizations and repositories under this
     * enterprise may not set a higher cache retention limit.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
     * @param enterprise The slug version of the enterprise name.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetActionsCacheRetentionLimitForEnterprise(
        enterprise: string,
        requestBody: actions_cache_retention_limit_for_enterprise,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/enterprises/{enterprise}/actions/cache/retention-limit',
            path: {
                'enterprise': enterprise,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get GitHub Actions cache storage limit for an enterprise
     * Gets GitHub Actions cache storage limit for an enterprise. All organizations and repositories under this
     * enterprise may not set a higher cache storage limit.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
     * @param enterprise The slug version of the enterprise name.
     * @returns actions_cache_storage_limit_for_enterprise Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheStorageLimitForEnterprise(
        enterprise: string,
    ): CancelablePromise<actions_cache_storage_limit_for_enterprise> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/enterprises/{enterprise}/actions/cache/storage-limit',
            path: {
                'enterprise': enterprise,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set GitHub Actions cache storage limit for an enterprise
     * Sets GitHub Actions cache storage limit for an enterprise. All organizations and repositories under this
     * enterprise may not set a higher cache storage limit.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
     * @param enterprise The slug version of the enterprise name.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetActionsCacheStorageLimitForEnterprise(
        enterprise: string,
        requestBody: actions_cache_storage_limit_for_enterprise,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/enterprises/{enterprise}/actions/cache/storage-limit',
            path: {
                'enterprise': enterprise,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get GitHub Actions cache retention limit for an organization
     * Gets GitHub Actions cache retention limit for an organization. All repositories under this
     * organization may not set a higher cache retention limit.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:organization` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_cache_retention_limit_for_organization Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheRetentionLimitForOrganization(
        org: string,
    ): CancelablePromise<actions_cache_retention_limit_for_organization> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/organizations/{org}/actions/cache/retention-limit',
            path: {
                'org': org,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set GitHub Actions cache retention limit for an organization
     * Sets GitHub Actions cache retention limit for an organization. All repositories under this
     * organization may not set a higher cache retention limit.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:organization` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetActionsCacheRetentionLimitForOrganization(
        org: string,
        requestBody: actions_cache_retention_limit_for_organization,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/organizations/{org}/actions/cache/retention-limit',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get GitHub Actions cache storage limit for an organization
     * Gets GitHub Actions cache storage limit for an organization. All repositories under this
     * organization may not set a higher cache storage limit.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:organization` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_cache_storage_limit_for_organization Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheStorageLimitForOrganization(
        org: string,
    ): CancelablePromise<actions_cache_storage_limit_for_organization> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/organizations/{org}/actions/cache/storage-limit',
            path: {
                'org': org,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set GitHub Actions cache storage limit for an organization
     * Sets GitHub Actions cache storage limit for an organization. All organizations and repositories under this
     * organization may not set a higher cache storage limit.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:organization` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetActionsCacheStorageLimitForOrganization(
        org: string,
        requestBody: actions_cache_storage_limit_for_organization,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/organizations/{org}/actions/cache/storage-limit',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get GitHub Actions cache usage for an organization
     * Gets the total GitHub Actions cache usage for an organization.
     * The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
     *
     * OAuth tokens and personal access tokens (classic) need the `read:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_cache_usage_org_enterprise Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheUsageForOrg(
        org: string,
    ): CancelablePromise<actions_cache_usage_org_enterprise> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/cache/usage',
            path: {
                'org': org,
            },
        });
    }
    /**
     * List repositories with GitHub Actions cache usage for an organization
     * Lists repositories and their GitHub Actions cache usage for an organization.
     * The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
     *
     * OAuth tokens and personal access tokens (classic) need the `read:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheUsageByRepoForOrg(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        repository_cache_usages: Array<actions_cache_usage_by_repository>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/cache/usage-by-repository',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List GitHub-hosted runners for an organization
     * Lists all GitHub-hosted runners configured in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `manage_runner:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListHostedRunnersForOrg(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        runners: Array<actions_hosted_runner>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create a GitHub-hosted runner for an organization
     * Creates a GitHub-hosted runner for an organization.
     * OAuth tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns actions_hosted_runner Response
     * @throws ApiError
     */
    public static actionsCreateHostedRunnerForOrg(
        org: string,
        requestBody: {
            /**
             * Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'.
             */
            name: string;
            /**
             * The image of runner. To list all available images, use `GET /actions/hosted-runners/images/github-owned` or `GET /actions/hosted-runners/images/partner`.
             */
            image: {
                /**
                 * The unique identifier of the runner image.
                 */
                id?: string;
                /**
                 * The source of the runner image.
                 */
                source?: 'github' | 'partner' | 'custom';
                /**
                 * The version of the runner image to deploy. This is relevant only for runners using custom images.
                 */
                version?: string | null;
            };
            /**
             * The machine size of the runner. To list available sizes, use `GET actions/hosted-runners/machine-sizes`
             */
            size: string;
            /**
             * The existing runner group to add this runner to.
             */
            runner_group_id: number;
            /**
             * The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.
             */
            maximum_runners?: number;
            /**
             * Whether this runner should be created with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`
             */
            enable_static_ip?: boolean;
            /**
             * Whether this runner should be used to generate custom images.
             */
            image_gen?: boolean;
        },
    ): CancelablePromise<actions_hosted_runner> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/actions/hosted-runners',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List custom images for an organization
     * List custom images for an organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListCustomImagesForOrg(
        org: string,
    ): CancelablePromise<{
        total_count: number;
        images: Array<actions_hosted_runner_custom_image>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/images/custom',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Get a custom image definition for GitHub Actions Hosted Runners
     * Get a custom image definition for GitHub Actions Hosted Runners.
     *
     * OAuth tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param imageDefinitionId Image definition ID of custom image
     * @returns actions_hosted_runner_custom_image Response
     * @throws ApiError
     */
    public static actionsGetCustomImageForOrg(
        org: string,
        imageDefinitionId: number,
    ): CancelablePromise<actions_hosted_runner_custom_image> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}',
            path: {
                'org': org,
                'image_definition_id': imageDefinitionId,
            },
        });
    }
    /**
     * Delete a custom image from the organization
     * Delete a custom image from the organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param imageDefinitionId Image definition ID of custom image
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteCustomImageFromOrg(
        org: string,
        imageDefinitionId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}',
            path: {
                'org': org,
                'image_definition_id': imageDefinitionId,
            },
        });
    }
    /**
     * List image versions of a custom image for an organization
     * List image versions of a custom image for an organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
     * @param imageDefinitionId Image definition ID of custom image
     * @param org The organization name. The name is not case sensitive.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListCustomImageVersionsForOrg(
        imageDefinitionId: number,
        org: string,
    ): CancelablePromise<{
        total_count: number;
        image_versions: Array<actions_hosted_runner_custom_image_version>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}/versions',
            path: {
                'image_definition_id': imageDefinitionId,
                'org': org,
            },
        });
    }
    /**
     * Get an image version of a custom image for GitHub Actions Hosted Runners
     * Get an image version of a custom image for GitHub Actions Hosted Runners.
     *
     * OAuth tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param imageDefinitionId Image definition ID of custom image
     * @param version Version of a custom image
     * @returns actions_hosted_runner_custom_image_version Response
     * @throws ApiError
     */
    public static actionsGetCustomImageVersionForOrg(
        org: string,
        imageDefinitionId: number,
        version: string,
    ): CancelablePromise<actions_hosted_runner_custom_image_version> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}/versions/{version}',
            path: {
                'org': org,
                'image_definition_id': imageDefinitionId,
                'version': version,
            },
        });
    }
    /**
     * Delete an image version of custom image from the organization
     * Delete an image version of custom image from the organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param imageDefinitionId Image definition ID of custom image
     * @param version Version of a custom image
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteCustomImageVersionFromOrg(
        org: string,
        imageDefinitionId: number,
        version: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}/versions/{version}',
            path: {
                'org': org,
                'image_definition_id': imageDefinitionId,
                'version': version,
            },
        });
    }
    /**
     * Get GitHub-owned images for GitHub-hosted runners in an organization
     * Get the list of GitHub-owned images available for GitHub-hosted runners for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsGetHostedRunnersGithubOwnedImagesForOrg(
        org: string,
    ): CancelablePromise<{
        total_count: number;
        images: Array<actions_hosted_runner_curated_image>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/images/github-owned',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Get partner images for GitHub-hosted runners in an organization
     * Get the list of partner images available for GitHub-hosted runners for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsGetHostedRunnersPartnerImagesForOrg(
        org: string,
    ): CancelablePromise<{
        total_count: number;
        images: Array<actions_hosted_runner_curated_image>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/images/partner',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Get limits on GitHub-hosted runners for an organization
     * Get the GitHub-hosted runners limits for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_hosted_runner_limits Response
     * @throws ApiError
     */
    public static actionsGetHostedRunnersLimitsForOrg(
        org: string,
    ): CancelablePromise<actions_hosted_runner_limits> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/limits',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Get GitHub-hosted runners machine specs for an organization
     * Get the list of machine specs available for GitHub-hosted runners for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsGetHostedRunnersMachineSpecsForOrg(
        org: string,
    ): CancelablePromise<{
        total_count: number;
        machine_specs: Array<actions_hosted_runner_machine_spec>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/machine-sizes',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Get platforms for GitHub-hosted runners in an organization
     * Get the list of platforms available for GitHub-hosted runners for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsGetHostedRunnersPlatformsForOrg(
        org: string,
    ): CancelablePromise<{
        total_count: number;
        platforms: Array<string>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/platforms',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Get a GitHub-hosted runner for an organization
     * Gets a GitHub-hosted runner configured in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param hostedRunnerId Unique identifier of the GitHub-hosted runner.
     * @returns actions_hosted_runner Response
     * @throws ApiError
     */
    public static actionsGetHostedRunnerForOrg(
        org: string,
        hostedRunnerId: number,
    ): CancelablePromise<actions_hosted_runner> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/hosted-runners/{hosted_runner_id}',
            path: {
                'org': org,
                'hosted_runner_id': hostedRunnerId,
            },
        });
    }
    /**
     * Update a GitHub-hosted runner for an organization
     * Updates a GitHub-hosted runner for an organization.
     * OAuth app tokens and personal access tokens (classic) need the `manage_runners:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param hostedRunnerId Unique identifier of the GitHub-hosted runner.
     * @param requestBody
     * @returns actions_hosted_runner Response
     * @throws ApiError
     */
    public static actionsUpdateHostedRunnerForOrg(
        org: string,
        hostedRunnerId: number,
        requestBody: {
            /**
             * Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'.
             */
            name?: string;
            /**
             * The existing runner group to add this runner to.
             */
            runner_group_id?: number;
            /**
             * The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.
             */
            maximum_runners?: number;
            /**
             * Whether this runner should be updated with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`
             */
            enable_static_ip?: boolean;
            /**
             * The version of the runner image to deploy. This is relevant only for runners using custom images.
             */
            image_version?: string | null;
        },
    ): CancelablePromise<actions_hosted_runner> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/orgs/{org}/actions/hosted-runners/{hosted_runner_id}',
            path: {
                'org': org,
                'hosted_runner_id': hostedRunnerId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a GitHub-hosted runner for an organization
     * Deletes a GitHub-hosted runner for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @param hostedRunnerId Unique identifier of the GitHub-hosted runner.
     * @returns actions_hosted_runner Response
     * @throws ApiError
     */
    public static actionsDeleteHostedRunnerForOrg(
        org: string,
        hostedRunnerId: number,
    ): CancelablePromise<actions_hosted_runner> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/hosted-runners/{hosted_runner_id}',
            path: {
                'org': org,
                'hosted_runner_id': hostedRunnerId,
            },
        });
    }
    /**
     * Get GitHub Actions permissions for an organization
     * Gets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_organization_permissions Response
     * @throws ApiError
     */
    public static actionsGetGithubActionsPermissionsOrganization(
        org: string,
    ): CancelablePromise<actions_organization_permissions> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/permissions',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Set GitHub Actions permissions for an organization
     * Sets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetGithubActionsPermissionsOrganization(
        org: string,
        requestBody: {
            enabled_repositories: enabled_repositories;
            allowed_actions?: allowed_actions;
            sha_pinning_required?: sha_pinning_required;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get artifact and log retention settings for an organization
     * Gets artifact and log retention settings for an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope or the "Actions policies" fine-grained permission to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_artifact_and_log_retention_response Response
     * @throws ApiError
     */
    public static actionsGetArtifactAndLogRetentionSettingsOrganization(
        org: string,
    ): CancelablePromise<actions_artifact_and_log_retention_response> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/permissions/artifact-and-log-retention',
            path: {
                'org': org,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set artifact and log retention settings for an organization
     * Sets artifact and log retention settings for an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope or the "Actions policies" fine-grained permission to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetArtifactAndLogRetentionSettingsOrganization(
        org: string,
        requestBody: actions_artifact_and_log_retention,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/artifact-and-log-retention',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get fork PR contributor approval permissions for an organization
     * Gets the fork PR contributor approval policy for an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope or the "Actions policies" fine-grained permission to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_fork_pr_contributor_approval Response
     * @throws ApiError
     */
    public static actionsGetForkPrContributorApprovalPermissionsOrganization(
        org: string,
    ): CancelablePromise<actions_fork_pr_contributor_approval> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/permissions/fork-pr-contributor-approval',
            path: {
                'org': org,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set fork PR contributor approval permissions for an organization
     * Sets the fork PR contributor approval policy for an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetForkPrContributorApprovalPermissionsOrganization(
        org: string,
        requestBody: actions_fork_pr_contributor_approval,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/fork-pr-contributor-approval',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get private repo fork PR workflow settings for an organization
     * Gets the settings for whether workflows from fork pull requests can run on private repositories in an organization.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_fork_pr_workflows_private_repos Response
     * @throws ApiError
     */
    public static actionsGetPrivateRepoForkPrWorkflowsSettingsOrganization(
        org: string,
    ): CancelablePromise<actions_fork_pr_workflows_private_repos> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/permissions/fork-pr-workflows-private-repos',
            path: {
                'org': org,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set private repo fork PR workflow settings for an organization
     * Sets the settings for whether workflows from fork pull requests can run on private repositories in an organization.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetPrivateRepoForkPrWorkflowsSettingsOrganization(
        org: string,
        requestBody: actions_fork_pr_workflows_private_repos_request,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/fork-pr-workflows-private-repos',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden - Fork PR workflow settings for private repositories are managed by the enterprise owner`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List selected repositories enabled for GitHub Actions in an organization
     * Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        repositories: Array<repository>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/permissions/repositories',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Set selected repositories enabled for GitHub Actions in an organization
     * Replaces the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
        org: string,
        requestBody: {
            /**
             * List of repository IDs to enable for GitHub Actions.
             */
            selected_repository_ids: Array<number>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/repositories',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Enable a selected repository for GitHub Actions in an organization
     * Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param repositoryId The unique identifier of the repository.
     * @returns void
     * @throws ApiError
     */
    public static actionsEnableSelectedRepositoryGithubActionsOrganization(
        org: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/repositories/{repository_id}',
            path: {
                'org': org,
                'repository_id': repositoryId,
            },
        });
    }
    /**
     * Disable a selected repository for GitHub Actions in an organization
     * Removes a repository from the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param repositoryId The unique identifier of the repository.
     * @returns void
     * @throws ApiError
     */
    public static actionsDisableSelectedRepositoryGithubActionsOrganization(
        org: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/permissions/repositories/{repository_id}',
            path: {
                'org': org,
                'repository_id': repositoryId,
            },
        });
    }
    /**
     * Get allowed actions and reusable workflows for an organization
     * Gets the selected actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns selected_actions Response
     * @throws ApiError
     */
    public static actionsGetAllowedActionsOrganization(
        org: string,
    ): CancelablePromise<selected_actions> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/permissions/selected-actions',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Set allowed actions and reusable workflows for an organization
     * Sets the actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetAllowedActionsOrganization(
        org: string,
        requestBody?: selected_actions,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/selected-actions',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get self-hosted runners settings for an organization
     * Gets the settings for self-hosted runners for an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope or the "Actions policies" fine-grained permission to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns self_hosted_runners_settings Response
     * @throws ApiError
     */
    public static actionsGetSelfHostedRunnersPermissionsOrganization(
        org: string,
    ): CancelablePromise<self_hosted_runners_settings> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/permissions/self-hosted-runners',
            path: {
                'org': org,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set self-hosted runners settings for an organization
     * Sets the settings for self-hosted runners for an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope or the "Actions policies" fine-grained permission to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetSelfHostedRunnersPermissionsOrganization(
        org: string,
        requestBody: {
            /**
             * The policy that controls whether self-hosted runners can be used in the organization
             */
            enabled_repositories: 'all' | 'selected' | 'none';
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/self-hosted-runners',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List repositories allowed to use self-hosted runners in an organization
     * Lists repositories that are allowed to use self-hosted runners in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope or the "Actions policies" fine-grained permission to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListSelectedRepositoriesSelfHostedRunnersOrganization(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count?: number;
        repositories?: Array<repository>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/permissions/self-hosted-runners/repositories',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set repositories allowed to use self-hosted runners in an organization
     * Sets repositories that are allowed to use self-hosted runners in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope or the "Actions policies" fine-grained permission to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetSelectedRepositoriesSelfHostedRunnersOrganization(
        org: string,
        requestBody: {
            /**
             * IDs of repositories that can use repository-level self-hosted runners
             */
            selected_repository_ids: Array<number>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/self-hosted-runners/repositories',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Add a repository to the list of repositories allowed to use self-hosted runners in an organization
     * Adds a repository to the list of repositories that are allowed to use self-hosted runners in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope or the "Actions policies" fine-grained permission to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param repositoryId The unique identifier of the repository.
     * @returns void
     * @throws ApiError
     */
    public static actionsEnableSelectedRepositorySelfHostedRunnersOrganization(
        org: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/self-hosted-runners/repositories/{repository_id}',
            path: {
                'org': org,
                'repository_id': repositoryId,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove a repository from the list of repositories allowed to use self-hosted runners in an organization
     * Removes a repository from the list of repositories that are allowed to use self-hosted runners in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope or the "Actions policies" fine-grained permission to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param repositoryId The unique identifier of the repository.
     * @returns void
     * @throws ApiError
     */
    public static actionsDisableSelectedRepositorySelfHostedRunnersOrganization(
        org: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/permissions/self-hosted-runners/repositories/{repository_id}',
            path: {
                'org': org,
                'repository_id': repositoryId,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get default workflow permissions for an organization
     * Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization,
     * as well as whether GitHub Actions can submit approving pull request reviews. For more information, see
     * "[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_get_default_workflow_permissions Response
     * @throws ApiError
     */
    public static actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
        org: string,
    ): CancelablePromise<actions_get_default_workflow_permissions> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/permissions/workflow',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Set default workflow permissions for an organization
     * Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization, and sets if GitHub Actions
     * can submit approving pull request reviews. For more information, see
     * "[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
        org: string,
        requestBody?: actions_set_default_workflow_permissions,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/permissions/workflow',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List self-hosted runner groups for an organization
     * Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param visibleToRepository Only return runner groups that are allowed to be used by this repository.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListSelfHostedRunnerGroupsForOrg(
        org: string,
        perPage: number = 30,
        page: number = 1,
        visibleToRepository?: string,
    ): CancelablePromise<{
        total_count: number;
        runner_groups: Array<runner_groups_org>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/runner-groups',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'visible_to_repository': visibleToRepository,
            },
        });
    }
    /**
     * Create a self-hosted runner group for an organization
     * Creates a new self-hosted runner group for an organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns runner_groups_org Response
     * @throws ApiError
     */
    public static actionsCreateSelfHostedRunnerGroupForOrg(
        org: string,
        requestBody: {
            /**
             * Name of the runner group.
             */
            name: string;
            /**
             * Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories.
             */
            visibility?: 'selected' | 'all' | 'private';
            /**
             * List of repository IDs that can access the runner group.
             */
            selected_repository_ids?: Array<number>;
            /**
             * List of runner IDs to add to the runner group.
             */
            runners?: Array<number>;
            /**
             * Whether the runner group can be used by `public` repositories.
             */
            allows_public_repositories?: boolean;
            /**
             * If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
             */
            restricted_to_workflows?: boolean;
            /**
             * List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
             */
            selected_workflows?: Array<string>;
            /**
             * The identifier of a hosted compute network configuration.
             */
            network_configuration_id?: string;
        },
    ): CancelablePromise<runner_groups_org> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/actions/runner-groups',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get a self-hosted runner group for an organization
     * Gets a specific self-hosted runner group for an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @returns runner_groups_org Response
     * @throws ApiError
     */
    public static actionsGetSelfHostedRunnerGroupForOrg(
        org: string,
        runnerGroupId: number,
    ): CancelablePromise<runner_groups_org> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
            },
        });
    }
    /**
     * Update a self-hosted runner group for an organization
     * Updates the `name` and `visibility` of a self-hosted runner group in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param requestBody
     * @returns runner_groups_org Response
     * @throws ApiError
     */
    public static actionsUpdateSelfHostedRunnerGroupForOrg(
        org: string,
        runnerGroupId: number,
        requestBody: {
            /**
             * Name of the runner group.
             */
            name: string;
            /**
             * Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories.
             */
            visibility?: 'selected' | 'all' | 'private';
            /**
             * Whether the runner group can be used by `public` repositories.
             */
            allows_public_repositories?: boolean;
            /**
             * If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
             */
            restricted_to_workflows?: boolean;
            /**
             * List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
             */
            selected_workflows?: Array<string>;
            /**
             * The identifier of a hosted compute network configuration.
             */
            network_configuration_id?: string | null;
        },
    ): CancelablePromise<runner_groups_org> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a self-hosted runner group from an organization
     * Deletes a self-hosted runner group for an organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteSelfHostedRunnerGroupFromOrg(
        org: string,
        runnerGroupId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
            },
        });
    }
    /**
     * List GitHub-hosted runners in a group for an organization
     * Lists the GitHub-hosted runners in an organization group.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListGithubHostedRunnersInGroupForOrg(
        org: string,
        runnerGroupId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        runners: Array<actions_hosted_runner>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List repository access to a self-hosted runner group in an organization
     * Lists the repositories with access to a self-hosted runner group configured in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListRepoAccessToSelfHostedRunnerGroupInOrg(
        org: string,
        runnerGroupId: number,
        page: number = 1,
        perPage: number = 30,
    ): CancelablePromise<{
        total_count: number;
        repositories: Array<minimal_repository>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
            },
            query: {
                'page': page,
                'per_page': perPage,
            },
        });
    }
    /**
     * Set repository access for a self-hosted runner group in an organization
     * Replaces the list of repositories that have access to a self-hosted runner group configured in an organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
        org: string,
        runnerGroupId: number,
        requestBody: {
            /**
             * List of repository IDs that can access the runner group.
             */
            selected_repository_ids: Array<number>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Add repository access to a self-hosted runner group in an organization
     * Adds a repository to the list of repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param repositoryId The unique identifier of the repository.
     * @returns void
     * @throws ApiError
     */
    public static actionsAddRepoAccessToSelfHostedRunnerGroupInOrg(
        org: string,
        runnerGroupId: number,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
                'repository_id': repositoryId,
            },
        });
    }
    /**
     * Remove repository access to a self-hosted runner group in an organization
     * Removes a repository from the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param repositoryId The unique identifier of the repository.
     * @returns void
     * @throws ApiError
     */
    public static actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(
        org: string,
        runnerGroupId: number,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
                'repository_id': repositoryId,
            },
        });
    }
    /**
     * List self-hosted runners in a group for an organization
     * Lists self-hosted runners that are in a specific organization group.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListSelfHostedRunnersInGroupForOrg(
        org: string,
        runnerGroupId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        runners: Array<runner>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Set self-hosted runners in a group for an organization
     * Replaces the list of self-hosted runners that are part of an organization runner group.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetSelfHostedRunnersInGroupForOrg(
        org: string,
        runnerGroupId: number,
        requestBody: {
            /**
             * List of runner IDs to add to the runner group.
             */
            runners: Array<number>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Add a self-hosted runner to a group for an organization
     * Adds a self-hosted runner to a runner group configured in an organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns void
     * @throws ApiError
     */
    public static actionsAddSelfHostedRunnerToGroupForOrg(
        org: string,
        runnerGroupId: number,
        runnerId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
                'runner_id': runnerId,
            },
        });
    }
    /**
     * Remove a self-hosted runner from a group for an organization
     * Removes a self-hosted runner from a group configured in an organization. The runner is then returned to the default group.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerGroupId Unique identifier of the self-hosted runner group.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns void
     * @throws ApiError
     */
    public static actionsRemoveSelfHostedRunnerFromGroupForOrg(
        org: string,
        runnerGroupId: number,
        runnerId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}',
            path: {
                'org': org,
                'runner_group_id': runnerGroupId,
                'runner_id': runnerId,
            },
        });
    }
    /**
     * List self-hosted runners for an organization
     * Lists all self-hosted runners configured in an organization.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param name The name of a self-hosted runner.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListSelfHostedRunnersForOrg(
        org: string,
        name?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        runners: Array<runner>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/runners',
            path: {
                'org': org,
            },
            query: {
                'name': name,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List runner applications for an organization
     * Lists binaries for the runner application that you can download and run.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.  If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @returns runner_application Response
     * @throws ApiError
     */
    public static actionsListRunnerApplicationsForOrg(
        org: string,
    ): CancelablePromise<Array<runner_application>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/runners/downloads',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Create configuration for a just-in-time runner for an organization
     * Generates a configuration that can be passed to the runner application at startup.
     *
     * The authenticated user must have admin access to the organization.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static actionsGenerateRunnerJitconfigForOrg(
        org: string,
        requestBody: {
            /**
             * The name of the new runner.
             */
            name: string;
            /**
             * The ID of the runner group to register the runner to.
             */
            runner_group_id: number;
            /**
             * The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.
             */
            labels: Array<string>;
            /**
             * The working directory to be used for job execution, relative to the runner install directory.
             */
            work_folder?: string;
        },
    ): CancelablePromise<{
        runner: runner;
        /**
         * The base64 encoded runner configuration.
         */
        encoded_jit_config: string;
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/actions/runners/generate-jitconfig',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Create a registration token for an organization
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     *
     * For example, you can replace `TOKEN` in the following example with the registration token provided by this endpoint to configure your self-hosted runner:
     *
     * ```
     * ./config.sh --url https://github.com/octo-org --token TOKEN
     * ```
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns authentication_token Response
     * @throws ApiError
     */
    public static actionsCreateRegistrationTokenForOrg(
        org: string,
    ): CancelablePromise<authentication_token> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/actions/runners/registration-token',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Create a remove token for an organization
     * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an organization. The token expires after one hour.
     *
     * For example, you can replace `TOKEN` in the following example with the registration token provided by this endpoint to remove your self-hosted runner from an organization:
     *
     * ```
     * ./config.sh remove --token TOKEN
     * ```
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns authentication_token Response
     * @throws ApiError
     */
    public static actionsCreateRemoveTokenForOrg(
        org: string,
    ): CancelablePromise<authentication_token> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/actions/runners/remove-token',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Get a self-hosted runner for an organization
     * Gets a specific self-hosted runner configured in an organization.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns runner Response
     * @throws ApiError
     */
    public static actionsGetSelfHostedRunnerForOrg(
        org: string,
        runnerId: number,
    ): CancelablePromise<runner> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/runners/{runner_id}',
            path: {
                'org': org,
                'runner_id': runnerId,
            },
        });
    }
    /**
     * Delete a self-hosted runner from an organization
     * Forces the removal of a self-hosted runner from an organization. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteSelfHostedRunnerFromOrg(
        org: string,
        runnerId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/runners/{runner_id}',
            path: {
                'org': org,
                'runner_id': runnerId,
            },
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List labels for a self-hosted runner for an organization
     * Lists all labels for a self-hosted runner configured in an organization.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListLabelsForSelfHostedRunnerForOrg(
        org: string,
        runnerId: number,
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/runners/{runner_id}/labels',
            path: {
                'org': org,
                'runner_id': runnerId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Add custom labels to a self-hosted runner for an organization
     * Adds custom labels to a self-hosted runner configured in an organization.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static actionsAddCustomLabelsToSelfHostedRunnerForOrg(
        org: string,
        runnerId: number,
        requestBody: {
            /**
             * The names of the custom labels to add to the runner.
             */
            labels: Array<string>;
        },
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/actions/runners/{runner_id}/labels',
            path: {
                'org': org,
                'runner_id': runnerId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Set custom labels for a self-hosted runner for an organization
     * Remove all previous custom labels and set the new custom labels for a specific
     * self-hosted runner configured in an organization.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static actionsSetCustomLabelsForSelfHostedRunnerForOrg(
        org: string,
        runnerId: number,
        requestBody: {
            /**
             * The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.
             */
            labels: Array<string>;
        },
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/runners/{runner_id}/labels',
            path: {
                'org': org,
                'runner_id': runnerId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove all custom labels from a self-hosted runner for an organization
     * Remove all custom labels from a self-hosted runner configured in an
     * organization. Returns the remaining read-only labels from the runner.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
        org: string,
        runnerId: number,
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/runners/{runner_id}/labels',
            path: {
                'org': org,
                'runner_id': runnerId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Remove a custom label from a self-hosted runner for an organization
     * Remove a custom label from a self-hosted runner configured
     * in an organization. Returns the remaining labels from the runner.
     *
     * This endpoint returns a `404 Not Found` status if the custom label is not
     * present on the runner.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @param name The name of a self-hosted runner's custom label.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
        org: string,
        runnerId: number,
        name: string,
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/runners/{runner_id}/labels/{name}',
            path: {
                'org': org,
                'runner_id': runnerId,
                'name': name,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List organization secrets
     * Lists all secrets available in an organization without revealing their
     * encrypted values.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListOrgSecrets(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        secrets: Array<organization_actions_secret>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/secrets',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get an organization public key
     * Gets your public key, which you need to encrypt secrets. You need to
     * encrypt a secret before you can create or update secrets.
     *
     * The authenticated user must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns actions_public_key Response
     * @throws ApiError
     */
    public static actionsGetOrgPublicKey(
        org: string,
    ): CancelablePromise<actions_public_key> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/secrets/public-key',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Get an organization secret
     * Gets a single organization secret without revealing its encrypted value.
     *
     * The authenticated user must have collaborator access to a repository to create, update, or read secrets
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @returns organization_actions_secret Response
     * @throws ApiError
     */
    public static actionsGetOrgSecret(
        org: string,
        secretName: string,
    ): CancelablePromise<organization_actions_secret> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/secrets/{secret_name}',
            path: {
                'org': org,
                'secret_name': secretName,
            },
        });
    }
    /**
     * Create or update an organization secret
     * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @param requestBody
     * @returns empty_object Response when creating a secret
     * @throws ApiError
     */
    public static actionsCreateOrUpdateOrgSecret(
        org: string,
        secretName: string,
        requestBody: {
            /**
             * Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/actions/secrets#get-an-organization-public-key) endpoint.
             */
            encrypted_value: string;
            /**
             * ID of the key you used to encrypt the secret.
             */
            key_id: string;
            /**
             * Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
             */
            visibility: 'all' | 'private' | 'selected';
            /**
             * An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
             */
            selected_repository_ids?: Array<number>;
        },
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/secrets/{secret_name}',
            path: {
                'org': org,
                'secret_name': secretName,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete an organization secret
     * Deletes a secret in an organization using the secret name.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteOrgSecret(
        org: string,
        secretName: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/secrets/{secret_name}',
            path: {
                'org': org,
                'secret_name': secretName,
            },
        });
    }
    /**
     * List selected repositories for an organization secret
     * Lists all repositories that have been selected when the `visibility`
     * for repository access to a secret is set to `selected`.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListSelectedReposForOrgSecret(
        org: string,
        secretName: string,
        page: number = 1,
        perPage: number = 30,
    ): CancelablePromise<{
        total_count: number;
        repositories: Array<minimal_repository>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/secrets/{secret_name}/repositories',
            path: {
                'org': org,
                'secret_name': secretName,
            },
            query: {
                'page': page,
                'per_page': perPage,
            },
        });
    }
    /**
     * Set selected repositories for an organization secret
     * Replaces all repositories for an organization secret when the `visibility`
     * for repository access is set to `selected`. The visibility is set when you [Create
     * or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetSelectedReposForOrgSecret(
        org: string,
        secretName: string,
        requestBody: {
            /**
             * An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
             */
            selected_repository_ids: Array<number>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/secrets/{secret_name}/repositories',
            path: {
                'org': org,
                'secret_name': secretName,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Add selected repository to an organization secret
     * Adds a repository to an organization secret when the `visibility` for
     * repository access is set to `selected`. For more information about setting the visibility, see [Create or
     * update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @param repositoryId
     * @returns void
     * @throws ApiError
     */
    public static actionsAddSelectedRepoToOrgSecret(
        org: string,
        secretName: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}',
            path: {
                'org': org,
                'secret_name': secretName,
                'repository_id': repositoryId,
            },
            errors: {
                409: `Conflict when visibility type is not set to selected`,
            },
        });
    }
    /**
     * Remove selected repository from an organization secret
     * Removes a repository from an organization secret when the `visibility`
     * for repository access is set to `selected`. The visibility is set when you [Create
     * or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @param repositoryId
     * @returns void
     * @throws ApiError
     */
    public static actionsRemoveSelectedRepoFromOrgSecret(
        org: string,
        secretName: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}',
            path: {
                'org': org,
                'secret_name': secretName,
                'repository_id': repositoryId,
            },
            errors: {
                409: `Conflict when visibility type not set to selected`,
            },
        });
    }
    /**
     * List organization variables
     * Lists all organization variables.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListOrgVariables(
        org: string,
        perPage: number = 10,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        variables: Array<organization_actions_variable>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/variables',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create an organization variable
     * Creates an organization variable that you can reference in a GitHub Actions workflow.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns empty_object Response when creating a variable
     * @throws ApiError
     */
    public static actionsCreateOrgVariable(
        org: string,
        requestBody: {
            /**
             * The name of the variable.
             */
            name: string;
            /**
             * The value of the variable.
             */
            value: string;
            /**
             * The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.
             */
            visibility: 'all' | 'private' | 'selected';
            /**
             * An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.
             */
            selected_repository_ids?: Array<number>;
        },
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/actions/variables',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get an organization variable
     * Gets a specific variable in an organization.
     *
     * The authenticated user must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param name The name of the variable.
     * @returns organization_actions_variable Response
     * @throws ApiError
     */
    public static actionsGetOrgVariable(
        org: string,
        name: string,
    ): CancelablePromise<organization_actions_variable> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/variables/{name}',
            path: {
                'org': org,
                'name': name,
            },
        });
    }
    /**
     * Update an organization variable
     * Updates an organization variable that you can reference in a GitHub Actions workflow.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param name The name of the variable.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsUpdateOrgVariable(
        org: string,
        name: string,
        requestBody: {
            /**
             * The name of the variable.
             */
            name?: string;
            /**
             * The value of the variable.
             */
            value?: string;
            /**
             * The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.
             */
            visibility?: 'all' | 'private' | 'selected';
            /**
             * An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.
             */
            selected_repository_ids?: Array<number>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/orgs/{org}/actions/variables/{name}',
            path: {
                'org': org,
                'name': name,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete an organization variable
     * Deletes an organization variable using the variable name.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param name The name of the variable.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteOrgVariable(
        org: string,
        name: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/variables/{name}',
            path: {
                'org': org,
                'name': name,
            },
        });
    }
    /**
     * List selected repositories for an organization variable
     * Lists all repositories that can access an organization variable
     * that is available to selected repositories.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param name The name of the variable.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListSelectedReposForOrgVariable(
        org: string,
        name: string,
        page: number = 1,
        perPage: number = 30,
    ): CancelablePromise<{
        total_count: number;
        repositories: Array<minimal_repository>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/actions/variables/{name}/repositories',
            path: {
                'org': org,
                'name': name,
            },
            query: {
                'page': page,
                'per_page': perPage,
            },
            errors: {
                409: `Response when the visibility of the variable is not set to \`selected\``,
            },
        });
    }
    /**
     * Set selected repositories for an organization variable
     * Replaces all repositories for an organization variable that is available
     * to selected repositories. Organization variables that are available to selected
     * repositories have their `visibility` field set to `selected`.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param name The name of the variable.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetSelectedReposForOrgVariable(
        org: string,
        name: string,
        requestBody: {
            /**
             * The IDs of the repositories that can access the organization variable.
             */
            selected_repository_ids: Array<number>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/variables/{name}/repositories',
            path: {
                'org': org,
                'name': name,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                409: `Response when the visibility of the variable is not set to \`selected\``,
            },
        });
    }
    /**
     * Add selected repository to an organization variable
     * Adds a repository to an organization variable that is available to selected repositories.
     * Organization variables that are available to selected repositories have their `visibility` field set to `selected`.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param name The name of the variable.
     * @param repositoryId
     * @returns void
     * @throws ApiError
     */
    public static actionsAddSelectedRepoToOrgVariable(
        org: string,
        name: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/actions/variables/{name}/repositories/{repository_id}',
            path: {
                'org': org,
                'name': name,
                'repository_id': repositoryId,
            },
            errors: {
                409: `Response when the visibility of the variable is not set to \`selected\``,
            },
        });
    }
    /**
     * Remove selected repository from an organization variable
     * Removes a repository from an organization variable that is
     * available to selected repositories. Organization variables that are available to
     * selected repositories have their `visibility` field set to `selected`.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.
     * @param org The organization name. The name is not case sensitive.
     * @param name The name of the variable.
     * @param repositoryId
     * @returns void
     * @throws ApiError
     */
    public static actionsRemoveSelectedRepoFromOrgVariable(
        org: string,
        name: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/actions/variables/{name}/repositories/{repository_id}',
            path: {
                'org': org,
                'name': name,
                'repository_id': repositoryId,
            },
            errors: {
                409: `Response when the visibility of the variable is not set to \`selected\``,
            },
        });
    }
    /**
     * List artifacts for a repository
     * Lists all artifacts for a repository.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param name The name field of an artifact. When specified, only artifacts with this name will be returned.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListArtifactsForRepo(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
        name?: string,
    ): CancelablePromise<{
        total_count: number;
        artifacts: Array<artifact>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/artifacts',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'name': name,
            },
        });
    }
    /**
     * Get an artifact
     * Gets a specific artifact for a workflow run.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param artifactId The unique identifier of the artifact.
     * @returns artifact Response
     * @throws ApiError
     */
    public static actionsGetArtifact(
        owner: string,
        repo: string,
        artifactId: number,
    ): CancelablePromise<artifact> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'artifact_id': artifactId,
            },
        });
    }
    /**
     * Delete an artifact
     * Deletes an artifact for a workflow run.
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param artifactId The unique identifier of the artifact.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteArtifact(
        owner: string,
        repo: string,
        artifactId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'artifact_id': artifactId,
            },
        });
    }
    /**
     * Download an artifact
     * Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look for `Location:` in
     * the response header to find the URL for the download. The `:archive_format` must be `zip`.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param artifactId The unique identifier of the artifact.
     * @param archiveFormat
     * @returns void
     * @throws ApiError
     */
    public static actionsDownloadArtifact(
        owner: string,
        repo: string,
        artifactId: number,
        archiveFormat: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}',
            path: {
                'owner': owner,
                'repo': repo,
                'artifact_id': artifactId,
                'archive_format': archiveFormat,
            },
            errors: {
                302: `Response`,
                410: `Gone`,
            },
        });
    }
    /**
     * Get GitHub Actions cache retention limit for a repository
     * Gets GitHub Actions cache retention limit for a repository. This determines how long caches will be retained for, if
     * not manually removed or evicted due to size constraints.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:repository` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_cache_retention_limit_for_repository Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheRetentionLimitForRepository(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_cache_retention_limit_for_repository> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/cache/retention-limit',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set GitHub Actions cache retention limit for a repository
     * Sets GitHub Actions cache retention limit for a repository. This determines how long caches will be retained for, if
     * not manually removed or evicted due to size constraints.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:repository` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetActionsCacheRetentionLimitForRepository(
        owner: string,
        repo: string,
        requestBody: actions_cache_retention_limit_for_repository,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/cache/retention-limit',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get GitHub Actions cache storage limit for a repository
     * Gets GitHub Actions cache storage limit for a repository. This determines the maximum size of caches that can be
     * stored before eviction occurs.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:repository` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_cache_storage_limit_for_repository Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheStorageLimitForRepository(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_cache_storage_limit_for_repository> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/cache/storage-limit',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set GitHub Actions cache storage limit for a repository
     * Sets GitHub Actions cache storage limit for a repository. This determines the maximum size of caches that can be
     * stored before eviction occurs.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:repository` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetActionsCacheStorageLimitForRepository(
        owner: string,
        repo: string,
        requestBody: actions_cache_storage_limit_for_repository,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/cache/storage-limit',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get GitHub Actions cache usage for a repository
     * Gets GitHub Actions cache usage for a repository.
     * The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_cache_usage_by_repository Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheUsage(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_cache_usage_by_repository> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/cache/usage',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * List GitHub Actions caches for a repository
     * Lists the GitHub Actions caches for a repository.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param ref The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
     * @param key An explicit key or prefix for identifying the cache
     * @param sort The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes.
     * @param direction The direction to sort the results by.
     * @returns actions_cache_list Response
     * @throws ApiError
     */
    public static actionsGetActionsCacheList(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
        ref?: string,
        key?: string,
        sort: 'created_at' | 'last_accessed_at' | 'size_in_bytes' = 'last_accessed_at',
        direction: 'asc' | 'desc' = 'desc',
    ): CancelablePromise<actions_cache_list> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/caches',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'ref': ref,
                'key': key,
                'sort': sort,
                'direction': direction,
            },
        });
    }
    /**
     * Delete GitHub Actions caches for a repository (using a cache key)
     * Deletes one or more GitHub Actions caches for a repository, using a complete cache key. By default, all caches that match the provided key are deleted, but you can optionally provide a Git ref to restrict deletions to caches that match both the provided key and the Git ref.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param key A key for identifying the cache.
     * @param ref The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
     * @returns actions_cache_list Response
     * @throws ApiError
     */
    public static actionsDeleteActionsCacheByKey(
        owner: string,
        repo: string,
        key: string,
        ref?: string,
    ): CancelablePromise<actions_cache_list> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/caches',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'key': key,
                'ref': ref,
            },
        });
    }
    /**
     * Delete a GitHub Actions cache for a repository (using a cache ID)
     * Deletes a GitHub Actions cache for a repository, using a cache ID.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param cacheId The unique identifier of the GitHub Actions cache.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteActionsCacheById(
        owner: string,
        repo: string,
        cacheId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/caches/{cache_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'cache_id': cacheId,
            },
        });
    }
    /**
     * Get a job for a workflow run
     * Gets a specific job in a workflow run.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param jobId The unique identifier of the job.
     * @returns job Response
     * @throws ApiError
     */
    public static actionsGetJobForWorkflowRun(
        owner: string,
        repo: string,
        jobId: number,
    ): CancelablePromise<job> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/jobs/{job_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'job_id': jobId,
            },
        });
    }
    /**
     * Download job logs for a workflow run
     * Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires after 1 minute. Look
     * for `Location:` in the response header to find the URL for the download.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param jobId The unique identifier of the job.
     * @returns void
     * @throws ApiError
     */
    public static actionsDownloadJobLogsForWorkflowRun(
        owner: string,
        repo: string,
        jobId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/jobs/{job_id}/logs',
            path: {
                'owner': owner,
                'repo': repo,
                'job_id': jobId,
            },
            errors: {
                302: `Response`,
            },
        });
    }
    /**
     * Re-run a job from a workflow run
     * Re-run a job and its dependent jobs in a workflow run.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param jobId The unique identifier of the job.
     * @param requestBody
     * @returns empty_object Response
     * @throws ApiError
     */
    public static actionsReRunJobForWorkflowRun(
        owner: string,
        repo: string,
        jobId: number,
        requestBody?: {
            /**
             * Whether to enable debug logging for the re-run.
             */
            enable_debug_logging?: boolean;
        } | null,
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/jobs/{job_id}/rerun',
            path: {
                'owner': owner,
                'repo': repo,
                'job_id': jobId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
            },
        });
    }
    /**
     * Get the customization template for an OIDC subject claim for a repository
     * Gets the customization template for an OpenID Connect (OIDC) subject claim.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns oidc_custom_sub_repo Status response
     * @throws ApiError
     */
    public static actionsGetCustomOidcSubClaimForRepo(
        owner: string,
        repo: string,
    ): CancelablePromise<oidc_custom_sub_repo> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/oidc/customization/sub',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                400: `Bad Request`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set the customization template for an OIDC subject claim for a repository
     * Sets the customization template and `opt-in` or `opt-out` flag for an OpenID Connect (OIDC) subject claim for a repository.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns empty_object Empty response
     * @throws ApiError
     */
    public static actionsSetCustomOidcSubClaimForRepo(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.
             */
            use_default: boolean;
            /**
             * Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.
             */
            include_claim_keys?: Array<string>;
        },
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/oidc/customization/sub',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List repository organization secrets
     * Lists all organization secrets shared with a repository without revealing their encrypted
     * values.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListRepoOrganizationSecrets(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        secrets: Array<actions_secret>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/organization-secrets',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List repository organization variables
     * Lists all organization variables shared with a repository.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListRepoOrganizationVariables(
        owner: string,
        repo: string,
        perPage: number = 10,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        variables: Array<actions_variable>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/organization-variables',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get GitHub Actions permissions for a repository
     * Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is enabled and the actions and reusable workflows allowed to run in the repository.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_repository_permissions Response
     * @throws ApiError
     */
    public static actionsGetGithubActionsPermissionsRepository(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_repository_permissions> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/permissions',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Set GitHub Actions permissions for a repository
     * Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions and reusable workflows in the repository.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetGithubActionsPermissionsRepository(
        owner: string,
        repo: string,
        requestBody: {
            enabled: actions_enabled;
            allowed_actions?: allowed_actions;
            sha_pinning_required?: sha_pinning_required;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/permissions',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get the level of access for workflows outside of the repository
     * Gets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
     * This endpoint only applies to private repositories.
     * For more information, see "[Allowing access to components in a private repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_workflow_access_to_repository Response
     * @throws ApiError
     */
    public static actionsGetWorkflowAccessToRepository(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_workflow_access_to_repository> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/permissions/access',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Set the level of access for workflows outside of the repository
     * Sets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
     * This endpoint only applies to private repositories.
     * For more information, see "[Allowing access to components in a private repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)".
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetWorkflowAccessToRepository(
        owner: string,
        repo: string,
        requestBody: actions_workflow_access_to_repository,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/permissions/access',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get artifact and log retention settings for a repository
     * Gets artifact and log retention settings for a repository.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_artifact_and_log_retention_response Response
     * @throws ApiError
     */
    public static actionsGetArtifactAndLogRetentionSettingsRepository(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_artifact_and_log_retention_response> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/permissions/artifact-and-log-retention',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set artifact and log retention settings for a repository
     * Sets artifact and log retention settings for a repository.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetArtifactAndLogRetentionSettingsRepository(
        owner: string,
        repo: string,
        requestBody: actions_artifact_and_log_retention,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/permissions/artifact-and-log-retention',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get fork PR contributor approval permissions for a repository
     * Gets the fork PR contributor approval policy for a repository.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_fork_pr_contributor_approval Response
     * @throws ApiError
     */
    public static actionsGetForkPrContributorApprovalPermissionsRepository(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_fork_pr_contributor_approval> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/permissions/fork-pr-contributor-approval',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set fork PR contributor approval permissions for a repository
     * Sets the fork PR contributor approval policy for a repository.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetForkPrContributorApprovalPermissionsRepository(
        owner: string,
        repo: string,
        requestBody: actions_fork_pr_contributor_approval,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/permissions/fork-pr-contributor-approval',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get private repo fork PR workflow settings for a repository
     * Gets the settings for whether workflows from fork pull requests can run on a private repository.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_fork_pr_workflows_private_repos Response
     * @throws ApiError
     */
    public static actionsGetPrivateRepoForkPrWorkflowsSettingsRepository(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_fork_pr_workflows_private_repos> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/permissions/fork-pr-workflows-private-repos',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set private repo fork PR workflow settings for a repository
     * Sets the settings for whether workflows from fork pull requests can run on a private repository.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetPrivateRepoForkPrWorkflowsSettingsRepository(
        owner: string,
        repo: string,
        requestBody: actions_fork_pr_workflows_private_repos_request,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/permissions/fork-pr-workflows-private-repos',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get allowed actions and reusable workflows for a repository
     * Gets the settings for selected actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns selected_actions Response
     * @throws ApiError
     */
    public static actionsGetAllowedActionsRepository(
        owner: string,
        repo: string,
    ): CancelablePromise<selected_actions> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/permissions/selected-actions',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Set allowed actions and reusable workflows for a repository
     * Sets the actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetAllowedActionsRepository(
        owner: string,
        repo: string,
        requestBody?: selected_actions,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/permissions/selected-actions',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get default workflow permissions for a repository
     * Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository,
     * as well as if GitHub Actions can submit approving pull request reviews.
     * For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_get_default_workflow_permissions Response
     * @throws ApiError
     */
    public static actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_get_default_workflow_permissions> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/permissions/workflow',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Set default workflow permissions for a repository
     * Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository, and sets if GitHub Actions
     * can submit approving pull request reviews.
     * For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
        owner: string,
        repo: string,
        requestBody: actions_set_default_workflow_permissions,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/permissions/workflow',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                409: `Conflict response when changing a setting is prevented by the owning organization`,
            },
        });
    }
    /**
     * List self-hosted runners for a repository
     * Lists all self-hosted runners configured in a repository.
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param name The name of a self-hosted runner.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListSelfHostedRunnersForRepo(
        owner: string,
        repo: string,
        name?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        runners: Array<runner>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runners',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'name': name,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List runner applications for a repository
     * Lists binaries for the runner application that you can download and run.
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns runner_application Response
     * @throws ApiError
     */
    public static actionsListRunnerApplicationsForRepo(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<runner_application>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runners/downloads',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Create configuration for a just-in-time runner for a repository
     * Generates a configuration that can be passed to the runner application at startup.
     *
     * The authenticated user must have admin access to the repository.
     *
     * OAuth tokens and personal access tokens (classic) need the`repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static actionsGenerateRunnerJitconfigForRepo(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The name of the new runner.
             */
            name: string;
            /**
             * The ID of the runner group to register the runner to.
             */
            runner_group_id: number;
            /**
             * The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.
             */
            labels: Array<string>;
            /**
             * The working directory to be used for job execution, relative to the runner install directory.
             */
            work_folder?: string;
        },
    ): CancelablePromise<{
        runner: runner;
        /**
         * The base64 encoded runner configuration.
         */
        encoded_jit_config: string;
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runners/generate-jitconfig',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Create a registration token for a repository
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     *
     * For example, you can replace `TOKEN` in the following example with the registration token provided by this endpoint to configure your self-hosted runner:
     *
     * ```
     * ./config.sh --url https://github.com/octo-org --token TOKEN
     * ```
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns authentication_token Response
     * @throws ApiError
     */
    public static actionsCreateRegistrationTokenForRepo(
        owner: string,
        repo: string,
    ): CancelablePromise<authentication_token> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runners/registration-token',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Create a remove token for a repository
     * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an repository. The token expires after one hour.
     *
     * For example, you can replace `TOKEN` in the following example with the registration token provided by this endpoint to remove your self-hosted runner from an organization:
     *
     * ```
     * ./config.sh remove --token TOKEN
     * ```
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns authentication_token Response
     * @throws ApiError
     */
    public static actionsCreateRemoveTokenForRepo(
        owner: string,
        repo: string,
    ): CancelablePromise<authentication_token> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runners/remove-token',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Get a self-hosted runner for a repository
     * Gets a specific self-hosted runner configured in a repository.
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns runner Response
     * @throws ApiError
     */
    public static actionsGetSelfHostedRunnerForRepo(
        owner: string,
        repo: string,
        runnerId: number,
    ): CancelablePromise<runner> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runners/{runner_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'runner_id': runnerId,
            },
        });
    }
    /**
     * Delete a self-hosted runner from a repository
     * Forces the removal of a self-hosted runner from a repository. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteSelfHostedRunnerFromRepo(
        owner: string,
        repo: string,
        runnerId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/runners/{runner_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'runner_id': runnerId,
            },
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List labels for a self-hosted runner for a repository
     * Lists all labels for a self-hosted runner configured in a repository.
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListLabelsForSelfHostedRunnerForRepo(
        owner: string,
        repo: string,
        runnerId: number,
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels',
            path: {
                'owner': owner,
                'repo': repo,
                'runner_id': runnerId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Add custom labels to a self-hosted runner for a repository
     * Adds custom labels to a self-hosted runner configured in a repository.
     *
     * Authenticated users must have admin access to the organization to use this endpoint.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static actionsAddCustomLabelsToSelfHostedRunnerForRepo(
        owner: string,
        repo: string,
        runnerId: number,
        requestBody: {
            /**
             * The names of the custom labels to add to the runner.
             */
            labels: Array<string>;
        },
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels',
            path: {
                'owner': owner,
                'repo': repo,
                'runner_id': runnerId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Set custom labels for a self-hosted runner for a repository
     * Remove all previous custom labels and set the new custom labels for a specific
     * self-hosted runner configured in a repository.
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static actionsSetCustomLabelsForSelfHostedRunnerForRepo(
        owner: string,
        repo: string,
        runnerId: number,
        requestBody: {
            /**
             * The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.
             */
            labels: Array<string>;
        },
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels',
            path: {
                'owner': owner,
                'repo': repo,
                'runner_id': runnerId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove all custom labels from a self-hosted runner for a repository
     * Remove all custom labels from a self-hosted runner configured in a
     * repository. Returns the remaining read-only labels from the runner.
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
        owner: string,
        repo: string,
        runnerId: number,
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels',
            path: {
                'owner': owner,
                'repo': repo,
                'runner_id': runnerId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Remove a custom label from a self-hosted runner for a repository
     * Remove a custom label from a self-hosted runner configured
     * in a repository. Returns the remaining labels from the runner.
     *
     * This endpoint returns a `404 Not Found` status if the custom label is not
     * present on the runner.
     *
     * Authenticated users must have admin access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runnerId Unique identifier of the self-hosted runner.
     * @param name The name of a self-hosted runner's custom label.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
        owner: string,
        repo: string,
        runnerId: number,
        name: string,
    ): CancelablePromise<{
        total_count: number;
        labels: Array<runner_label>;
    }> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'runner_id': runnerId,
                'name': name,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List workflow runs for a repository
     * Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     *
     * This endpoint will return up to 1,000 results for each search when using the following parameters: `actor`, `branch`, `check_suite_id`, `created`, `event`, `head_sha`, `status`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param actor Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.
     * @param branch Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
     * @param event Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
     * @param status Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param created Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
     * @param excludePullRequests If `true` pull requests are omitted from the response (empty array).
     * @param checkSuiteId Returns workflow runs with the `check_suite_id` that you specify.
     * @param headSha Only returns workflow runs that are associated with the specified `head_sha`.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListWorkflowRunsForRepo(
        owner: string,
        repo: string,
        actor?: string,
        branch?: string,
        event?: string,
        status?: 'completed' | 'action_required' | 'cancelled' | 'failure' | 'neutral' | 'skipped' | 'stale' | 'success' | 'timed_out' | 'in_progress' | 'queued' | 'requested' | 'waiting' | 'pending',
        perPage: number = 30,
        page: number = 1,
        created?: string,
        excludePullRequests: boolean = false,
        checkSuiteId?: number,
        headSha?: string,
    ): CancelablePromise<{
        total_count: number;
        workflow_runs: Array<workflow_run>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'actor': actor,
                'branch': branch,
                'event': event,
                'status': status,
                'per_page': perPage,
                'page': page,
                'created': created,
                'exclude_pull_requests': excludePullRequests,
                'check_suite_id': checkSuiteId,
                'head_sha': headSha,
            },
        });
    }
    /**
     * Get a workflow run
     * Gets a specific workflow run.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param excludePullRequests If `true` pull requests are omitted from the response (empty array).
     * @returns workflow_run Response
     * @throws ApiError
     */
    public static actionsGetWorkflowRun(
        owner: string,
        repo: string,
        runId: number,
        excludePullRequests: boolean = false,
    ): CancelablePromise<workflow_run> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            query: {
                'exclude_pull_requests': excludePullRequests,
            },
        });
    }
    /**
     * Delete a workflow run
     * Deletes a specific workflow run.
     *
     * Anyone with write access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteWorkflowRun(
        owner: string,
        repo: string,
        runId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
        });
    }
    /**
     * Get the review history for a workflow run
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @returns environment_approvals Response
     * @throws ApiError
     */
    public static actionsGetReviewsForRun(
        owner: string,
        repo: string,
        runId: number,
    ): CancelablePromise<Array<environment_approvals>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/approvals',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
        });
    }
    /**
     * Approve a workflow run for a fork pull request
     * Approves a workflow run for a pull request from a public fork of a first time contributor. For more information, see ["Approving workflow runs from public forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @returns empty_object Response
     * @throws ApiError
     */
    public static actionsApproveWorkflowRun(
        owner: string,
        repo: string,
        runId: number,
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/approve',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List workflow run artifacts
     * Lists artifacts for a workflow run.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param name The name field of an artifact. When specified, only artifacts with this name will be returned.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListWorkflowRunArtifacts(
        owner: string,
        repo: string,
        runId: number,
        perPage: number = 30,
        page: number = 1,
        name?: string,
    ): CancelablePromise<{
        total_count: number;
        artifacts: Array<artifact>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'name': name,
            },
        });
    }
    /**
     * Get a workflow run attempt
     * Gets a specific workflow run attempt.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param attemptNumber The attempt number of the workflow run.
     * @param excludePullRequests If `true` pull requests are omitted from the response (empty array).
     * @returns workflow_run Response
     * @throws ApiError
     */
    public static actionsGetWorkflowRunAttempt(
        owner: string,
        repo: string,
        runId: number,
        attemptNumber: number,
        excludePullRequests: boolean = false,
    ): CancelablePromise<workflow_run> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
                'attempt_number': attemptNumber,
            },
            query: {
                'exclude_pull_requests': excludePullRequests,
            },
        });
    }
    /**
     * List jobs for a workflow run attempt
     * Lists jobs for a specific workflow run attempt. You can use parameters to narrow the list of results. For more information
     * about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint  with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param attemptNumber The attempt number of the workflow run.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListJobsForWorkflowRunAttempt(
        owner: string,
        repo: string,
        runId: number,
        attemptNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        jobs: Array<job>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
                'attempt_number': attemptNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Download workflow run attempt logs
     * Gets a redirect URL to download an archive of log files for a specific workflow run attempt. This link expires after
     * 1 minute. Look for `Location:` in the response header to find the URL for the download.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param attemptNumber The attempt number of the workflow run.
     * @returns void
     * @throws ApiError
     */
    public static actionsDownloadWorkflowRunAttemptLogs(
        owner: string,
        repo: string,
        runId: number,
        attemptNumber: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
                'attempt_number': attemptNumber,
            },
            errors: {
                302: `Response`,
            },
        });
    }
    /**
     * Cancel a workflow run
     * Cancels a workflow run using its `id`.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @returns empty_object Response
     * @throws ApiError
     */
    public static actionsCancelWorkflowRun(
        owner: string,
        repo: string,
        runId: number,
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/cancel',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            errors: {
                409: `Conflict`,
            },
        });
    }
    /**
     * Review custom deployment protection rules for a workflow run
     * Approve or reject custom deployment protection rules provided by a GitHub App for a workflow run. For more information, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
     *
     * > [!NOTE]
     * > GitHub Apps can only review their own custom deployment protection rules. To approve or reject pending deployments that are waiting for review from a specific person or team, see [`POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments`](/rest/actions/workflow-runs#review-pending-deployments-for-a-workflow-run).
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsReviewCustomGatesForRun(
        owner: string,
        repo: string,
        runId: number,
        requestBody: (review_custom_gates_comment_required | review_custom_gates_state_required),
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Force cancel a workflow run
     * Cancels a workflow run and bypasses conditions that would otherwise cause a workflow execution to continue, such as an `always()` condition on a job.
     * You should only use this endpoint to cancel a workflow run when the workflow run is not responding to [`POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel`](/rest/actions/workflow-runs#cancel-a-workflow-run).
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @returns empty_object Response
     * @throws ApiError
     */
    public static actionsForceCancelWorkflowRun(
        owner: string,
        repo: string,
        runId: number,
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            errors: {
                409: `Conflict`,
            },
        });
    }
    /**
     * List jobs for a workflow run
     * Lists jobs for a workflow run. You can use parameters to narrow the list of results. For more information
     * about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param filter Filters jobs by their `completed_at` timestamp. `latest` returns jobs from the most recent execution of the workflow run. `all` returns all jobs for a workflow run, including from old executions of the workflow run.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListJobsForWorkflowRun(
        owner: string,
        repo: string,
        runId: number,
        filter: 'latest' | 'all' = 'latest',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        jobs: Array<job>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/jobs',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            query: {
                'filter': filter,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Download workflow run logs
     * Gets a redirect URL to download an archive of log files for a workflow run. This link expires after 1 minute. Look for
     * `Location:` in the response header to find the URL for the download.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @returns void
     * @throws ApiError
     */
    public static actionsDownloadWorkflowRunLogs(
        owner: string,
        repo: string,
        runId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/logs',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            errors: {
                302: `Response`,
            },
        });
    }
    /**
     * Delete workflow run logs
     * Deletes all logs for a workflow run.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteWorkflowRunLogs(
        owner: string,
        repo: string,
        runId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/logs',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            errors: {
                403: `Forbidden`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get pending deployments for a workflow run
     * Get all deployment environments for a workflow run that are waiting for protection rules to pass.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @returns pending_deployment Response
     * @throws ApiError
     */
    public static actionsGetPendingDeploymentsForRun(
        owner: string,
        repo: string,
        runId: number,
    ): CancelablePromise<Array<pending_deployment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
        });
    }
    /**
     * Review pending deployments for a workflow run
     * Approve or reject pending deployments that are waiting on approval by a required reviewer.
     *
     * Required reviewers with read access to the repository contents and deployments can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param requestBody
     * @returns deployment Response
     * @throws ApiError
     */
    public static actionsReviewPendingDeploymentsForRun(
        owner: string,
        repo: string,
        runId: number,
        requestBody: {
            /**
             * The list of environment ids to approve or reject
             */
            environment_ids: Array<number>;
            /**
             * Whether to approve or reject deployment to the specified environments.
             */
            state: 'approved' | 'rejected';
            /**
             * A comment to accompany the deployment review
             */
            comment: string;
        },
    ): CancelablePromise<Array<deployment>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Re-run a workflow
     * Re-runs your workflow run using its `id`.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param requestBody
     * @returns empty_object Response
     * @throws ApiError
     */
    public static actionsReRunWorkflow(
        owner: string,
        repo: string,
        runId: number,
        requestBody?: {
            /**
             * Whether to enable debug logging for the re-run.
             */
            enable_debug_logging?: boolean;
        } | null,
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/rerun',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Re-run failed jobs from a workflow run
     * Re-run all of the failed jobs and their dependent jobs in a workflow run using the `id` of the workflow run.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @param requestBody
     * @returns empty_object Response
     * @throws ApiError
     */
    public static actionsReRunWorkflowFailedJobs(
        owner: string,
        repo: string,
        runId: number,
        requestBody?: {
            /**
             * Whether to enable debug logging for the re-run.
             */
            enable_debug_logging?: boolean;
        } | null,
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get workflow run usage
     * > [!WARNING]
     * > This endpoint is in the process of closing down. Refer to "[Actions Get workflow usage and Get workflow run usage endpoints closing down](https://github.blog/changelog/2025-02-02-actions-get-workflow-usage-and-get-workflow-run-usage-endpoints-closing-down/)" for more information.
     *
     * Gets the number of billable minutes and total run time for a specific workflow run. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param runId The unique identifier of the workflow run.
     * @returns workflow_run_usage Response
     * @throws ApiError
     */
    public static actionsGetWorkflowRunUsage(
        owner: string,
        repo: string,
        runId: number,
    ): CancelablePromise<workflow_run_usage> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/runs/{run_id}/timing',
            path: {
                'owner': owner,
                'repo': repo,
                'run_id': runId,
            },
        });
    }
    /**
     * List repository secrets
     * Lists all secrets available in a repository without revealing their encrypted
     * values.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListRepoSecrets(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        secrets: Array<actions_secret>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/secrets',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get a repository public key
     * Gets your public key, which you need to encrypt secrets. You need to
     * encrypt a secret before you can create or update secrets.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns actions_public_key Response
     * @throws ApiError
     */
    public static actionsGetRepoPublicKey(
        owner: string,
        repo: string,
    ): CancelablePromise<actions_public_key> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/secrets/public-key',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Get a repository secret
     * Gets a single repository secret without revealing its encrypted value.
     *
     * The authenticated user must have collaborator access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @returns actions_secret Response
     * @throws ApiError
     */
    public static actionsGetRepoSecret(
        owner: string,
        repo: string,
        secretName: string,
    ): CancelablePromise<actions_secret> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/secrets/{secret_name}',
            path: {
                'owner': owner,
                'repo': repo,
                'secret_name': secretName,
            },
        });
    }
    /**
     * Create or update a repository secret
     * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @param requestBody
     * @returns empty_object Response when creating a secret
     * @throws ApiError
     */
    public static actionsCreateOrUpdateRepoSecret(
        owner: string,
        repo: string,
        secretName: string,
        requestBody: {
            /**
             * Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/actions/secrets#get-a-repository-public-key) endpoint.
             */
            encrypted_value: string;
            /**
             * ID of the key you used to encrypt the secret.
             */
            key_id: string;
        },
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/secrets/{secret_name}',
            path: {
                'owner': owner,
                'repo': repo,
                'secret_name': secretName,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a repository secret
     * Deletes a secret in a repository using the secret name.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param secretName The name of the secret.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteRepoSecret(
        owner: string,
        repo: string,
        secretName: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/secrets/{secret_name}',
            path: {
                'owner': owner,
                'repo': repo,
                'secret_name': secretName,
            },
        });
    }
    /**
     * List repository variables
     * Lists all repository variables.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListRepoVariables(
        owner: string,
        repo: string,
        perPage: number = 10,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        variables: Array<actions_variable>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/variables',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create a repository variable
     * Creates a repository variable that you can reference in a GitHub Actions workflow.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns empty_object Response
     * @throws ApiError
     */
    public static actionsCreateRepoVariable(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The name of the variable.
             */
            name: string;
            /**
             * The value of the variable.
             */
            value: string;
        },
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/variables',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get a repository variable
     * Gets a specific variable in a repository.
     *
     * The authenticated user must have collaborator access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param name The name of the variable.
     * @returns actions_variable Response
     * @throws ApiError
     */
    public static actionsGetRepoVariable(
        owner: string,
        repo: string,
        name: string,
    ): CancelablePromise<actions_variable> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/variables/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'name': name,
            },
        });
    }
    /**
     * Update a repository variable
     * Updates a repository variable that you can reference in a GitHub Actions workflow.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param name The name of the variable.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsUpdateRepoVariable(
        owner: string,
        repo: string,
        name: string,
        requestBody: {
            /**
             * The name of the variable.
             */
            name?: string;
            /**
             * The value of the variable.
             */
            value?: string;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/actions/variables/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'name': name,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a repository variable
     * Deletes a repository variable using the variable name.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param name The name of the variable.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteRepoVariable(
        owner: string,
        repo: string,
        name: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/actions/variables/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'name': name,
            },
        });
    }
    /**
     * List repository workflows
     * Lists the workflows in a repository.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListRepoWorkflows(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        workflows: Array<workflow>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/workflows',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get a workflow
     * Gets a specific workflow. You can replace `workflow_id` with the workflow
     * file name. For example, you could use `main.yaml`.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
     * @returns workflow Response
     * @throws ApiError
     */
    public static actionsGetWorkflow(
        owner: string,
        repo: string,
        workflowId: (number | string),
    ): CancelablePromise<workflow> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'workflow_id': workflowId,
            },
        });
    }
    /**
     * Disable a workflow
     * Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
     * @returns void
     * @throws ApiError
     */
    public static actionsDisableWorkflow(
        owner: string,
        repo: string,
        workflowId: (number | string),
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable',
            path: {
                'owner': owner,
                'repo': repo,
                'workflow_id': workflowId,
            },
        });
    }
    /**
     * Create a workflow dispatch event
     * You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
     *
     * You must configure your GitHub Actions workflow to run when the [`workflow_dispatch` webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event occurs. The `inputs` are configured in the workflow file. For more information about how to configure the `workflow_dispatch` event in the workflow file, see "[Events that trigger workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)."
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsCreateWorkflowDispatch(
        owner: string,
        repo: string,
        workflowId: (number | string),
        requestBody: {
            /**
             * The git reference for the workflow. The reference can be a branch or tag name.
             */
            ref: string;
            /**
             * Input keys and values configured in the workflow file. The maximum number of properties is 25. Any default properties configured in the workflow file will be used when `inputs` are omitted.
             */
            inputs?: Record<string, any>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches',
            path: {
                'owner': owner,
                'repo': repo,
                'workflow_id': workflowId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Enable a workflow
     * Enables a workflow and sets the `state` of the workflow to `active`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
     * @returns void
     * @throws ApiError
     */
    public static actionsEnableWorkflow(
        owner: string,
        repo: string,
        workflowId: (number | string),
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable',
            path: {
                'owner': owner,
                'repo': repo,
                'workflow_id': workflowId,
            },
        });
    }
    /**
     * List workflow runs for a workflow
     * List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).
     *
     * Anyone with read access to the repository can use this endpoint
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     *
     * This endpoint will return up to 1,000 results for each search when using the following parameters: `actor`, `branch`, `check_suite_id`, `created`, `event`, `head_sha`, `status`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
     * @param actor Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.
     * @param branch Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
     * @param event Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
     * @param status Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param created Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
     * @param excludePullRequests If `true` pull requests are omitted from the response (empty array).
     * @param checkSuiteId Returns workflow runs with the `check_suite_id` that you specify.
     * @param headSha Only returns workflow runs that are associated with the specified `head_sha`.
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListWorkflowRuns(
        owner: string,
        repo: string,
        workflowId: (number | string),
        actor?: string,
        branch?: string,
        event?: string,
        status?: 'completed' | 'action_required' | 'cancelled' | 'failure' | 'neutral' | 'skipped' | 'stale' | 'success' | 'timed_out' | 'in_progress' | 'queued' | 'requested' | 'waiting' | 'pending',
        perPage: number = 30,
        page: number = 1,
        created?: string,
        excludePullRequests: boolean = false,
        checkSuiteId?: number,
        headSha?: string,
    ): CancelablePromise<{
        total_count: number;
        workflow_runs: Array<workflow_run>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs',
            path: {
                'owner': owner,
                'repo': repo,
                'workflow_id': workflowId,
            },
            query: {
                'actor': actor,
                'branch': branch,
                'event': event,
                'status': status,
                'per_page': perPage,
                'page': page,
                'created': created,
                'exclude_pull_requests': excludePullRequests,
                'check_suite_id': checkSuiteId,
                'head_sha': headSha,
            },
        });
    }
    /**
     * Get workflow usage
     * > [!WARNING]
     * > This endpoint is in the process of closing down. Refer to "[Actions Get workflow usage and Get workflow run usage endpoints closing down](https://github.blog/changelog/2025-02-02-actions-get-workflow-usage-and-get-workflow-run-usage-endpoints-closing-down/)" for more information.
     *
     * Gets the number of billable minutes used by a specific workflow during the current billing cycle. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     *
     * You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
     * @returns workflow_usage Response
     * @throws ApiError
     */
    public static actionsGetWorkflowUsage(
        owner: string,
        repo: string,
        workflowId: (number | string),
    ): CancelablePromise<workflow_usage> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing',
            path: {
                'owner': owner,
                'repo': repo,
                'workflow_id': workflowId,
            },
        });
    }
    /**
     * List environment secrets
     * Lists all secrets available in an environment without revealing their
     * encrypted values.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListEnvironmentSecrets(
        owner: string,
        repo: string,
        environmentName: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        secrets: Array<actions_secret>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/secrets',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get an environment public key
     * Get the public key for an environment, which you need to encrypt environment
     * secrets. You need to encrypt a secret before you can create or update secrets.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * If the repository is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @returns actions_public_key Response
     * @throws ApiError
     */
    public static actionsGetEnvironmentPublicKey(
        owner: string,
        repo: string,
        environmentName: string,
    ): CancelablePromise<actions_public_key> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
            },
        });
    }
    /**
     * Get an environment secret
     * Gets a single environment secret without revealing its encrypted value.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param secretName The name of the secret.
     * @returns actions_secret Response
     * @throws ApiError
     */
    public static actionsGetEnvironmentSecret(
        owner: string,
        repo: string,
        environmentName: string,
        secretName: string,
    ): CancelablePromise<actions_secret> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
                'secret_name': secretName,
            },
        });
    }
    /**
     * Create or update an environment secret
     * Creates or updates an environment secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param secretName The name of the secret.
     * @param requestBody
     * @returns empty_object Response when creating a secret
     * @throws ApiError
     */
    public static actionsCreateOrUpdateEnvironmentSecret(
        owner: string,
        repo: string,
        environmentName: string,
        secretName: string,
        requestBody: {
            /**
             * Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/actions/secrets#get-an-environment-public-key) endpoint.
             */
            encrypted_value: string;
            /**
             * ID of the key you used to encrypt the secret.
             */
            key_id: string;
        },
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
                'secret_name': secretName,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete an environment secret
     * Deletes a secret in an environment using the secret name.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read secrets.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param secretName The name of the secret.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteEnvironmentSecret(
        owner: string,
        repo: string,
        environmentName: string,
        secretName: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
                'secret_name': secretName,
            },
        });
    }
    /**
     * List environment variables
     * Lists all environment variables.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param perPage The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static actionsListEnvironmentVariables(
        owner: string,
        repo: string,
        environmentName: string,
        perPage: number = 10,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        variables: Array<actions_variable>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/variables',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create an environment variable
     * Create an environment variable that you can reference in a GitHub Actions workflow.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param requestBody
     * @returns empty_object Response
     * @throws ApiError
     */
    public static actionsCreateEnvironmentVariable(
        owner: string,
        repo: string,
        environmentName: string,
        requestBody: {
            /**
             * The name of the variable.
             */
            name: string;
            /**
             * The value of the variable.
             */
            value: string;
        },
    ): CancelablePromise<empty_object> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/variables',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Get an environment variable
     * Gets a specific variable in an environment.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param name The name of the variable.
     * @returns actions_variable Response
     * @throws ApiError
     */
    public static actionsGetEnvironmentVariable(
        owner: string,
        repo: string,
        environmentName: string,
        name: string,
    ): CancelablePromise<actions_variable> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/variables/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
                'name': name,
            },
        });
    }
    /**
     * Update an environment variable
     * Updates an environment variable that you can reference in a GitHub Actions workflow.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param name The name of the variable.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static actionsUpdateEnvironmentVariable(
        owner: string,
        repo: string,
        name: string,
        environmentName: string,
        requestBody: {
            /**
             * The name of the variable.
             */
            name?: string;
            /**
             * The value of the variable.
             */
            value?: string;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/variables/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'name': name,
                'environment_name': environmentName,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete an environment variable
     * Deletes an environment variable using the variable name.
     *
     * Authenticated users must have collaborator access to a repository to create, update, or read variables.
     *
     * OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param name The name of the variable.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @returns void
     * @throws ApiError
     */
    public static actionsDeleteEnvironmentVariable(
        owner: string,
        repo: string,
        name: string,
        environmentName: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/variables/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'name': name,
                'environment_name': environmentName,
            },
        });
    }
}

// From: ActivityService.ts
export class ActivityService {
    /**
     * List public events
     * > [!NOTE]
     * > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns event Response
     * @throws ApiError
     */
    public static activityListPublicEvents(
        perPage: number = 15,
        page: number = 1,
    ): CancelablePromise<Array<event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/events',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                503: `Service unavailable`,
            },
        });
    }
    /**
     * Get feeds
     * Lists the feeds available to the authenticated user. The response provides a URL for each feed. You can then get a specific feed by sending a request to one of the feed URLs.
     *
     * *   **Timeline**: The GitHub global public timeline
     * *   **User**: The public timeline for any user, using `uri_template`. For more information, see "[Hypermedia](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
     * *   **Current user public**: The public timeline for the authenticated user
     * *   **Current user**: The private timeline for the authenticated user
     * *   **Current user actor**: The private timeline for activity created by the authenticated user
     * *   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.
     * *   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.
     *
     * By default, timeline resources are returned in JSON. You can specify the `application/atom+xml` type in the `Accept` header to return timeline resources in Atom format. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * > [!NOTE]
     * > Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) since current feed URIs use the older, non revocable auth tokens.
     * @returns feed Response
     * @throws ApiError
     */
    public static activityGetFeeds(): CancelablePromise<feed> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/feeds',
        });
    }
    /**
     * List public events for a network of repositories
     * > [!NOTE]
     * > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns event Response
     * @throws ApiError
     */
    public static activityListPublicEventsForRepoNetwork(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/networks/{owner}/{repo}/events',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                301: `Moved permanently`,
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List notifications for the authenticated user
     * List all notifications for the current user, sorted by most recently updated.
     * @param all If `true`, show notifications marked as read.
     * @param participating If `true`, only shows notifications in which the user is directly participating or mentioned.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param before Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 50). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns thread Response
     * @throws ApiError
     */
    public static activityListNotificationsForAuthenticatedUser(
        all: boolean = false,
        participating: boolean = false,
        since?: string,
        before?: string,
        page: number = 1,
        perPage: number = 50,
    ): CancelablePromise<Array<thread>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/notifications',
            query: {
                'all': all,
                'participating': participating,
                'since': since,
                'before': before,
                'page': page,
                'per_page': perPage,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Mark notifications as read
     * Marks all notifications as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static activityMarkNotificationsAsRead(
        requestBody?: {
            /**
             * Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.
             */
            last_read_at?: string;
            /**
             * Whether the notification has been read.
             */
            read?: boolean;
        },
    ): CancelablePromise<{
        message?: string;
    }> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/notifications',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Get a thread
     * Gets information about a notification thread.
     * @param threadId The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).
     * @returns thread Response
     * @throws ApiError
     */
    public static activityGetThread(
        threadId: number,
    ): CancelablePromise<thread> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/notifications/threads/{thread_id}',
            path: {
                'thread_id': threadId,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Mark a thread as read
     * Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification in your notification inbox on GitHub: https://github.com/notifications.
     * @param threadId The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).
     * @returns any Reset Content
     * @throws ApiError
     */
    public static activityMarkThreadAsRead(
        threadId: number,
    ): CancelablePromise<any> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/notifications/threads/{thread_id}',
            path: {
                'thread_id': threadId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Mark a thread as done
     * Marks a thread as "done." Marking a thread as "done" is equivalent to marking a notification in your notification inbox on GitHub as done: https://github.com/notifications.
     * @param threadId The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).
     * @returns void
     * @throws ApiError
     */
    public static activityMarkThreadAsDone(
        threadId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/notifications/threads/{thread_id}',
            path: {
                'thread_id': threadId,
            },
        });
    }
    /**
     * Get a thread subscription for the authenticated user
     * This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/activity/watching#get-a-repository-subscription).
     *
     * Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
     * @param threadId The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).
     * @returns thread_subscription Response
     * @throws ApiError
     */
    public static activityGetThreadSubscriptionForAuthenticatedUser(
        threadId: number,
    ): CancelablePromise<thread_subscription> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/notifications/threads/{thread_id}/subscription',
            path: {
                'thread_id': threadId,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Set a thread subscription
     * If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.
     *
     * You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.
     *
     * Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/activity/notifications#delete-a-thread-subscription) endpoint.
     * @param threadId The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).
     * @param requestBody
     * @returns thread_subscription Response
     * @throws ApiError
     */
    public static activitySetThreadSubscription(
        threadId: number,
        requestBody?: {
            /**
             * Whether to block all notifications from a thread.
             */
            ignored?: boolean;
        },
    ): CancelablePromise<thread_subscription> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/notifications/threads/{thread_id}/subscription',
            path: {
                'thread_id': threadId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Delete a thread subscription
     * Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/activity/notifications#set-a-thread-subscription) endpoint and set `ignore` to `true`.
     * @param threadId The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).
     * @returns void
     * @throws ApiError
     */
    public static activityDeleteThreadSubscription(
        threadId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/notifications/threads/{thread_id}/subscription',
            path: {
                'thread_id': threadId,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * List public organization events
     * > [!NOTE]
     * > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns event Response
     * @throws ApiError
     */
    public static activityListPublicOrgEvents(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/events',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List repository events
     * > [!NOTE]
     * > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns event Response
     * @throws ApiError
     */
    public static activityListRepoEvents(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/events',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List repository notifications for the authenticated user
     * Lists all notifications for the current user in the specified repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param all If `true`, show notifications marked as read.
     * @param participating If `true`, only shows notifications in which the user is directly participating or mentioned.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param before Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns thread Response
     * @throws ApiError
     */
    public static activityListRepoNotificationsForAuthenticatedUser(
        owner: string,
        repo: string,
        all: boolean = false,
        participating: boolean = false,
        since?: string,
        before?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<thread>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/notifications',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'all': all,
                'participating': participating,
                'since': since,
                'before': before,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Mark repository notifications as read
     * Marks all notifications in a repository as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static activityMarkRepoNotificationsAsRead(
        owner: string,
        repo: string,
        requestBody?: {
            /**
             * Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.
             */
            last_read_at?: string;
        },
    ): CancelablePromise<{
        message?: string;
        url?: string;
    }> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/notifications',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List stargazers
     * Lists the people that have starred the repository.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static activityListStargazersForRepo(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<(Array<simple_user> | Array<stargazer>)> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/stargazers',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List watchers
     * Lists the people watching the specified repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static activityListWatchersForRepo(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/subscribers',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get a repository subscription
     * Gets information about whether the authenticated user is subscribed to the repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns repository_subscription if you subscribe to the repository
     * @throws ApiError
     */
    public static activityGetRepoSubscription(
        owner: string,
        repo: string,
    ): CancelablePromise<repository_subscription> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/subscription',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                403: `Forbidden`,
                404: `Not Found if you don't subscribe to the repository`,
            },
        });
    }
    /**
     * Set a repository subscription
     * If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/activity/watching#delete-a-repository-subscription) completely.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns repository_subscription Response
     * @throws ApiError
     */
    public static activitySetRepoSubscription(
        owner: string,
        repo: string,
        requestBody?: {
            /**
             * Determines if notifications should be received from this repository.
             */
            subscribed?: boolean;
            /**
             * Determines if all notifications should be blocked from this repository.
             */
            ignored?: boolean;
        },
    ): CancelablePromise<repository_subscription> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/subscription',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a repository subscription
     * This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/activity/watching#set-a-repository-subscription).
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static activityDeleteRepoSubscription(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/subscription',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * List repositories starred by the authenticated user
     * Lists repositories the authenticated user has starred.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
     * @param sort The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
     * @param direction The direction to sort the results by.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns repository Response
     * @throws ApiError
     */
    public static activityListReposStarredByAuthenticatedUser(
        sort: 'created' | 'updated' = 'created',
        direction: 'asc' | 'desc' = 'desc',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/starred',
            query: {
                'sort': sort,
                'direction': direction,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Check if a repository is starred by the authenticated user
     * Whether the authenticated user has starred the repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static activityCheckRepoIsStarredByAuthenticatedUser(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/starred/{owner}/{repo}',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Not Found if this repository is not starred by you`,
            },
        });
    }
    /**
     * Star a repository for the authenticated user
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static activityStarRepoForAuthenticatedUser(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/user/starred/{owner}/{repo}',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Unstar a repository for the authenticated user
     * Unstar a repository that the authenticated user has previously starred.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static activityUnstarRepoForAuthenticatedUser(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/user/starred/{owner}/{repo}',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List repositories watched by the authenticated user
     * Lists repositories the authenticated user is watching.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns minimal_repository Response
     * @throws ApiError
     */
    public static activityListWatchedReposForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<minimal_repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/subscriptions',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * List events for the authenticated user
     * If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events. _Optional_: use the fine-grained token with following permission set to view private events: "Events" user permissions (read).
     *
     * > [!NOTE]
     * > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns event Response
     * @throws ApiError
     */
    public static activityListEventsForAuthenticatedUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/events',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List organization events for the authenticated user
     * This is the user's organization dashboard. You must be authenticated as the user to view this.
     *
     * > [!NOTE]
     * > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
     * @param username The handle for the GitHub user account.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns event Response
     * @throws ApiError
     */
    public static activityListOrgEventsForAuthenticatedUser(
        username: string,
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/events/orgs/{org}',
            path: {
                'username': username,
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List public events for a user
     * > [!NOTE]
     * > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns event Response
     * @throws ApiError
     */
    public static activityListPublicEventsForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/events/public',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List events received by the authenticated user
     * These are events that you've received by watching repositories and following users. If you are authenticated as the
     * given user, you will see private events. Otherwise, you'll only see public events.
     *
     * > [!NOTE]
     * > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns event Response
     * @throws ApiError
     */
    public static activityListReceivedEventsForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/received_events',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List public events received by a user
     * > [!NOTE]
     * > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns event Response
     * @throws ApiError
     */
    public static activityListReceivedPublicEventsForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/received_events/public',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List repositories starred by a user
     * Lists repositories a user has starred.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
     * @param username The handle for the GitHub user account.
     * @param sort The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
     * @param direction The direction to sort the results by.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static activityListReposStarredByUser(
        username: string,
        sort: 'created' | 'updated' = 'created',
        direction: 'asc' | 'desc' = 'desc',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<(Array<starred_repository> | Array<repository>)> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/starred',
            path: {
                'username': username,
            },
            query: {
                'sort': sort,
                'direction': direction,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List repositories watched by a user
     * Lists repositories a user is watching.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns minimal_repository Response
     * @throws ApiError
     */
    public static activityListReposWatchedByUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<minimal_repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/subscriptions',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
}

// From: GistsService.ts
export class GistsService {
    /**
     * List gists for the authenticated user
     * Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns base_gist Response
     * @throws ApiError
     */
    public static gistsList(
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<base_gist>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists',
            query: {
                'since': since,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Create a gist
     * Allows you to add a new gist with one or more files.
     *
     * > [!NOTE]
     * > Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.
     * @param requestBody
     * @returns gist_simple Response
     * @throws ApiError
     */
    public static gistsCreate(
        requestBody: {
            /**
             * Description of the gist
             */
            description?: string;
            /**
             * Names and content for the files that make up the gist
             */
            files: Record<string, {
                /**
                 * Content of the file
                 */
                content: string;
            }>;
            public?: (boolean | 'true' | 'false');
        },
    ): CancelablePromise<gist_simple> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/gists',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List public gists
     * List public gists sorted by most recently updated to least recently updated.
     *
     * Note: With [pagination](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns base_gist Response
     * @throws ApiError
     */
    public static gistsListPublic(
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<base_gist>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists/public',
            query: {
                'since': since,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List starred gists
     * List the authenticated user's starred gists:
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns base_gist Response
     * @throws ApiError
     */
    public static gistsListStarred(
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<base_gist>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists/starred',
            query: {
                'since': since,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Get a gist
     * Gets a specified gist.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
     * @param gistId The unique identifier of the gist.
     * @returns gist_simple Response
     * @throws ApiError
     */
    public static gistsGet(
        gistId: string,
    ): CancelablePromise<gist_simple> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists/{gist_id}',
            path: {
                'gist_id': gistId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden Gist`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a gist
     * Allows you to update a gist's description and to update, delete, or rename gist files. Files
     * from the previous version of the gist that aren't explicitly changed during an edit
     * are unchanged.
     *
     * At least one of `description` or `files` is required.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
     * @param gistId The unique identifier of the gist.
     * @param requestBody
     * @returns gist_simple Response
     * @throws ApiError
     */
    public static gistsUpdate(
        gistId: string,
        requestBody: {
            /**
             * The description of the gist.
             */
            description?: string;
            /**
             * The gist files to be updated, renamed, or deleted. Each `key` must match the current filename
             * (including extension) of the targeted gist file. For example: `hello.py`.
             *
             * To delete a file, set the whole file to null. For example: `hello.py : null`. The file will also be
             * deleted if the specified object does not contain at least one of `content` or `filename`.
             */
            files?: Record<string, {
                /**
                 * The new content of the file.
                 */
                content?: string;
                /**
                 * The new filename for the file.
                 */
                filename?: string | null;
            } | null>;
        } | null,
    ): CancelablePromise<gist_simple> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/gists/{gist_id}',
            path: {
                'gist_id': gistId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete a gist
     * @param gistId The unique identifier of the gist.
     * @returns void
     * @throws ApiError
     */
    public static gistsDelete(
        gistId: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/gists/{gist_id}',
            path: {
                'gist_id': gistId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List gist comments
     * Lists the comments on a gist.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
     * @param gistId The unique identifier of the gist.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns gist_comment Response
     * @throws ApiError
     */
    public static gistsListComments(
        gistId: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<gist_comment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists/{gist_id}/comments',
            path: {
                'gist_id': gistId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a gist comment
     * Creates a comment on a gist.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
     * @param gistId The unique identifier of the gist.
     * @param requestBody
     * @returns gist_comment Response
     * @throws ApiError
     */
    public static gistsCreateComment(
        gistId: string,
        requestBody: {
            /**
             * The comment text.
             */
            body: string;
        },
    ): CancelablePromise<gist_comment> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/gists/{gist_id}/comments',
            path: {
                'gist_id': gistId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a gist comment
     * Gets a comment on a gist.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
     * @param gistId The unique identifier of the gist.
     * @param commentId The unique identifier of the comment.
     * @returns gist_comment Response
     * @throws ApiError
     */
    public static gistsGetComment(
        gistId: string,
        commentId: number,
    ): CancelablePromise<gist_comment> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists/{gist_id}/comments/{comment_id}',
            path: {
                'gist_id': gistId,
                'comment_id': commentId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden Gist`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a gist comment
     * Updates a comment on a gist.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
     * @param gistId The unique identifier of the gist.
     * @param commentId The unique identifier of the comment.
     * @param requestBody
     * @returns gist_comment Response
     * @throws ApiError
     */
    public static gistsUpdateComment(
        gistId: string,
        commentId: number,
        requestBody: {
            /**
             * The comment text.
             */
            body: string;
        },
    ): CancelablePromise<gist_comment> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/gists/{gist_id}/comments/{comment_id}',
            path: {
                'gist_id': gistId,
                'comment_id': commentId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete a gist comment
     * @param gistId The unique identifier of the gist.
     * @param commentId The unique identifier of the comment.
     * @returns void
     * @throws ApiError
     */
    public static gistsDeleteComment(
        gistId: string,
        commentId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/gists/{gist_id}/comments/{comment_id}',
            path: {
                'gist_id': gistId,
                'comment_id': commentId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List gist commits
     * @param gistId The unique identifier of the gist.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns gist_commit Response
     * @throws ApiError
     */
    public static gistsListCommits(
        gistId: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<gist_commit>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists/{gist_id}/commits',
            path: {
                'gist_id': gistId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List gist forks
     * @param gistId The unique identifier of the gist.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns gist_simple Response
     * @throws ApiError
     */
    public static gistsListForks(
        gistId: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<gist_simple>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists/{gist_id}/forks',
            path: {
                'gist_id': gistId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Fork a gist
     * @param gistId The unique identifier of the gist.
     * @returns base_gist Response
     * @throws ApiError
     */
    public static gistsFork(
        gistId: string,
    ): CancelablePromise<base_gist> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/gists/{gist_id}/forks',
            path: {
                'gist_id': gistId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Check if a gist is starred
     * @param gistId The unique identifier of the gist.
     * @returns void
     * @throws ApiError
     */
    public static gistsCheckIsStarred(
        gistId: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists/{gist_id}/star',
            path: {
                'gist_id': gistId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Not Found if gist is not starred`,
            },
        });
    }
    /**
     * Star a gist
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
     * @param gistId The unique identifier of the gist.
     * @returns void
     * @throws ApiError
     */
    public static gistsStar(
        gistId: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/gists/{gist_id}/star',
            path: {
                'gist_id': gistId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Unstar a gist
     * @param gistId The unique identifier of the gist.
     * @returns void
     * @throws ApiError
     */
    public static gistsUnstar(
        gistId: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/gists/{gist_id}/star',
            path: {
                'gist_id': gistId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a gist revision
     * Gets a specified gist revision.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
     * @param gistId The unique identifier of the gist.
     * @param sha
     * @returns gist_simple Response
     * @throws ApiError
     */
    public static gistsGetRevision(
        gistId: string,
        sha: string,
    ): CancelablePromise<gist_simple> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/gists/{gist_id}/{sha}',
            path: {
                'gist_id': gistId,
                'sha': sha,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List gists for a user
     * Lists public gists for the specified user:
     * @param username The handle for the GitHub user account.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns base_gist Response
     * @throws ApiError
     */
    public static gistsListForUser(
        username: string,
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<base_gist>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/gists',
            path: {
                'username': username,
            },
            query: {
                'since': since,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
}

// From: IssuesService.ts
export class IssuesService {
    /**
     * List issues assigned to the authenticated user
     * List issues assigned to the authenticated user across all visible repositories including owned repositories, member
     * repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
     * necessarily assigned to you.
     *
     * > [!NOTE]
     * > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param filter Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
     * @param state Indicates the state of the issues to return.
     * @param labels A list of comma separated label names. Example: `bug,ui,@high`
     * @param sort What to sort results by.
     * @param direction The direction to sort the results by.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param collab
     * @param orgs
     * @param owned
     * @param pulls
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesList(
        filter: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'repos' | 'all' = 'assigned',
        state: 'open' | 'closed' | 'all' = 'open',
        labels?: string,
        sort: 'created' | 'updated' | 'comments' = 'created',
        direction: 'asc' | 'desc' = 'desc',
        since?: string,
        collab?: boolean,
        orgs?: boolean,
        owned?: boolean,
        pulls?: boolean,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/issues',
            query: {
                'filter': filter,
                'state': state,
                'labels': labels,
                'sort': sort,
                'direction': direction,
                'since': since,
                'collab': collab,
                'orgs': orgs,
                'owned': owned,
                'pulls': pulls,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List organization issues assigned to the authenticated user
     * List issues in an organization assigned to the authenticated user.
     *
     * > [!NOTE]
     * > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param org The organization name. The name is not case sensitive.
     * @param filter Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
     * @param state Indicates the state of the issues to return.
     * @param labels A list of comma separated label names. Example: `bug,ui,@high`
     * @param type Can be the name of an issue type.
     * @param sort What to sort results by.
     * @param direction The direction to sort the results by.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesListForOrg(
        org: string,
        filter: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'repos' | 'all' = 'assigned',
        state: 'open' | 'closed' | 'all' = 'open',
        labels?: string,
        type?: string,
        sort: 'created' | 'updated' | 'comments' = 'created',
        direction: 'asc' | 'desc' = 'desc',
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/issues',
            path: {
                'org': org,
            },
            query: {
                'filter': filter,
                'state': state,
                'labels': labels,
                'type': type,
                'sort': sort,
                'direction': direction,
                'since': since,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List assignees
     * Lists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static issuesListAssignees(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/assignees',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Check if a user can be assigned
     * Checks if a user has permission to be assigned to an issue in this repository.
     *
     * If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
     *
     * Otherwise a `404` status code is returned.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param assignee
     * @returns void
     * @throws ApiError
     */
    public static issuesCheckUserCanBeAssigned(
        owner: string,
        repo: string,
        assignee: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/assignees/{assignee}',
            path: {
                'owner': owner,
                'repo': repo,
                'assignee': assignee,
            },
            errors: {
                404: `Otherwise a \`404\` status code is returned.`,
            },
        });
    }
    /**
     * List repository issues
     * List issues in a repository. Only open issues will be listed.
     *
     * > [!NOTE]
     * > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param milestone If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.
     * @param state Indicates the state of the issues to return.
     * @param assignee Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.
     * @param type Can be the name of an issue type. If the string `*` is passed, issues with any type are accepted. If the string `none` is passed, issues without type are returned.
     * @param creator The user that created the issue.
     * @param mentioned A user that's mentioned in the issue.
     * @param labels A list of comma separated label names. Example: `bug,ui,@high`
     * @param sort What to sort results by.
     * @param direction The direction to sort the results by.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesListForRepo(
        owner: string,
        repo: string,
        milestone?: string,
        state: 'open' | 'closed' | 'all' = 'open',
        assignee?: string,
        type?: string,
        creator?: string,
        mentioned?: string,
        labels?: string,
        sort: 'created' | 'updated' | 'comments' = 'created',
        direction: 'asc' | 'desc' = 'desc',
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'milestone': milestone,
                'state': state,
                'assignee': assignee,
                'type': type,
                'creator': creator,
                'mentioned': mentioned,
                'labels': labels,
                'sort': sort,
                'direction': direction,
                'since': since,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Create an issue
     * Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
     * and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesCreate(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The title of the issue.
             */
            title: (string | number);
            /**
             * The contents of the issue.
             */
            body?: string;
            /**
             * Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is closing down.**_
             */
            assignee?: string | null;
            milestone?: (string | number) | null;
            /**
             * Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._
             */
            labels?: Array<(string | {
                id?: number;
                name?: string;
                description?: string | null;
                color?: string | null;
            })>;
            /**
             * Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._
             */
            assignees?: Array<string>;
            /**
             * The name of the issue type to associate with this issue. _NOTE: Only users with push access can set the type for new issues. The type is silently dropped otherwise._
             */
            type?: string | null;
        },
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/issues',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                403: `Forbidden`,
                404: `Resource not found`,
                410: `Gone`,
                422: `Validation failed, or the endpoint has been spammed.`,
                503: `Service unavailable`,
            },
        });
    }
    /**
     * List issue comments for a repository
     * You can use the REST API to list comments on issues and pull requests for a repository. Every pull request is an issue, but not every issue is a pull request.
     *
     * By default, issue comments are ordered by ascending ID.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param sort The property to sort the results by.
     * @param direction Either `asc` or `desc`. Ignored without the `sort` parameter.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue_comment Response
     * @throws ApiError
     */
    public static issuesListCommentsForRepo(
        owner: string,
        repo: string,
        sort: 'created' | 'updated' = 'created',
        direction?: 'asc' | 'desc',
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue_comment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/comments',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'sort': sort,
                'direction': direction,
                'since': since,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get an issue comment
     * You can use the REST API to get comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @returns issue_comment Response
     * @throws ApiError
     */
    public static issuesGetComment(
        owner: string,
        repo: string,
        commentId: number,
    ): CancelablePromise<issue_comment> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/comments/{comment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'comment_id': commentId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update an issue comment
     * You can use the REST API to update comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param requestBody
     * @returns issue_comment Response
     * @throws ApiError
     */
    public static issuesUpdateComment(
        owner: string,
        repo: string,
        commentId: number,
        requestBody: {
            /**
             * The contents of the comment.
             */
            body: string;
        },
    ): CancelablePromise<issue_comment> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/issues/comments/{comment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'comment_id': commentId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete an issue comment
     * You can use the REST API to delete comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @returns void
     * @throws ApiError
     */
    public static issuesDeleteComment(
        owner: string,
        repo: string,
        commentId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/issues/comments/{comment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'comment_id': commentId,
            },
        });
    }
    /**
     * List issue events for a repository
     * Lists events for a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue_event Response
     * @throws ApiError
     */
    public static issuesListEventsForRepo(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue_event>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/events',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get an issue event
     * Gets a single event by the event id.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param eventId
     * @returns issue_event Response
     * @throws ApiError
     */
    public static issuesGetEvent(
        owner: string,
        repo: string,
        eventId: number,
    ): CancelablePromise<issue_event> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/events/{event_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'event_id': eventId,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * Get an issue
     * The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api#follow-redirects) if the issue was
     * [transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
     * the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
     * returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
     * access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
     * to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
     *
     * > [!NOTE]
     * > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesGet(
        owner: string,
        repo: string,
        issueNumber: number,
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            errors: {
                301: `Moved permanently`,
                304: `Not modified`,
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * Update an issue
     * Issue owners and users with push access or Triage role can edit an issue.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesUpdate(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody?: {
            /**
             * The title of the issue.
             */
            title?: (string | number) | null;
            /**
             * The contents of the issue.
             */
            body?: string | null;
            /**
             * Username to assign to this issue. **This field is closing down.**
             */
            assignee?: string | null;
            /**
             * The open or closed state of the issue.
             */
            state?: 'open' | 'closed';
            /**
             * The reason for the state change. Ignored unless `state` is changed.
             */
            state_reason?: 'completed' | 'not_planned' | 'duplicate' | 'reopened' | null;
            milestone?: (string | number) | null;
            /**
             * Labels to associate with this issue. Pass one or more labels to _replace_ the set of labels on this issue. Send an empty array (`[]`) to clear all labels from the issue. Only users with push access can set labels for issues. Without push access to the repository, label changes are silently dropped.
             */
            labels?: Array<(string | {
                id?: number;
                name?: string;
                description?: string | null;
                color?: string | null;
            })>;
            /**
             * Usernames to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this issue. Send an empty array (`[]`) to clear all assignees from the issue. Only users with push access can set assignees for new issues. Without push access to the repository, assignee changes are silently dropped.
             */
            assignees?: Array<string>;
            /**
             * The name of the issue type to associate with this issue or use `null` to remove the current issue type. Only users with push access can set the type for issues. Without push access to the repository, type changes are silently dropped.
             */
            type?: string | null;
        },
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/issues/{issue_number}',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                301: `Moved permanently`,
                403: `Forbidden`,
                404: `Resource not found`,
                410: `Gone`,
                422: `Validation failed, or the endpoint has been spammed.`,
                503: `Service unavailable`,
            },
        });
    }
    /**
     * Add assignees to an issue
     * Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesAddAssignees(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody?: {
            /**
             * Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._
             */
            assignees?: Array<string>;
        },
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/assignees',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Remove assignees from an issue
     * Removes one or more assignees from an issue.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesRemoveAssignees(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody?: {
            /**
             * Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._
             */
            assignees?: Array<string>;
        },
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/assignees',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Check if a user can be assigned to a issue
     * Checks if a user has permission to be assigned to a specific issue.
     *
     * If the `assignee` can be assigned to this issue, a `204` status code with no content is returned.
     *
     * Otherwise a `404` status code is returned.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param assignee
     * @returns void
     * @throws ApiError
     */
    public static issuesCheckUserCanBeAssignedToIssue(
        owner: string,
        repo: string,
        issueNumber: number,
        assignee: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
                'assignee': assignee,
            },
            errors: {
                404: `Response if \`assignee\` can not be assigned to \`issue_number\``,
            },
        });
    }
    /**
     * List issue comments
     * You can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
     *
     * Issue comments are ordered by ascending ID.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue_comment Response
     * @throws ApiError
     */
    public static issuesListComments(
        owner: string,
        repo: string,
        issueNumber: number,
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue_comment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/comments',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            query: {
                'since': since,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * Create an issue comment
     * You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting.
     * For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
     * and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns issue_comment Response
     * @throws ApiError
     */
    public static issuesCreateComment(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody: {
            /**
             * The contents of the comment.
             */
            body: string;
        },
    ): CancelablePromise<issue_comment> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/comments',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                410: `Gone`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List dependencies an issue is blocked by
     * You can use the REST API to list the dependencies an issue is blocked by.
     *
     * This endpoint supports the following custom media types. For more information, see [Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw Markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the Markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's Markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesListDependenciesBlockedBy(
        owner: string,
        repo: string,
        issueNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * Add a dependency an issue is blocked by
     * You can use the REST API to add a 'blocked by' relationship to an issue.
     *
     * Creating content too quickly using this endpoint may result in secondary rate limiting.
     * For more information, see [Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)
     * and [Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).
     *
     * This endpoint supports the following custom media types. For more information, see [Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw Markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the Markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's Markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesAddBlockedByDependency(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody: {
            /**
             * The id of the issue that blocks the current issue
             */
            issue_id: number;
        },
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                301: `Moved permanently`,
                403: `Forbidden`,
                404: `Resource not found`,
                410: `Gone`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove dependency an issue is blocked by
     * You can use the REST API to remove a dependency that an issue is blocked by.
     *
     * Removing content too quickly using this endpoint may result in secondary rate limiting.
     * For more information, see [Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)
     * and [Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).
     *
     * This endpoint supports the following custom media types. For more information, see [Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).
     * - **`application/vnd.github.raw+json`**: Returns the raw Markdown body. Response will include `body`. This is the default if you do not pass a specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the Markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's Markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param issueId The id of the blocking issue to remove as a dependency
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesRemoveDependencyBlockedBy(
        owner: string,
        repo: string,
        issueNumber: number,
        issueId: number,
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by/{issue_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
                'issue_id': issueId,
            },
            errors: {
                301: `Moved permanently`,
                400: `Bad Request`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * List dependencies an issue is blocking
     * You can use the REST API to list the dependencies an issue is blocking.
     *
     * This endpoint supports the following custom media types. For more information, see [Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw Markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the Markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's Markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesListDependenciesBlocking(
        owner: string,
        repo: string,
        issueNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocking',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * List issue events
     * Lists all events for an issue.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue_event_for_issue Response
     * @throws ApiError
     */
    public static issuesListEvents(
        owner: string,
        repo: string,
        issueNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue_event_for_issue>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/events',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                410: `Gone`,
            },
        });
    }
    /**
     * List labels for an issue
     * Lists all labels for an issue.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns label Response
     * @throws ApiError
     */
    public static issuesListLabelsOnIssue(
        owner: string,
        repo: string,
        issueNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<label>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/labels',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * Add labels to an issue
     * Adds labels to an issue. If you provide an empty array of labels, all labels are removed from the issue.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns label Response
     * @throws ApiError
     */
    public static issuesAddLabels(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody?: ({
            /**
             * The names of the labels to add to the issue's existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also replace all of the labels for an issue. For more information, see "[Set labels for an issue](https://docs.github.com/rest/issues/labels#set-labels-for-an-issue)."
             */
            labels?: Array<string>;
        } | Array<string> | {
            labels?: Array<{
                name: string;
            }>;
        } | string),
    ): CancelablePromise<Array<label>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/labels',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
                410: `Gone`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Set labels for an issue
     * Removes any previous labels and sets the new labels for an issue.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns label Response
     * @throws ApiError
     */
    public static issuesSetLabels(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody?: ({
            /**
             * The names of the labels to set for the issue. The labels you set replace any existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also add labels to the existing labels for an issue. For more information, see "[Add labels to an issue](https://docs.github.com/rest/issues/labels#add-labels-to-an-issue)."
             */
            labels?: Array<string>;
        } | Array<string> | {
            labels?: Array<{
                name: string;
            }>;
        } | string),
    ): CancelablePromise<Array<label>> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/labels',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
                410: `Gone`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove all labels from an issue
     * Removes all labels from an issue.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @returns void
     * @throws ApiError
     */
    public static issuesRemoveAllLabels(
        owner: string,
        repo: string,
        issueNumber: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/labels',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * Remove a label from an issue
     * Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param name
     * @returns label Response
     * @throws ApiError
     */
    public static issuesRemoveLabel(
        owner: string,
        repo: string,
        issueNumber: number,
        name: string,
    ): CancelablePromise<Array<label>> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
                'name': name,
            },
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * Lock an issue
     * Users with push access can lock an issue or pull request's conversation.
     *
     * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static issuesLock(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody?: {
            /**
             * The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:
             * * `off-topic`
             * * `too heated`
             * * `resolved`
             * * `spam`
             */
            lock_reason?: 'off-topic' | 'too heated' | 'resolved' | 'spam';
        } | null,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/lock',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                410: `Gone`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Unlock an issue
     * Users with push access can unlock an issue's conversation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @returns void
     * @throws ApiError
     */
    public static issuesUnlock(
        owner: string,
        repo: string,
        issueNumber: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/lock',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get parent issue
     * You can use the REST API to get the parent issue of a sub-issue.
     *
     * This endpoint supports the following custom media types. For more information, see [Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesGetParent(
        owner: string,
        repo: string,
        issueNumber: number,
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/parent',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * Remove sub-issue
     * You can use the REST API to remove a sub-issue from an issue.
     * Removing content too quickly using this endpoint may result in secondary rate limiting.
     * For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
     * and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass a specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesRemoveSubIssue(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody: {
            /**
             * The id of the sub-issue to remove
             */
            sub_issue_id: number;
        },
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/sub_issue',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List sub-issues
     * You can use the REST API to list the sub-issues on an issue.
     *
     * This endpoint supports the following custom media types. For more information, see [Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw Markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the Markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's Markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesListSubIssues(
        owner: string,
        repo: string,
        issueNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/sub_issues',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * Add sub-issue
     * You can use the REST API to add sub-issues to issues.
     *
     * Creating content too quickly using this endpoint may result in secondary rate limiting.
     * For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
     * and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesAddSubIssue(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody: {
            /**
             * The id of the sub-issue to add. The sub-issue must belong to the same repository owner as the parent issue
             */
            sub_issue_id: number;
            /**
             * Option that, when true, instructs the operation to replace the sub-issues current parent issue
             */
            replace_parent?: boolean;
        },
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/sub_issues',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                410: `Gone`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Reprioritize sub-issue
     * You can use the REST API to reprioritize a sub-issue to a different position in the parent list.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param requestBody
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesReprioritizeSubIssue(
        owner: string,
        repo: string,
        issueNumber: number,
        requestBody: {
            /**
             * The id of the sub-issue to reprioritize
             */
            sub_issue_id: number;
            /**
             * The id of the sub-issue to be prioritized after (either positional argument after OR before should be specified).
             */
            after_id?: number;
            /**
             * The id of the sub-issue to be prioritized before (either positional argument after OR before should be specified).
             */
            before_id?: number;
        },
    ): CancelablePromise<issue> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
                503: `Service unavailable`,
            },
        });
    }
    /**
     * List timeline events for an issue
     * List all timeline events for an issue.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns timeline_issue_events Response
     * @throws ApiError
     */
    public static issuesListEventsForTimeline(
        owner: string,
        repo: string,
        issueNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<timeline_issue_events>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/issues/{issue_number}/timeline',
            path: {
                'owner': owner,
                'repo': repo,
                'issue_number': issueNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
                410: `Gone`,
            },
        });
    }
    /**
     * List labels for a repository
     * Lists all labels for a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns label Response
     * @throws ApiError
     */
    public static issuesListLabelsForRepo(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<label>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/labels',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a label
     * Creates a label for the specified repository with the given name and color. The name and color parameters are required. The color must be a valid [hexadecimal color code](http://www.color-hex.com/).
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns label Response
     * @throws ApiError
     */
    public static issuesCreateLabel(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."
             */
            name: string;
            /**
             * The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
             */
            color?: string;
            /**
             * A short description of the label. Must be 100 characters or fewer.
             */
            description?: string;
        },
    ): CancelablePromise<label> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/labels',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a label
     * Gets a label using the given name.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param name
     * @returns label Response
     * @throws ApiError
     */
    public static issuesGetLabel(
        owner: string,
        repo: string,
        name: string,
    ): CancelablePromise<label> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/labels/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'name': name,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a label
     * Updates a label using the given label name.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param name
     * @param requestBody
     * @returns label Response
     * @throws ApiError
     */
    public static issuesUpdateLabel(
        owner: string,
        repo: string,
        name: string,
        requestBody?: {
            /**
             * The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."
             */
            new_name?: string;
            /**
             * The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
             */
            color?: string;
            /**
             * A short description of the label. Must be 100 characters or fewer.
             */
            description?: string;
        },
    ): CancelablePromise<label> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/labels/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'name': name,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a label
     * Deletes a label using the given label name.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param name
     * @returns void
     * @throws ApiError
     */
    public static issuesDeleteLabel(
        owner: string,
        repo: string,
        name: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/labels/{name}',
            path: {
                'owner': owner,
                'repo': repo,
                'name': name,
            },
        });
    }
    /**
     * List milestones
     * Lists milestones for a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param state The state of the milestone. Either `open`, `closed`, or `all`.
     * @param sort What to sort results by. Either `due_on` or `completeness`.
     * @param direction The direction of the sort. Either `asc` or `desc`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns milestone Response
     * @throws ApiError
     */
    public static issuesListMilestones(
        owner: string,
        repo: string,
        state: 'open' | 'closed' | 'all' = 'open',
        sort: 'due_on' | 'completeness' = 'due_on',
        direction: 'asc' | 'desc' = 'asc',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<milestone>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/milestones',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'state': state,
                'sort': sort,
                'direction': direction,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a milestone
     * Creates a milestone.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns milestone Response
     * @throws ApiError
     */
    public static issuesCreateMilestone(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The title of the milestone.
             */
            title: string;
            /**
             * The state of the milestone. Either `open` or `closed`.
             */
            state?: 'open' | 'closed';
            /**
             * A description of the milestone.
             */
            description?: string;
            /**
             * The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
             */
            due_on?: string;
        },
    ): CancelablePromise<milestone> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/milestones',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a milestone
     * Gets a milestone using the given milestone number.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param milestoneNumber The number that identifies the milestone.
     * @returns milestone Response
     * @throws ApiError
     */
    public static issuesGetMilestone(
        owner: string,
        repo: string,
        milestoneNumber: number,
    ): CancelablePromise<milestone> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/milestones/{milestone_number}',
            path: {
                'owner': owner,
                'repo': repo,
                'milestone_number': milestoneNumber,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a milestone
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param milestoneNumber The number that identifies the milestone.
     * @param requestBody
     * @returns milestone Response
     * @throws ApiError
     */
    public static issuesUpdateMilestone(
        owner: string,
        repo: string,
        milestoneNumber: number,
        requestBody?: {
            /**
             * The title of the milestone.
             */
            title?: string;
            /**
             * The state of the milestone. Either `open` or `closed`.
             */
            state?: 'open' | 'closed';
            /**
             * A description of the milestone.
             */
            description?: string;
            /**
             * The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
             */
            due_on?: string;
        },
    ): CancelablePromise<milestone> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/milestones/{milestone_number}',
            path: {
                'owner': owner,
                'repo': repo,
                'milestone_number': milestoneNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a milestone
     * Deletes a milestone using the given milestone number.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param milestoneNumber The number that identifies the milestone.
     * @returns void
     * @throws ApiError
     */
    public static issuesDeleteMilestone(
        owner: string,
        repo: string,
        milestoneNumber: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/milestones/{milestone_number}',
            path: {
                'owner': owner,
                'repo': repo,
                'milestone_number': milestoneNumber,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List labels for issues in a milestone
     * Lists labels for issues in a milestone.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param milestoneNumber The number that identifies the milestone.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns label Response
     * @throws ApiError
     */
    public static issuesListLabelsForMilestone(
        owner: string,
        repo: string,
        milestoneNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<label>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/milestones/{milestone_number}/labels',
            path: {
                'owner': owner,
                'repo': repo,
                'milestone_number': milestoneNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List user account issues assigned to the authenticated user
     * List issues across owned and member repositories assigned to the authenticated user.
     *
     * > [!NOTE]
     * > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param filter Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
     * @param state Indicates the state of the issues to return.
     * @param labels A list of comma separated label names. Example: `bug,ui,@high`
     * @param sort What to sort results by.
     * @param direction The direction to sort the results by.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns issue Response
     * @throws ApiError
     */
    public static issuesListForAuthenticatedUser(
        filter: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'repos' | 'all' = 'assigned',
        state: 'open' | 'closed' | 'all' = 'open',
        labels?: string,
        sort: 'created' | 'updated' | 'comments' = 'created',
        direction: 'asc' | 'desc' = 'desc',
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<issue>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/issues',
            query: {
                'filter': filter,
                'state': state,
                'labels': labels,
                'sort': sort,
                'direction': direction,
                'since': since,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                404: `Resource not found`,
            },
        });
    }
}

// From: MetaService.ts
export class MetaService {
    /**
     * GitHub API Root
     * Get Hypermedia links to resources accessible in GitHub's REST API
     * @returns root Response
     * @throws ApiError
     */
    public static metaRoot(): CancelablePromise<root> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/',
        });
    }
    /**
     * Get GitHub meta information
     * Returns meta information about GitHub, including a list of GitHub's IP addresses. For more information, see "[About GitHub's IP addresses](https://docs.github.com/articles/about-github-s-ip-addresses/)."
     *
     * The API's response also includes a list of GitHub's domain names.
     *
     * The values shown in the documentation's response are example values. You must always query the API directly to get the latest values.
     *
     * > [!NOTE]
     * > This endpoint returns both IPv4 and IPv6 addresses. However, not all features support IPv6. You should refer to the specific documentation for each feature to determine if IPv6 is supported.
     * @returns api_overview Response
     * @throws ApiError
     */
    public static metaGet(): CancelablePromise<api_overview> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/meta',
            errors: {
                304: `Not modified`,
            },
        });
    }
    /**
     * Get Octocat
     * Get the octocat as ASCII art
     * @param s The words to show in Octocat's speech bubble
     * @returns string Response
     * @throws ApiError
     */
    public static metaGetOctocat(
        s?: string,
    ): CancelablePromise<string> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/octocat',
            query: {
                's': s,
            },
        });
    }
    /**
     * Get all API versions
     * Get all supported GitHub API versions.
     * @returns string Response
     * @throws ApiError
     */
    public static metaGetAllVersions(): CancelablePromise<Array<string>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/versions',
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get the Zen of GitHub
     * Get a random sentence from the Zen of GitHub
     * @returns string Response
     * @throws ApiError
     */
    public static metaGetZen(): CancelablePromise<string> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/zen',
        });
    }
}

// From: OrgsService.ts
export class OrgsService {
    /**
     * List organizations
     * Lists all organizations, in the order that they were created.
     *
     * > [!NOTE]
     * > Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of organizations.
     * @param since An organization ID. Only return organizations with an ID greater than this ID.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns organization_simple Response
     * @throws ApiError
     */
    public static orgsList(
        since?: number,
        perPage: number = 30,
    ): CancelablePromise<Array<organization_simple>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/organizations',
            query: {
                'since': since,
                'per_page': perPage,
            },
            errors: {
                304: `Not modified`,
            },
        });
    }
    /**
     * Get all custom property values for an organization
     * Gets all custom property values that are set for an organization.
     *
     * The organization must belong to an enterprise.
     *
     * Access requirements:
     * - Organization admins
     * - OAuth tokens and personal access tokens (classic) with the `read:org` scope
     * - Actors with the organization-level "read custom properties for an organization" fine-grained permission or above
     * @param org The organization name. The name is not case sensitive.
     * @returns custom_property_value Response
     * @throws ApiError
     */
    public static orgsCustomPropertiesForOrgsGetOrganizationValues(
        org: string,
    ): CancelablePromise<Array<custom_property_value>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/organizations/{org}/org-properties/values',
            path: {
                'org': org,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create or update custom property values for an organization
     * Create new or update existing custom property values for an organization.
     * To remove a custom property value from an organization, set the property value to `null`.
     *
     * The organization must belong to an enterprise.
     *
     * Access requirements:
     * - Organization admins
     * - OAuth tokens and personal access tokens (classic) with the `admin:org` scope
     * - Actors with the organization-level "edit custom properties for an organization" fine-grained permission
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static orgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValues(
        org: string,
        requestBody: {
            /**
             * A list of custom property names and associated values to apply to the organization.
             */
            properties: Array<custom_property_value>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/organizations/{org}/org-properties/values',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get an organization
     * Gets information about an organization.
     *
     * When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, outside collaborators, guest collaborators, repository collaborators, or everyone with access to any repository within the organization to enable [two-factor authentication](https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).
     *
     * To see the full details about an organization, the authenticated user must be an organization owner.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to see the full details about an organization.
     *
     * To see information about an organization's GitHub plan, GitHub Apps need the `Organization plan` permission.
     * @param org The organization name. The name is not case sensitive.
     * @returns organization_full Response
     * @throws ApiError
     */
    public static orgsGet(
        org: string,
    ): CancelablePromise<organization_full> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}',
            path: {
                'org': org,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update an organization
     * > [!WARNING]
     * > **Closing down notice:** GitHub will replace and discontinue `members_allowed_repository_creation_type` in favor of more granular permissions. The new input parameters are `members_can_create_public_repositories`, `members_can_create_private_repositories` for all organizations and `members_can_create_internal_repositories` for organizations associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see the [blog post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes).
     *
     * > [!WARNING]
     * > **Closing down notice:** Code security product enablement for new repositories through the organization API is closing down. Please use [code security configurations](https://docs.github.com/rest/code-security/configurations#set-a-code-security-configuration-as-a-default-for-an-organization) to set defaults instead. For more information on setting a default security configuration, see the [changelog](https://github.blog/changelog/2024-07-09-sunsetting-security-settings-defaults-parameters-in-the-organizations-rest-api/).
     *
     * Updates the organization's profile and member privileges.
     *
     * The authenticated user must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` or `repo` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns organization_full Response
     * @throws ApiError
     */
    public static orgsUpdate(
        org: string,
        requestBody?: {
            /**
             * Billing email address. This address is not publicized.
             */
            billing_email?: string;
            /**
             * The company name.
             */
            company?: string;
            /**
             * The publicly visible email address.
             */
            email?: string;
            /**
             * The Twitter username of the company.
             */
            twitter_username?: string;
            /**
             * The location.
             */
            location?: string;
            /**
             * The shorthand name of the company.
             */
            name?: string;
            /**
             * The description of the company. The maximum size is 160 characters.
             */
            description?: string;
            /**
             * Whether an organization can use organization projects.
             */
            has_organization_projects?: boolean;
            /**
             * Whether repositories that belong to the organization can use repository projects.
             */
            has_repository_projects?: boolean;
            /**
             * Default permission level members have for organization repositories.
             */
            default_repository_permission?: 'read' | 'write' | 'admin' | 'none';
            /**
             * Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.
             */
            members_can_create_repositories?: boolean;
            /**
             * Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
             */
            members_can_create_internal_repositories?: boolean;
            /**
             * Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
             */
            members_can_create_private_repositories?: boolean;
            /**
             * Whether organization members can create public repositories, which are visible to anyone. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
             */
            members_can_create_public_repositories?: boolean;
            /**
             * Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud.
             * **Note:** This parameter is closing down and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.
             */
            members_allowed_repository_creation_type?: 'all' | 'private' | 'none';
            /**
             * Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.
             */
            members_can_create_pages?: boolean;
            /**
             * Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.
             */
            members_can_create_public_pages?: boolean;
            /**
             * Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.
             */
            members_can_create_private_pages?: boolean;
            /**
             * Whether organization members can fork private organization repositories.
             */
            members_can_fork_private_repositories?: boolean;
            /**
             * Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.
             */
            web_commit_signoff_required?: boolean;
            blog?: string;
            /**
             * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
             *
             * Whether GitHub Advanced Security is automatically enabled for new repositories and repositories transferred to this organization.
             *
             * To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
             *
             * You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
             * @deprecated
             */
            advanced_security_enabled_for_new_repositories?: boolean;
            /**
             * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
             *
             * Whether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.
             *
             * To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
             *
             * You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
             * @deprecated
             */
            dependabot_alerts_enabled_for_new_repositories?: boolean;
            /**
             * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
             *
             * Whether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.
             *
             * To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
             *
             * You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
             * @deprecated
             */
            dependabot_security_updates_enabled_for_new_repositories?: boolean;
            /**
             * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
             *
             * Whether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.
             *
             * To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
             *
             * You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
             * @deprecated
             */
            dependency_graph_enabled_for_new_repositories?: boolean;
            /**
             * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
             *
             * Whether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.
             *
             * To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
             *
             * You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
             * @deprecated
             */
            secret_scanning_enabled_for_new_repositories?: boolean;
            /**
             * **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.
             *
             * Whether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.
             *
             * To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
             *
             * You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
             * @deprecated
             */
            secret_scanning_push_protection_enabled_for_new_repositories?: boolean;
            /**
             * Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.
             */
            secret_scanning_push_protection_custom_link_enabled?: boolean;
            /**
             * If `secret_scanning_push_protection_custom_link_enabled` is true, the URL that will be displayed to contributors who are blocked from pushing a secret.
             */
            secret_scanning_push_protection_custom_link?: string;
            /**
             * Controls whether or not deploy keys may be added and used for repositories in the organization.
             */
            deploy_keys_enabled_for_repositories?: boolean;
        },
    ): CancelablePromise<organization_full> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/orgs/{org}',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                409: `Conflict`,
                422: `Validation failed`,
            },
        });
    }
    /**
     * Delete an organization
     * Deletes an organization and all its repositories.
     *
     * The organization login will be unavailable for 90 days after deletion.
     *
     * Please review the Terms of Service regarding account deletion before using this endpoint:
     *
     * https://docs.github.com/site-policy/github-terms/github-terms-of-service
     * @param org The organization name. The name is not case sensitive.
     * @returns any Accepted
     * @throws ApiError
     */
    public static orgsDelete(
        org: string,
    ): CancelablePromise<Record<string, any>> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}',
            path: {
                'org': org,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create an artifact deployment record
     * Create or update deployment records for an artifact associated with an organization.
     * This endpoint allows you to record information about a specific artifact, such as its name, digest, environments, cluster, and deployment.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns any Artifact deployment record stored successfully.
     * @throws ApiError
     */
    public static orgsCreateArtifactDeploymentRecord(
        org: string,
        requestBody: {
            /**
             * The name of the artifact.
             */
            name: string;
            /**
             * The hex encoded digest of the artifact.
             */
            digest: string;
            /**
             * The artifact version.
             */
            version?: string;
            /**
             * The status of the artifact. Can be either deployed or decommissioned.
             */
            status: 'deployed' | 'decommissioned';
            /**
             * The stage of the deployment.
             */
            logical_environment: string;
            /**
             * The physical region of the deployment.
             */
            physical_environment?: string;
            /**
             * The deployment cluster.
             */
            cluster?: string;
            /**
             * The name of the deployment.
             */
            deployment_name: string;
            /**
             * The tags associated with the deployment.
             */
            tags?: Record<string, string>;
            /**
             * A list of runtime risks associated with the deployment.
             */
            runtime_risks?: Array<'critical-resource' | 'internet-exposed' | 'lateral-movement' | 'sensitive-data'>;
            /**
             * The name of the GitHub repository associated with the artifact. This should be used
             * when there are no provenance attestations available for the artifact. The repository
             * must belong to the organization specified in the path parameter.
             *
             * If a provenance attestation is available for the artifact, the API will use
             * the repository information from the attestation instead of this parameter.
             */
            github_repository?: string;
        },
    ): CancelablePromise<{
        /**
         * The number of deployment records created
         */
        total_count?: number;
        deployment_records?: Array<artifact_deployment_record>;
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/artifacts/metadata/deployment-record',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Set cluster deployment records
     * Set deployment records for a given cluster.
     * @param org The organization name. The name is not case sensitive.
     * @param cluster The cluster name.
     * @param requestBody
     * @returns any Artifact deployment record stored successfully.
     * @throws ApiError
     */
    public static orgsSetClusterDeploymentRecords(
        org: string,
        cluster: string,
        requestBody: {
            /**
             * The stage of the deployment.
             */
            logical_environment: string;
            /**
             * The physical region of the deployment.
             */
            physical_environment?: string;
            /**
             * The list of deployments to record.
             */
            deployments: Array<{
                /**
                 * The name of the artifact. Note that if multiple deployments have identical 'digest' parameter values,
                 * the name parameter must also be identical across all entries.
                 *
                 */
                name: string;
                /**
                 * The hex encoded digest of the artifact. Note that if multiple deployments have identical 'digest' parameter values,
                 * the name and version parameters must also be identical across all entries.
                 *
                 */
                digest: string;
                /**
                 * The artifact version. Note that if multiple deployments have identical 'digest' parameter values,
                 * the version parameter must also be identical across all entries.
                 *
                 */
                version?: string;
                /**
                 * The deployment status of the artifact.
                 */
                status?: 'deployed' | 'decommissioned';
                /**
                 * The unique identifier for the deployment represented by the new record. To accommodate differing
                 * containers and namespaces within a record set, the following format is recommended:
                 * {namespaceName}-{deploymentName}-{containerName}
                 *
                 */
                deployment_name: string;
                /**
                 * The name of the GitHub repository associated with the artifact. This should be used
                 * when there are no provenance attestations available for the artifact. The repository
                 * must belong to the organization specified in the path parameter.
                 *
                 * If a provenance attestation is available for the artifact, the API will use
                 * the repository information from the attestation instead of this parameter.
                 */
                github_repository?: string;
                /**
                 * Key-value pairs to tag the deployment record.
                 */
                tags?: Record<string, string>;
                /**
                 * A list of runtime risks associated with the deployment.
                 */
                runtime_risks?: Array<'critical-resource' | 'internet-exposed' | 'lateral-movement' | 'sensitive-data'>;
            }>;
        },
    ): CancelablePromise<{
        /**
         * The number of deployment records created
         */
        total_count?: number;
        deployment_records?: Array<artifact_deployment_record>;
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/artifacts/metadata/deployment-record/cluster/{cluster}',
            path: {
                'org': org,
                'cluster': cluster,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Create artifact metadata storage record
     * Create metadata storage records for artifacts associated with an organization.
     * This endpoint will create a new artifact storage record on behalf of any artifact matching the provided digest and
     * associated with a repository owned by the organization.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns any Artifact metadata storage record stored successfully.
     * @throws ApiError
     */
    public static orgsCreateArtifactStorageRecord(
        org: string,
        requestBody: {
            /**
             * The name of the artifact.
             */
            name: string;
            /**
             * The digest of the artifact (algorithm:hex-encoded-digest).
             */
            digest: string;
            /**
             * The artifact version.
             */
            version?: string;
            /**
             * The URL where the artifact is stored.
             */
            artifact_url?: string;
            /**
             * The path of the artifact.
             */
            path?: string;
            /**
             * The base URL of the artifact registry.
             */
            registry_url: string;
            /**
             * The repository name within the registry.
             */
            repository?: string;
            /**
             * The status of the artifact (e.g., active, inactive).
             */
            status?: 'active' | 'eol' | 'deleted';
            /**
             * The name of the GitHub repository associated with the artifact. This should be used
             * when there are no provenance attestations available for the artifact. The repository
             * must belong to the organization specified in the path parameter.
             *
             * If a provenance attestation is available for the artifact, the API will use
             * the repository information from the attestation instead of this parameter.
             */
            github_repository?: string;
        },
    ): CancelablePromise<{
        total_count?: number;
        storage_records?: Array<{
            id?: number;
            name?: string;
            digest?: string;
            artifact_url?: string | null;
            registry_url?: string;
            repository?: string | null;
            status?: string;
            created_at?: string;
            updated_at?: string;
        }>;
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/artifacts/metadata/storage-record',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List artifact deployment records
     * List deployment records for an artifact metadata associated with an organization.
     * @param org The organization name. The name is not case sensitive.
     * @param subjectDigest The SHA256 digest of the artifact, in the form `sha256:HEX_DIGEST`.
     * @returns any Successful response
     * @throws ApiError
     */
    public static orgsListArtifactDeploymentRecords(
        org: string,
        subjectDigest: string,
    ): CancelablePromise<{
        /**
         * The number of deployment records for this digest and organization
         */
        total_count?: number;
        deployment_records?: Array<artifact_deployment_record>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/artifacts/{subject_digest}/metadata/deployment-records',
            path: {
                'org': org,
                'subject_digest': subjectDigest,
            },
        });
    }
    /**
     * List artifact storage records
     * List a collection of artifact storage records with a given subject digest that are associated with repositories owned by an organization.
     *
     * The collection of storage records returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `content:read` permission is required.
     * @param org The organization name. The name is not case sensitive.
     * @param subjectDigest The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.
     * @returns any Response
     * @throws ApiError
     */
    public static orgsListArtifactStorageRecords(
        org: string,
        subjectDigest: string,
    ): CancelablePromise<{
        /**
         * The number of storage records for this digest and organization
         */
        total_count?: number;
        storage_records?: Array<{
            id?: number;
            name?: string;
            digest?: string;
            artifact_url?: string;
            registry_url?: string;
            repository?: string;
            status?: string;
            created_at?: string;
            updated_at?: string;
        }>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/artifacts/{subject_digest}/metadata/storage-records',
            path: {
                'org': org,
                'subject_digest': subjectDigest,
            },
        });
    }
    /**
     * List attestations by bulk subject digests
     * List a collection of artifact attestations associated with any entry in a list of subject digests owned by an organization.
     *
     * The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `attestations:read` permission is required.
     *
     * **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param before A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param after A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static orgsListAttestationsBulk(
        org: string,
        requestBody: {
            /**
             * List of subject digests to fetch attestations for.
             */
            subject_digests: Array<string>;
            /**
             * Optional filter for fetching attestations with a given predicate type.
             * This option accepts `provenance`, `sbom`, `release`, or freeform text
             * for custom predicate types.
             */
            predicate_type?: string;
        },
        perPage: number = 30,
        before?: string,
        after?: string,
    ): CancelablePromise<{
        /**
         * Mapping of subject digest to bundles.
         */
        attestations_subject_digests?: Record<string, Array<{
            /**
             * The bundle of the attestation.
             */
            bundle?: {
                mediaType?: string;
                verificationMaterial?: Record<string, any>;
                dsseEnvelope?: Record<string, any>;
            };
            repository_id?: number;
            bundle_url?: string;
        }> | null>;
        /**
         * Information about the current page.
         */
        page_info?: {
            /**
             * Indicates whether there is a next page.
             */
            has_next?: boolean;
            /**
             * Indicates whether there is a previous page.
             */
            has_previous?: boolean;
            /**
             * The cursor to the next page.
             */
            next?: string;
            /**
             * The cursor to the previous page.
             */
            previous?: string;
        };
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/attestations/bulk-list',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'before': before,
                'after': after,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete attestations in bulk
     * Delete artifact attestations in bulk by either subject digests or unique ID.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static orgsDeleteAttestationsBulk(
        org: string,
        requestBody: any,
    ): CancelablePromise<any> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/attestations/delete-request',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete attestations by subject digest
     * Delete an artifact attestation by subject digest.
     * @param org The organization name. The name is not case sensitive.
     * @param subjectDigest Subject Digest
     * @returns any Response
     * @throws ApiError
     */
    public static orgsDeleteAttestationsBySubjectDigest(
        org: string,
        subjectDigest: string,
    ): CancelablePromise<any> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/attestations/digest/{subject_digest}',
            path: {
                'org': org,
                'subject_digest': subjectDigest,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List attestation repositories
     * List repositories owned by the provided organization that have created at least one attested artifact
     * Results will be sorted in ascending order by repository ID
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param before A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param after A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param predicateType Optional filter for fetching attestations with a given predicate type.
     * This option accepts `provenance`, `sbom`, `release`, or freeform text
     * for custom predicate types.
     * @returns any Response
     * @throws ApiError
     */
    public static orgsListAttestationRepositories(
        org: string,
        perPage: number = 30,
        before?: string,
        after?: string,
        predicateType?: string,
    ): CancelablePromise<Array<{
        id?: number;
        name?: string;
    }>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/attestations/repositories',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'before': before,
                'after': after,
                'predicate_type': predicateType,
            },
        });
    }
    /**
     * Delete attestations by ID
     * Delete an artifact attestation by unique ID that is associated with a repository owned by an org.
     * @param org The organization name. The name is not case sensitive.
     * @param attestationId Attestation ID
     * @returns any Response
     * @throws ApiError
     */
    public static orgsDeleteAttestationsById(
        org: string,
        attestationId: number,
    ): CancelablePromise<any> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/attestations/{attestation_id}',
            path: {
                'org': org,
                'attestation_id': attestationId,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List attestations
     * List a collection of artifact attestations with a given subject digest that are associated with repositories owned by an organization.
     *
     * The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `attestations:read` permission is required.
     *
     * **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
     * @param org The organization name. The name is not case sensitive.
     * @param subjectDigest The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param before A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param after A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param predicateType Optional filter for fetching attestations with a given predicate type.
     * This option accepts `provenance`, `sbom`, `release`, or freeform text
     * for custom predicate types.
     * @returns any Response
     * @throws ApiError
     */
    public static orgsListAttestations(
        org: string,
        subjectDigest: string,
        perPage: number = 30,
        before?: string,
        after?: string,
        predicateType?: string,
    ): CancelablePromise<{
        attestations?: Array<{
            /**
             * The attestation's Sigstore Bundle.
             * Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.
             */
            bundle?: {
                mediaType?: string;
                verificationMaterial?: Record<string, any>;
                dsseEnvelope?: Record<string, any>;
            };
            repository_id?: number;
            bundle_url?: string;
            initiator?: string;
        }>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/attestations/{subject_digest}',
            path: {
                'org': org,
                'subject_digest': subjectDigest,
            },
            query: {
                'per_page': perPage,
                'before': before,
                'after': after,
                'predicate_type': predicateType,
            },
        });
    }
    /**
     * List users blocked by an organization
     * List the users blocked by an organization.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static orgsListBlockedUsers(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/blocks',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Check if a user is blocked by an organization
     * Returns a 204 if the given user is blocked by the given organization. Returns a 404 if the organization is not blocking the user, or if the user account has been identified as spam by GitHub.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsCheckBlockedUser(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/blocks/{username}',
            path: {
                'org': org,
                'username': username,
            },
            errors: {
                404: `If the user is not blocked`,
            },
        });
    }
    /**
     * Block a user from an organization
     * Blocks the given user on behalf of the specified organization and returns a 204. If the organization cannot block the given user a 422 is returned.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsBlockUser(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/blocks/{username}',
            path: {
                'org': org,
                'username': username,
            },
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Unblock a user from an organization
     * Unblocks the given user on behalf of the specified organization.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsUnblockUser(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/blocks/{username}',
            path: {
                'org': org,
                'username': username,
            },
        });
    }
    /**
     * List failed organization invitations
     * The return hash contains `failed_at` and `failed_reason` fields which represent the time at which the invitation failed and the reason for the failure.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns organization_invitation Response
     * @throws ApiError
     */
    public static orgsListFailedInvitations(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<organization_invitation>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/failed_invitations',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List organization webhooks
     * List webhooks for an organization.
     *
     * The authenticated user must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns org_hook Response
     * @throws ApiError
     */
    public static orgsListWebhooks(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<org_hook>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/hooks',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create an organization webhook
     * Create a hook that posts payloads in JSON format.
     *
     * You must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or
     * edit webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns org_hook Response
     * @throws ApiError
     */
    public static orgsCreateWebhook(
        org: string,
        requestBody: {
            /**
             * Must be passed as "web".
             */
            name: string;
            /**
             * Key/value pairs to provide settings for this webhook.
             */
            config: {
                url: webhook_config_url;
                content_type?: webhook_config_content_type;
                secret?: webhook_config_secret;
                insecure_ssl?: webhook_config_insecure_ssl;
                username?: string;
                password?: string;
            };
            /**
             * Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `["*"]` to receive all possible events.
             */
            events?: Array<string>;
            /**
             * Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
             */
            active?: boolean;
        },
    ): CancelablePromise<org_hook> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/hooks',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get an organization webhook
     * Returns a webhook configured in an organization. To get only the webhook
     * `config` properties, see "[Get a webhook configuration for an organization](/rest/orgs/webhooks#get-a-webhook-configuration-for-an-organization).
     *
     * You must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @returns org_hook Response
     * @throws ApiError
     */
    public static orgsGetWebhook(
        org: string,
        hookId: number,
    ): CancelablePromise<org_hook> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/hooks/{hook_id}',
            path: {
                'org': org,
                'hook_id': hookId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update an organization webhook
     * Updates a webhook configured in an organization. When you update a webhook,
     * the `secret` will be overwritten. If you previously had a `secret` set, you must
     * provide the same `secret` or set a new `secret` or the secret will be removed. If
     * you are only updating individual webhook `config` properties, use "[Update a webhook
     * configuration for an organization](/rest/orgs/webhooks#update-a-webhook-configuration-for-an-organization)".
     *
     * You must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param requestBody
     * @returns org_hook Response
     * @throws ApiError
     */
    public static orgsUpdateWebhook(
        org: string,
        hookId: number,
        requestBody?: {
            /**
             * Key/value pairs to provide settings for this webhook.
             */
            config?: {
                url: webhook_config_url;
                content_type?: webhook_config_content_type;
                secret?: webhook_config_secret;
                insecure_ssl?: webhook_config_insecure_ssl;
            };
            /**
             * Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.
             */
            events?: Array<string>;
            /**
             * Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
             */
            active?: boolean;
            name?: string;
        },
    ): CancelablePromise<org_hook> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/orgs/{org}/hooks/{hook_id}',
            path: {
                'org': org,
                'hook_id': hookId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete an organization webhook
     * Delete a webhook for an organization.
     *
     * The authenticated user must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @returns void
     * @throws ApiError
     */
    public static orgsDeleteWebhook(
        org: string,
        hookId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/hooks/{hook_id}',
            path: {
                'org': org,
                'hook_id': hookId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a webhook configuration for an organization
     * Returns the webhook configuration for an organization. To get more information about the webhook, including the `active` state and `events`, use "[Get an organization webhook ](/rest/orgs/webhooks#get-an-organization-webhook)."
     *
     * You must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @returns webhook_config Response
     * @throws ApiError
     */
    public static orgsGetWebhookConfigForOrg(
        org: string,
        hookId: number,
    ): CancelablePromise<webhook_config> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/hooks/{hook_id}/config',
            path: {
                'org': org,
                'hook_id': hookId,
            },
        });
    }
    /**
     * Update a webhook configuration for an organization
     * Updates the webhook configuration for an organization. To update more information about the webhook, including the `active` state and `events`, use "[Update an organization webhook ](/rest/orgs/webhooks#update-an-organization-webhook)."
     *
     * You must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param requestBody
     * @returns webhook_config Response
     * @throws ApiError
     */
    public static orgsUpdateWebhookConfigForOrg(
        org: string,
        hookId: number,
        requestBody?: {
            url?: webhook_config_url;
            content_type?: webhook_config_content_type;
            secret?: webhook_config_secret;
            insecure_ssl?: webhook_config_insecure_ssl;
        },
    ): CancelablePromise<webhook_config> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/orgs/{org}/hooks/{hook_id}/config',
            path: {
                'org': org,
                'hook_id': hookId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List deliveries for an organization webhook
     * Returns a list of webhook deliveries for a webhook configured in an organization.
     *
     * You must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param cursor Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
     * @returns hook_delivery_item Response
     * @throws ApiError
     */
    public static orgsListWebhookDeliveries(
        org: string,
        hookId: number,
        perPage: number = 30,
        cursor?: string,
    ): CancelablePromise<Array<hook_delivery_item>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/hooks/{hook_id}/deliveries',
            path: {
                'org': org,
                'hook_id': hookId,
            },
            query: {
                'per_page': perPage,
                'cursor': cursor,
            },
            errors: {
                400: `Bad Request`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a webhook delivery for an organization webhook
     * Returns a delivery for a webhook configured in an organization.
     *
     * You must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param deliveryId
     * @returns hook_delivery Response
     * @throws ApiError
     */
    public static orgsGetWebhookDelivery(
        org: string,
        hookId: number,
        deliveryId: number,
    ): CancelablePromise<hook_delivery> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}',
            path: {
                'org': org,
                'hook_id': hookId,
                'delivery_id': deliveryId,
            },
            errors: {
                400: `Bad Request`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Redeliver a delivery for an organization webhook
     * Redeliver a delivery for a webhook configured in an organization.
     *
     * You must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param deliveryId
     * @returns any Accepted
     * @throws ApiError
     */
    public static orgsRedeliverWebhookDelivery(
        org: string,
        hookId: number,
        deliveryId: number,
    ): CancelablePromise<Record<string, any>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts',
            path: {
                'org': org,
                'hook_id': hookId,
                'delivery_id': deliveryId,
            },
            errors: {
                400: `Bad Request`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Ping an organization webhook
     * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event)
     * to be sent to the hook.
     *
     * You must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need `admin:org_hook` scope. OAuth apps cannot list, view, or edit
     * webhooks that they did not create and users cannot list, view, or edit webhooks that were created by OAuth apps.
     * @param org The organization name. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @returns void
     * @throws ApiError
     */
    public static orgsPingWebhook(
        org: string,
        hookId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/hooks/{hook_id}/pings',
            path: {
                'org': org,
                'hook_id': hookId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get route stats by actor
     * Get API request count statistics for an actor broken down by route within a specified time frame.
     * @param org The organization name. The name is not case sensitive.
     * @param actorType The type of the actor
     * @param actorId The ID of the actor
     * @param minTimestamp The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param maxTimestamp The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param direction The direction to sort the results by.
     * @param sort The property to sort the results by.
     * @param apiRouteSubstring Providing a substring will filter results where the API route contains the substring. This is a case-insensitive search.
     * @returns api_insights_route_stats Response
     * @throws ApiError
     */
    public static apiInsightsGetRouteStatsByActor(
        org: string,
        actorType: 'installation' | 'classic_pat' | 'fine_grained_pat' | 'oauth_app' | 'github_app_user_to_server',
        actorId: number,
        minTimestamp: string,
        maxTimestamp?: string,
        page: number = 1,
        perPage: number = 30,
        direction: 'asc' | 'desc' = 'desc',
        sort?: Array<'last_rate_limited_timestamp' | 'last_request_timestamp' | 'rate_limited_request_count' | 'http_method' | 'api_route' | 'total_request_count'>,
        apiRouteSubstring?: string,
    ): CancelablePromise<api_insights_route_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/insights/api/route-stats/{actor_type}/{actor_id}',
            path: {
                'org': org,
                'actor_type': actorType,
                'actor_id': actorId,
            },
            query: {
                'min_timestamp': minTimestamp,
                'max_timestamp': maxTimestamp,
                'page': page,
                'per_page': perPage,
                'direction': direction,
                'sort': sort,
                'api_route_substring': apiRouteSubstring,
            },
        });
    }
    /**
     * Get subject stats
     * Get API request statistics for all subjects within an organization within a specified time frame. Subjects can be users or GitHub Apps.
     * @param org The organization name. The name is not case sensitive.
     * @param minTimestamp The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param maxTimestamp The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param direction The direction to sort the results by.
     * @param sort The property to sort the results by.
     * @param subjectNameSubstring Providing a substring will filter results where the subject name contains the substring. This is a case-insensitive search.
     * @returns api_insights_subject_stats Response
     * @throws ApiError
     */
    public static apiInsightsGetSubjectStats(
        org: string,
        minTimestamp: string,
        maxTimestamp?: string,
        page: number = 1,
        perPage: number = 30,
        direction: 'asc' | 'desc' = 'desc',
        sort?: Array<'last_rate_limited_timestamp' | 'last_request_timestamp' | 'rate_limited_request_count' | 'subject_name' | 'total_request_count'>,
        subjectNameSubstring?: string,
    ): CancelablePromise<api_insights_subject_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/insights/api/subject-stats',
            path: {
                'org': org,
            },
            query: {
                'min_timestamp': minTimestamp,
                'max_timestamp': maxTimestamp,
                'page': page,
                'per_page': perPage,
                'direction': direction,
                'sort': sort,
                'subject_name_substring': subjectNameSubstring,
            },
        });
    }
    /**
     * Get summary stats
     * Get overall statistics of API requests made within an organization by all users and apps within a specified time frame.
     * @param org The organization name. The name is not case sensitive.
     * @param minTimestamp The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param maxTimestamp The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @returns api_insights_summary_stats Response
     * @throws ApiError
     */
    public static apiInsightsGetSummaryStats(
        org: string,
        minTimestamp: string,
        maxTimestamp?: string,
    ): CancelablePromise<api_insights_summary_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/insights/api/summary-stats',
            path: {
                'org': org,
            },
            query: {
                'min_timestamp': minTimestamp,
                'max_timestamp': maxTimestamp,
            },
        });
    }
    /**
     * Get summary stats by user
     * Get overall statistics of API requests within the organization for a user.
     * @param org The organization name. The name is not case sensitive.
     * @param userId The ID of the user to query for stats
     * @param minTimestamp The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param maxTimestamp The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @returns api_insights_summary_stats Response
     * @throws ApiError
     */
    public static apiInsightsGetSummaryStatsByUser(
        org: string,
        userId: string,
        minTimestamp: string,
        maxTimestamp?: string,
    ): CancelablePromise<api_insights_summary_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/insights/api/summary-stats/users/{user_id}',
            path: {
                'org': org,
                'user_id': userId,
            },
            query: {
                'min_timestamp': minTimestamp,
                'max_timestamp': maxTimestamp,
            },
        });
    }
    /**
     * Get summary stats by actor
     * Get overall statistics of API requests within the organization made by a specific actor. Actors can be GitHub App installations, OAuth apps or other tokens on behalf of a user.
     * @param org The organization name. The name is not case sensitive.
     * @param minTimestamp The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param actorType The type of the actor
     * @param actorId The ID of the actor
     * @param maxTimestamp The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @returns api_insights_summary_stats Response
     * @throws ApiError
     */
    public static apiInsightsGetSummaryStatsByActor(
        org: string,
        minTimestamp: string,
        actorType: 'installation' | 'classic_pat' | 'fine_grained_pat' | 'oauth_app' | 'github_app_user_to_server',
        actorId: number,
        maxTimestamp?: string,
    ): CancelablePromise<api_insights_summary_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/insights/api/summary-stats/{actor_type}/{actor_id}',
            path: {
                'org': org,
                'actor_type': actorType,
                'actor_id': actorId,
            },
            query: {
                'min_timestamp': minTimestamp,
                'max_timestamp': maxTimestamp,
            },
        });
    }
    /**
     * Get time stats
     * Get the number of API requests and rate-limited requests made within an organization over a specified time period.
     * @param org The organization name. The name is not case sensitive.
     * @param minTimestamp The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param timestampIncrement The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)
     * @param maxTimestamp The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @returns api_insights_time_stats Response
     * @throws ApiError
     */
    public static apiInsightsGetTimeStats(
        org: string,
        minTimestamp: string,
        timestampIncrement: string,
        maxTimestamp?: string,
    ): CancelablePromise<api_insights_time_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/insights/api/time-stats',
            path: {
                'org': org,
            },
            query: {
                'min_timestamp': minTimestamp,
                'max_timestamp': maxTimestamp,
                'timestamp_increment': timestampIncrement,
            },
        });
    }
    /**
     * Get time stats by user
     * Get the number of API requests and rate-limited requests made within an organization by a specific user over a specified time period.
     * @param org The organization name. The name is not case sensitive.
     * @param userId The ID of the user to query for stats
     * @param minTimestamp The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param timestampIncrement The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)
     * @param maxTimestamp The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @returns api_insights_time_stats Response
     * @throws ApiError
     */
    public static apiInsightsGetTimeStatsByUser(
        org: string,
        userId: string,
        minTimestamp: string,
        timestampIncrement: string,
        maxTimestamp?: string,
    ): CancelablePromise<api_insights_time_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/insights/api/time-stats/users/{user_id}',
            path: {
                'org': org,
                'user_id': userId,
            },
            query: {
                'min_timestamp': minTimestamp,
                'max_timestamp': maxTimestamp,
                'timestamp_increment': timestampIncrement,
            },
        });
    }
    /**
     * Get time stats by actor
     * Get the number of API requests and rate-limited requests made within an organization by a specific actor within a specified time period.
     * @param org The organization name. The name is not case sensitive.
     * @param actorType The type of the actor
     * @param actorId The ID of the actor
     * @param minTimestamp The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param timestampIncrement The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)
     * @param maxTimestamp The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @returns api_insights_time_stats Response
     * @throws ApiError
     */
    public static apiInsightsGetTimeStatsByActor(
        org: string,
        actorType: 'installation' | 'classic_pat' | 'fine_grained_pat' | 'oauth_app' | 'github_app_user_to_server',
        actorId: number,
        minTimestamp: string,
        timestampIncrement: string,
        maxTimestamp?: string,
    ): CancelablePromise<api_insights_time_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/insights/api/time-stats/{actor_type}/{actor_id}',
            path: {
                'org': org,
                'actor_type': actorType,
                'actor_id': actorId,
            },
            query: {
                'min_timestamp': minTimestamp,
                'max_timestamp': maxTimestamp,
                'timestamp_increment': timestampIncrement,
            },
        });
    }
    /**
     * Get user stats
     * Get API usage statistics within an organization for a user broken down by the type of access.
     * @param org The organization name. The name is not case sensitive.
     * @param userId The ID of the user to query for stats
     * @param minTimestamp The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param maxTimestamp The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param direction The direction to sort the results by.
     * @param sort The property to sort the results by.
     * @param actorNameSubstring Providing a substring will filter results where the actor name contains the substring. This is a case-insensitive search.
     * @returns api_insights_user_stats Response
     * @throws ApiError
     */
    public static apiInsightsGetUserStats(
        org: string,
        userId: string,
        minTimestamp: string,
        maxTimestamp?: string,
        page: number = 1,
        perPage: number = 30,
        direction: 'asc' | 'desc' = 'desc',
        sort?: Array<'last_rate_limited_timestamp' | 'last_request_timestamp' | 'rate_limited_request_count' | 'subject_name' | 'total_request_count'>,
        actorNameSubstring?: string,
    ): CancelablePromise<api_insights_user_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/insights/api/user-stats/{user_id}',
            path: {
                'org': org,
                'user_id': userId,
            },
            query: {
                'min_timestamp': minTimestamp,
                'max_timestamp': maxTimestamp,
                'page': page,
                'per_page': perPage,
                'direction': direction,
                'sort': sort,
                'actor_name_substring': actorNameSubstring,
            },
        });
    }
    /**
     * List app installations for an organization
     * Lists all GitHub Apps in an organization. The installation count includes
     * all GitHub Apps installed on repositories in the organization.
     *
     * The authenticated user must be an organization owner to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:read` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static orgsListAppInstallations(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        total_count: number;
        installations: Array<installation>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/installations',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List pending organization invitations
     * The return hash contains a `role` field which refers to the Organization
     * Invitation role and will be one of the following values: `direct_member`, `admin`,
     * `billing_manager`, or `hiring_manager`. If the invitee is not a GitHub
     * member, the `login` field in the return hash will be `null`.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param role Filter invitations by their member role.
     * @param invitationSource Filter invitations by their invitation source.
     * @returns organization_invitation Response
     * @throws ApiError
     */
    public static orgsListPendingInvitations(
        org: string,
        perPage: number = 30,
        page: number = 1,
        role: 'all' | 'admin' | 'direct_member' | 'billing_manager' | 'hiring_manager' = 'all',
        invitationSource: 'all' | 'member' | 'scim' = 'all',
    ): CancelablePromise<Array<organization_invitation>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/invitations',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'role': role,
                'invitation_source': invitationSource,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create an organization invitation
     * Invite people to an organization by using their GitHub user ID or their email address. In order to create invitations in an organization, the authenticated user must be an organization owner.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
     * and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns organization_invitation Response
     * @throws ApiError
     */
    public static orgsCreateInvitation(
        org: string,
        requestBody?: {
            /**
             * **Required unless you provide `email`**. GitHub user ID for the person you are inviting.
             */
            invitee_id?: number;
            /**
             * **Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user.
             */
            email?: string;
            /**
             * The role for the new member.
             * * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.
             * * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.
             * * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.
             * * `reinstate` - The previous role assigned to the invitee before they were removed from your organization. Can be one of the roles listed above. Only works if the invitee was previously part of your organization.
             */
            role?: 'admin' | 'direct_member' | 'billing_manager' | 'reinstate';
            /**
             * Specify IDs for the teams you want to invite new members to.
             */
            team_ids?: Array<number>;
        },
    ): CancelablePromise<organization_invitation> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/invitations',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Cancel an organization invitation
     * Cancel an organization invitation. In order to cancel an organization invitation, the authenticated user must be an organization owner.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * @param org The organization name. The name is not case sensitive.
     * @param invitationId The unique identifier of the invitation.
     * @returns void
     * @throws ApiError
     */
    public static orgsCancelInvitation(
        org: string,
        invitationId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/invitations/{invitation_id}',
            path: {
                'org': org,
                'invitation_id': invitationId,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List organization invitation teams
     * List all teams associated with an invitation. In order to see invitations in an organization, the authenticated user must be an organization owner.
     * @param org The organization name. The name is not case sensitive.
     * @param invitationId The unique identifier of the invitation.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns team Response
     * @throws ApiError
     */
    public static orgsListInvitationTeams(
        org: string,
        invitationId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<team>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/invitations/{invitation_id}/teams',
            path: {
                'org': org,
                'invitation_id': invitationId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List issue types for an organization
     * Lists all issue types for an organization. OAuth app tokens and personal access tokens (classic) need the read:org scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns issue_type Response
     * @throws ApiError
     */
    public static orgsListIssueTypes(
        org: string,
    ): CancelablePromise<Array<issue_type>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/issue-types',
            path: {
                'org': org,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create issue type for an organization
     * Create a new issue type for an organization.
     *
     * You can find out more about issue types in [Managing issue types in an organization](https://docs.github.com/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization).
     *
     * To use this endpoint, the authenticated user must be an administrator for the organization. OAuth app tokens and
     * personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns issue_type Response
     * @throws ApiError
     */
    public static orgsCreateIssueType(
        org: string,
        requestBody: organization_create_issue_type,
    ): CancelablePromise<issue_type> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/issue-types',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Update issue type for an organization
     * Updates an issue type for an organization.
     *
     * You can find out more about issue types in [Managing issue types in an organization](https://docs.github.com/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization).
     *
     * To use this endpoint, the authenticated user must be an administrator for the organization. OAuth app tokens and
     * personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param issueTypeId The unique identifier of the issue type.
     * @param requestBody
     * @returns issue_type Response
     * @throws ApiError
     */
    public static orgsUpdateIssueType(
        org: string,
        issueTypeId: number,
        requestBody: organization_update_issue_type,
    ): CancelablePromise<issue_type> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/issue-types/{issue_type_id}',
            path: {
                'org': org,
                'issue_type_id': issueTypeId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete issue type for an organization
     * Deletes an issue type for an organization.
     *
     * You can find out more about issue types in [Managing issue types in an organization](https://docs.github.com/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization).
     *
     * To use this endpoint, the authenticated user must be an administrator for the organization. OAuth app tokens and
     * personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param issueTypeId The unique identifier of the issue type.
     * @returns void
     * @throws ApiError
     */
    public static orgsDeleteIssueType(
        org: string,
        issueTypeId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/issue-types/{issue_type_id}',
            path: {
                'org': org,
                'issue_type_id': issueTypeId,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List organization members
     * List all users who are members of an organization. If the authenticated user is also a member of this organization then both concealed and public members will be returned.
     * @param org The organization name. The name is not case sensitive.
     * @param filter Filter members returned in the list. `2fa_disabled` means that only members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. `2fa_insecure` means that only members with [insecure 2FA methods](https://docs.github.com/organizations/keeping-your-organization-secure/managing-two-factor-authentication-for-your-organization/requiring-two-factor-authentication-in-your-organization#requiring-secure-methods-of-two-factor-authentication-in-your-organization) will be returned. These options are only available for organization owners.
     * @param role Filter members returned by their role.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static orgsListMembers(
        org: string,
        filter: '2fa_disabled' | '2fa_insecure' | 'all' = 'all',
        role: 'all' | 'admin' | 'member' = 'all',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/members',
            path: {
                'org': org,
            },
            query: {
                'filter': filter,
                'role': role,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Check organization membership for a user
     * Check if a user is, publicly or privately, a member of the organization.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsCheckMembershipForUser(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/members/{username}',
            path: {
                'org': org,
                'username': username,
            },
            errors: {
                302: `Response if requester is not an organization member`,
                404: `Not Found if requester is an organization member and user is not a member`,
            },
        });
    }
    /**
     * Remove an organization member
     * Removing a user from this list will remove them from all teams and they will no longer have any access to the organization's repositories.
     *
     * > [!NOTE]
     * > If a user has both direct membership in the organization as well as indirect membership via an enterprise team, only their direct membership will be removed. Their indirect membership via an enterprise team remains until the user is removed from the enterprise team.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsRemoveMember(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/members/{username}',
            path: {
                'org': org,
                'username': username,
            },
            errors: {
                403: `Forbidden`,
            },
        });
    }
    /**
     * Get organization membership for a user
     * In order to get a user's membership with an organization, the authenticated user must be an organization member. The `state` parameter in the response can be used to identify the user's membership status.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns org_membership Response
     * @throws ApiError
     */
    public static orgsGetMembershipForUser(
        org: string,
        username: string,
    ): CancelablePromise<org_membership> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/memberships/{username}',
            path: {
                'org': org,
                'username': username,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set organization membership for a user
     * Only authenticated organization owners can add a member to the organization or update the member's role.
     *
     * *   If the authenticated user is _adding_ a member to the organization, the invited user will receive an email inviting them to the organization. The user's [membership status](https://docs.github.com/rest/orgs/members#get-organization-membership-for-a-user) will be `pending` until they accept the invitation.
     *
     * *   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the authenticated user changes a member's role to `admin`, the affected user will receive an email notifying them that they've been made an organization owner. If the authenticated user changes an owner's role to `member`, no email will be sent.
     *
     * **Rate limits**
     *
     * To prevent abuse, organization owners are limited to creating 50 organization invitations for an organization within a 24 hour period. If the organization is more than one month old or on a paid plan, the limit is 500 invitations per 24 hour period.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @param requestBody
     * @returns org_membership Response
     * @throws ApiError
     */
    public static orgsSetMembershipForUser(
        org: string,
        username: string,
        requestBody?: {
            /**
             * The role to give the user in the organization. Can be one of:
             * * `admin` - The user will become an owner of the organization.
             * * `member` - The user will become a non-owner member of the organization.
             */
            role?: 'admin' | 'member';
        },
    ): CancelablePromise<org_membership> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/memberships/{username}',
            path: {
                'org': org,
                'username': username,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove organization membership for a user
     * In order to remove a user's membership with an organization, the authenticated user must be an organization owner.
     *
     * If the specified user is an active member of the organization, this will remove them from the organization. If the specified user has been invited to the organization, this will cancel their invitation. The specified user will receive an email notification in both cases.
     *
     * > [!NOTE]
     * > If a user has both direct membership in the organization as well as indirect membership via an enterprise team, only their direct membership will be removed. Their indirect membership via an enterprise team remains until the user is removed from the enterprise team.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsRemoveMembershipForUser(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/memberships/{username}',
            path: {
                'org': org,
                'username': username,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get all organization roles for an organization
     * Lists the organization roles available in this organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * To use this endpoint, the authenticated user must be one of:
     *
     * - An administrator for the organization.
     * - A user, or a user on a team, with the fine-grained permissions of `read_organization_custom_org_role` in the organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns any Response - list of organization roles
     * @throws ApiError
     */
    public static orgsListOrgRoles(
        org: string,
    ): CancelablePromise<{
        /**
         * The total number of organization roles available to the organization.
         */
        total_count?: number;
        /**
         * The list of organization roles available to the organization.
         */
        roles?: Array<organization_role>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/organization-roles',
            path: {
                'org': org,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove all organization roles for a team
     * Removes all assigned organization roles from a team. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * The authenticated user must be an administrator for the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @returns void
     * @throws ApiError
     */
    public static orgsRevokeAllOrgRolesTeam(
        org: string,
        teamSlug: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/organization-roles/teams/{team_slug}',
            path: {
                'org': org,
                'team_slug': teamSlug,
            },
        });
    }
    /**
     * Assign an organization role to a team
     * Assigns an organization role to a team in an organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * The authenticated user must be an administrator for the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @param roleId The unique identifier of the role.
     * @returns void
     * @throws ApiError
     */
    public static orgsAssignTeamToOrgRole(
        org: string,
        teamSlug: string,
        roleId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/organization-roles/teams/{team_slug}/{role_id}',
            path: {
                'org': org,
                'team_slug': teamSlug,
                'role_id': roleId,
            },
            errors: {
                404: `Response if the organization, team or role does not exist.`,
                422: `Response if the organization roles feature is not enabled for the organization, or validation failed.`,
            },
        });
    }
    /**
     * Remove an organization role from a team
     * Removes an organization role from a team. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * The authenticated user must be an administrator for the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @param roleId The unique identifier of the role.
     * @returns void
     * @throws ApiError
     */
    public static orgsRevokeOrgRoleTeam(
        org: string,
        teamSlug: string,
        roleId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/organization-roles/teams/{team_slug}/{role_id}',
            path: {
                'org': org,
                'team_slug': teamSlug,
                'role_id': roleId,
            },
        });
    }
    /**
     * Remove all organization roles for a user
     * Revokes all assigned organization roles from a user. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * The authenticated user must be an administrator for the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsRevokeAllOrgRolesUser(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/organization-roles/users/{username}',
            path: {
                'org': org,
                'username': username,
            },
        });
    }
    /**
     * Assign an organization role to a user
     * Assigns an organization role to a member of an organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * The authenticated user must be an administrator for the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @param roleId The unique identifier of the role.
     * @returns void
     * @throws ApiError
     */
    public static orgsAssignUserToOrgRole(
        org: string,
        username: string,
        roleId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/organization-roles/users/{username}/{role_id}',
            path: {
                'org': org,
                'username': username,
                'role_id': roleId,
            },
            errors: {
                404: `Response if the organization, user or role does not exist.`,
                422: `Response if the organization roles feature is not enabled enabled for the organization, the validation failed, or the user is not an organization member.`,
            },
        });
    }
    /**
     * Remove an organization role from a user
     * Remove an organization role from a user. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * The authenticated user must be an administrator for the organization to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @param roleId The unique identifier of the role.
     * @returns void
     * @throws ApiError
     */
    public static orgsRevokeOrgRoleUser(
        org: string,
        username: string,
        roleId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/organization-roles/users/{username}/{role_id}',
            path: {
                'org': org,
                'username': username,
                'role_id': roleId,
            },
        });
    }
    /**
     * Get an organization role
     * Gets an organization role that is available to this organization. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * To use this endpoint, the authenticated user must be one of:
     *
     * - An administrator for the organization.
     * - A user, or a user on a team, with the fine-grained permissions of `read_organization_custom_org_role` in the organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param roleId The unique identifier of the role.
     * @returns organization_role Response
     * @throws ApiError
     */
    public static orgsGetOrgRole(
        org: string,
        roleId: number,
    ): CancelablePromise<organization_role> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/organization-roles/{role_id}',
            path: {
                'org': org,
                'role_id': roleId,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List teams that are assigned to an organization role
     * Lists the teams that are assigned to an organization role. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * To use this endpoint, you must be an administrator for the organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param roleId The unique identifier of the role.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns team_role_assignment Response - List of assigned teams
     * @throws ApiError
     */
    public static orgsListOrgRoleTeams(
        org: string,
        roleId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<team_role_assignment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/organization-roles/{role_id}/teams',
            path: {
                'org': org,
                'role_id': roleId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Response if the organization or role does not exist.`,
                422: `Response if the organization roles feature is not enabled or validation failed.`,
            },
        });
    }
    /**
     * List users that are assigned to an organization role
     * Lists organization members that are assigned to an organization role. For more information on organization roles, see "[Using organization roles](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles)."
     *
     * To use this endpoint, you must be an administrator for the organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param roleId The unique identifier of the role.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns user_role_assignment Response - List of assigned users
     * @throws ApiError
     */
    public static orgsListOrgRoleUsers(
        org: string,
        roleId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<user_role_assignment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/organization-roles/{role_id}/users',
            path: {
                'org': org,
                'role_id': roleId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Response if the organization or role does not exist.`,
                422: `Response if the organization roles feature is not enabled or validation failed.`,
            },
        });
    }
    /**
     * List outside collaborators for an organization
     * List all users who are outside collaborators of an organization.
     * @param org The organization name. The name is not case sensitive.
     * @param filter Filter the list of outside collaborators. `2fa_disabled` means that only outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. `2fa_insecure` means that only outside collaborators with [insecure 2FA methods](https://docs.github.com/organizations/keeping-your-organization-secure/managing-two-factor-authentication-for-your-organization/requiring-two-factor-authentication-in-your-organization#requiring-secure-methods-of-two-factor-authentication-in-your-organization) will be returned.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static orgsListOutsideCollaborators(
        org: string,
        filter: '2fa_disabled' | '2fa_insecure' | 'all' = 'all',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/outside_collaborators',
            path: {
                'org': org,
            },
            query: {
                'filter': filter,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Convert an organization member to outside collaborator
     * When an organization member is converted to an outside collaborator, they'll only have access to the repositories that their current team membership allows. The user will no longer be a member of the organization. For more information, see "[Converting an organization member to an outside collaborator](https://docs.github.com/articles/converting-an-organization-member-to-an-outside-collaborator/)". Converting an organization member to an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @param requestBody
     * @returns any User is getting converted asynchronously
     * @throws ApiError
     */
    public static orgsConvertMemberToOutsideCollaborator(
        org: string,
        username: string,
        requestBody?: {
            /**
             * When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.
             */
            async?: boolean;
        },
    ): CancelablePromise<any> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/outside_collaborators/{username}',
            path: {
                'org': org,
                'username': username,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden if user is the last owner of the organization, not a member of the organization, or if the enterprise enforces a policy for inviting outside collaborators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Remove outside collaborator from an organization
     * Removing a user from this list will remove them from all the organization's repositories.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsRemoveOutsideCollaborator(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/outside_collaborators/{username}',
            path: {
                'org': org,
                'username': username,
            },
            errors: {
                422: `Unprocessable Entity if user is a member of the organization`,
            },
        });
    }
    /**
     * List requests to access organization resources with fine-grained personal access tokens
     * Lists requests from organization members to access organization resources with a fine-grained personal access token.
     *
     * Only GitHub Apps can use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param sort The property by which to sort the results.
     * @param direction The direction to sort the results by.
     * @param owner A list of owner usernames to use to filter the results.
     * @param repository The name of the repository to use to filter the results.
     * @param permission The permission to use to filter the results.
     * @param lastUsedBefore Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param lastUsedAfter Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param tokenId The ID of the token
     * @returns organization_programmatic_access_grant_request Response
     * @throws ApiError
     */
    public static orgsListPatGrantRequests(
        org: string,
        perPage: number = 30,
        page: number = 1,
        sort: 'created_at' = 'created_at',
        direction: 'asc' | 'desc' = 'desc',
        owner?: Array<string>,
        repository?: string,
        permission?: string,
        lastUsedBefore?: string,
        lastUsedAfter?: string,
        tokenId?: Array<string>,
    ): CancelablePromise<Array<organization_programmatic_access_grant_request>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/personal-access-token-requests',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'sort': sort,
                'direction': direction,
                'owner': owner,
                'repository': repository,
                'permission': permission,
                'last_used_before': lastUsedBefore,
                'last_used_after': lastUsedAfter,
                'token_id': tokenId,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Review requests to access organization resources with fine-grained personal access tokens
     * Approves or denies multiple pending requests to access organization resources via a fine-grained personal access token.
     *
     * Only GitHub Apps can use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns any Accepted
     * @throws ApiError
     */
    public static orgsReviewPatGrantRequestsInBulk(
        org: string,
        requestBody: {
            /**
             * Unique identifiers of the requests for access via fine-grained personal access token. Must be formed of between 1 and 100 `pat_request_id` values.
             */
            pat_request_ids?: Array<number>;
            /**
             * Action to apply to the requests.
             */
            action: 'approve' | 'deny';
            /**
             * Reason for approving or denying the requests. Max 1024 characters.
             */
            reason?: string | null;
        },
    ): CancelablePromise<Record<string, any>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/personal-access-token-requests',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Review a request to access organization resources with a fine-grained personal access token
     * Approves or denies a pending request to access organization resources via a fine-grained personal access token.
     *
     * Only GitHub Apps can use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param patRequestId Unique identifier of the request for access via fine-grained personal access token.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static orgsReviewPatGrantRequest(
        org: string,
        patRequestId: number,
        requestBody: {
            /**
             * Action to apply to the request.
             */
            action: 'approve' | 'deny';
            /**
             * Reason for approving or denying the request. Max 1024 characters.
             */
            reason?: string | null;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/personal-access-token-requests/{pat_request_id}',
            path: {
                'org': org,
                'pat_request_id': patRequestId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * List repositories requested to be accessed by a fine-grained personal access token
     * Lists the repositories a fine-grained personal access token request is requesting access to.
     *
     * Only GitHub Apps can use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param patRequestId Unique identifier of the request for access via fine-grained personal access token.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns minimal_repository Response
     * @throws ApiError
     */
    public static orgsListPatGrantRequestRepositories(
        org: string,
        patRequestId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<minimal_repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories',
            path: {
                'org': org,
                'pat_request_id': patRequestId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * List fine-grained personal access tokens with access to organization resources
     * Lists approved fine-grained personal access tokens owned by organization members that can access organization resources.
     *
     * Only GitHub Apps can use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param sort The property by which to sort the results.
     * @param direction The direction to sort the results by.
     * @param owner A list of owner usernames to use to filter the results.
     * @param repository The name of the repository to use to filter the results.
     * @param permission The permission to use to filter the results.
     * @param lastUsedBefore Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param lastUsedAfter Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param tokenId The ID of the token
     * @returns organization_programmatic_access_grant Response
     * @throws ApiError
     */
    public static orgsListPatGrants(
        org: string,
        perPage: number = 30,
        page: number = 1,
        sort: 'created_at' = 'created_at',
        direction: 'asc' | 'desc' = 'desc',
        owner?: Array<string>,
        repository?: string,
        permission?: string,
        lastUsedBefore?: string,
        lastUsedAfter?: string,
        tokenId?: Array<string>,
    ): CancelablePromise<Array<organization_programmatic_access_grant>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/personal-access-tokens',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'sort': sort,
                'direction': direction,
                'owner': owner,
                'repository': repository,
                'permission': permission,
                'last_used_before': lastUsedBefore,
                'last_used_after': lastUsedAfter,
                'token_id': tokenId,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Update the access to organization resources via fine-grained personal access tokens
     * Updates the access organization members have to organization resources via fine-grained personal access tokens. Limited to revoking a token's existing access.
     *
     * Only GitHub Apps can use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns any Accepted
     * @throws ApiError
     */
    public static orgsUpdatePatAccesses(
        org: string,
        requestBody: {
            /**
             * Action to apply to the fine-grained personal access token.
             */
            action: 'revoke';
            /**
             * The IDs of the fine-grained personal access tokens.
             */
            pat_ids: Array<number>;
        },
    ): CancelablePromise<Record<string, any>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/personal-access-tokens',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Update the access a fine-grained personal access token has to organization resources
     * Updates the access an organization member has to organization resources via a fine-grained personal access token. Limited to revoking the token's existing access. Limited to revoking a token's existing access.
     *
     * Only GitHub Apps can use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param patId The unique identifier of the fine-grained personal access token.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static orgsUpdatePatAccess(
        org: string,
        patId: number,
        requestBody: {
            /**
             * Action to apply to the fine-grained personal access token.
             */
            action: 'revoke';
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/personal-access-tokens/{pat_id}',
            path: {
                'org': org,
                'pat_id': patId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * List repositories a fine-grained personal access token has access to
     * Lists the repositories a fine-grained personal access token has access to.
     *
     * Only GitHub Apps can use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param patId Unique identifier of the fine-grained personal access token.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns minimal_repository Response
     * @throws ApiError
     */
    public static orgsListPatGrantRepositories(
        org: string,
        patId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<minimal_repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/personal-access-tokens/{pat_id}/repositories',
            path: {
                'org': org,
                'pat_id': patId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get all custom properties for an organization
     * Gets all custom properties defined for an organization.
     * Organization members can read these properties.
     * @param org The organization name. The name is not case sensitive.
     * @returns custom_property Response
     * @throws ApiError
     */
    public static orgsCustomPropertiesForReposGetOrganizationDefinitions(
        org: string,
    ): CancelablePromise<Array<custom_property>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/properties/schema',
            path: {
                'org': org,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create or update custom properties for an organization
     * Creates new or updates existing custom properties defined for an organization in a batch.
     *
     * If the property already exists, the existing property will be replaced with the new values.
     * Missing optional values will fall back to default values, previous values will be overwritten.
     * E.g. if a property exists with `values_editable_by: org_and_repo_actors` and it's updated without specifying `values_editable_by`, it will be updated to default value `org_actors`.
     *
     * To use this endpoint, the authenticated user must be one of:
     * - An administrator for the organization.
     * - A user, or a user on a team, with the fine-grained permission of `custom_properties_org_definitions_manager` in the organization.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns custom_property Response
     * @throws ApiError
     */
    public static orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitions(
        org: string,
        requestBody: {
            /**
             * The array of custom properties to create or update.
             */
            properties: Array<custom_property>;
        },
    ): CancelablePromise<Array<custom_property>> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/orgs/{org}/properties/schema',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a custom property for an organization
     * Gets a custom property that is defined for an organization.
     * Organization members can read these properties.
     * @param org The organization name. The name is not case sensitive.
     * @param customPropertyName The custom property name
     * @returns custom_property Response
     * @throws ApiError
     */
    public static orgsCustomPropertiesForReposGetOrganizationDefinition(
        org: string,
        customPropertyName: string,
    ): CancelablePromise<custom_property> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/properties/schema/{custom_property_name}',
            path: {
                'org': org,
                'custom_property_name': customPropertyName,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create or update a custom property for an organization
     * Creates a new or updates an existing custom property that is defined for an organization.
     *
     * To use this endpoint, the authenticated user must be one of:
     * - An administrator for the organization.
     * - A user, or a user on a team, with the fine-grained permission of `custom_properties_org_definitions_manager` in the organization.
     * @param org The organization name. The name is not case sensitive.
     * @param customPropertyName The custom property name
     * @param requestBody
     * @returns custom_property Response
     * @throws ApiError
     */
    public static orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinition(
        org: string,
        customPropertyName: string,
        requestBody: custom_property_set_payload,
    ): CancelablePromise<custom_property> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/properties/schema/{custom_property_name}',
            path: {
                'org': org,
                'custom_property_name': customPropertyName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Remove a custom property for an organization
     * Removes a custom property that is defined for an organization.
     *
     * To use this endpoint, the authenticated user must be one of:
     * - An administrator for the organization.
     * - A user, or a user on a team, with the fine-grained permission of `custom_properties_org_definitions_manager` in the organization.
     * @param org The organization name. The name is not case sensitive.
     * @param customPropertyName The custom property name
     * @returns void
     * @throws ApiError
     */
    public static orgsCustomPropertiesForReposDeleteOrganizationDefinition(
        org: string,
        customPropertyName: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/properties/schema/{custom_property_name}',
            path: {
                'org': org,
                'custom_property_name': customPropertyName,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List custom property values for organization repositories
     * Lists organization repositories with all of their custom property values.
     * Organization members can read these properties.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param repositoryQuery Finds repositories in the organization with a query containing one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.
     * @returns org_repo_custom_property_values Response
     * @throws ApiError
     */
    public static orgsCustomPropertiesForReposGetOrganizationValues(
        org: string,
        perPage: number = 30,
        page: number = 1,
        repositoryQuery?: string,
    ): CancelablePromise<Array<org_repo_custom_property_values>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/properties/values',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'repository_query': repositoryQuery,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create or update custom property values for organization repositories
     * Create new or update existing custom property values for repositories in a batch that belong to an organization.
     * Each target repository will have its custom property values updated to match the values provided in the request.
     *
     * A maximum of 30 repositories can be updated in a single request.
     *
     * Using a value of `null` for a custom property will remove or 'unset' the property value from the repository.
     *
     * To use this endpoint, the authenticated user must be one of:
     * - An administrator for the organization.
     * - A user, or a user on a team, with the fine-grained permission of `custom_properties_org_values_editor` in the organization.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static orgsCustomPropertiesForReposCreateOrUpdateOrganizationValues(
        org: string,
        requestBody: {
            /**
             * The names of repositories that the custom property values will be applied to.
             */
            repository_names: Array<string>;
            /**
             * List of custom property names and associated values to apply to the repositories.
             */
            properties: Array<custom_property_value>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/orgs/{org}/properties/values',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List public organization members
     * Members of an organization can choose to have their membership publicized or not.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static orgsListPublicMembers(
        org: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/public_members',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Check public organization membership for a user
     * Check if the provided user is a public member of the organization.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsCheckPublicMembershipForUser(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/public_members/{username}',
            path: {
                'org': org,
                'username': username,
            },
            errors: {
                404: `Not Found if user is not a public member`,
            },
        });
    }
    /**
     * Set public organization membership for the authenticated user
     * The user can publicize their own membership. (A user cannot publicize the membership for another user.)
     *
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsSetPublicMembershipForAuthenticatedUser(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/public_members/{username}',
            path: {
                'org': org,
                'username': username,
            },
            errors: {
                403: `Forbidden`,
            },
        });
    }
    /**
     * Remove public organization membership for the authenticated user
     * Removes the public membership for the authenticated user from the specified organization, unless public visibility is enforced by default.
     * @param org The organization name. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static orgsRemovePublicMembershipForAuthenticatedUser(
        org: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/public_members/{username}',
            path: {
                'org': org,
                'username': username,
            },
        });
    }
    /**
     * Get organization ruleset history
     * Get the history of an organization ruleset.
     * @param org The organization name. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns ruleset_version Response
     * @throws ApiError
     */
    public static orgsGetOrgRulesetHistory(
        org: string,
        rulesetId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<ruleset_version>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/rulesets/{ruleset_id}/history',
            path: {
                'org': org,
                'ruleset_id': rulesetId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get organization ruleset version
     * Get a version of an organization ruleset.
     * @param org The organization name. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @param versionId The ID of the version
     * @returns ruleset_version_with_state Response
     * @throws ApiError
     */
    public static orgsGetOrgRulesetVersion(
        org: string,
        rulesetId: number,
        versionId: number,
    ): CancelablePromise<ruleset_version_with_state> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/rulesets/{ruleset_id}/history/{version_id}',
            path: {
                'org': org,
                'ruleset_id': rulesetId,
                'version_id': versionId,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * @deprecated
     * List security manager teams
     * > [!WARNING]
     * > **Closing down notice:** This operation is closing down and will be removed starting January 1, 2026. Please use the "[Organization Roles](https://docs.github.com/rest/orgs/organization-roles)" endpoints instead.
     * @param org The organization name. The name is not case sensitive.
     * @returns team_simple Response
     * @throws ApiError
     */
    public static orgsListSecurityManagerTeams(
        org: string,
    ): CancelablePromise<Array<team_simple>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/security-managers',
            path: {
                'org': org,
            },
        });
    }
    /**
     * @deprecated
     * Add a security manager team
     * > [!WARNING]
     * > **Closing down notice:** This operation is closing down and will be removed starting January 1, 2026. Please use the "[Organization Roles](https://docs.github.com/rest/orgs/organization-roles)" endpoints instead.
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @returns void
     * @throws ApiError
     */
    public static orgsAddSecurityManagerTeam(
        org: string,
        teamSlug: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/security-managers/teams/{team_slug}',
            path: {
                'org': org,
                'team_slug': teamSlug,
            },
        });
    }
    /**
     * @deprecated
     * Remove a security manager team
     * > [!WARNING]
     * > **Closing down notice:** This operation is closing down and will be removed starting January 1, 2026. Please use the "[Organization Roles](https://docs.github.com/rest/orgs/organization-roles)" endpoints instead.
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @returns void
     * @throws ApiError
     */
    public static orgsRemoveSecurityManagerTeam(
        org: string,
        teamSlug: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/security-managers/teams/{team_slug}',
            path: {
                'org': org,
                'team_slug': teamSlug,
            },
        });
    }
    /**
     * Get immutable releases settings for an organization
     * Gets the immutable releases policy for repositories in an organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @returns immutable_releases_organization_settings Immutable releases settings response
     * @throws ApiError
     */
    public static orgsGetImmutableReleasesSettings(
        org: string,
    ): CancelablePromise<immutable_releases_organization_settings> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/settings/immutable-releases',
            path: {
                'org': org,
            },
        });
    }
    /**
     * Set immutable releases settings for an organization
     * Sets the immutable releases policy for repositories in an organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static orgsSetImmutableReleasesSettings(
        org: string,
        requestBody: {
            /**
             * The policy that controls how immutable releases are enforced in the organization.
             */
            enforced_repositories: 'all' | 'none' | 'selected';
            /**
             * An array of repository ids for which immutable releases enforcement should be applied. You can only provide a list of repository ids when the `enforced_repositories` is set to `selected`. You can add and remove individual repositories using the [Enable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#enable-a-selected-repository-for-immutable-releases-in-an-organization) and [Disable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#disable-a-selected-repository-for-immutable-releases-in-an-organization) endpoints.
             */
            selected_repository_ids?: Array<number>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/settings/immutable-releases',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List selected repositories for immutable releases enforcement
     * List all of the repositories that have been selected for immutable releases enforcement in an organization.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static orgsGetImmutableReleasesSettingsRepositories(
        org: string,
        page: number = 1,
        perPage: number = 30,
    ): CancelablePromise<{
        total_count: number;
        repositories: Array<minimal_repository>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/settings/immutable-releases/repositories',
            path: {
                'org': org,
            },
            query: {
                'page': page,
                'per_page': perPage,
            },
        });
    }
    /**
     * Set selected repositories for immutable releases enforcement
     * Replaces all repositories that have been selected for immutable releases enforcement in an organization. To use this endpoint, the organization immutable releases policy for `enforced_repositories` must be configured to `selected`.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static orgsSetImmutableReleasesSettingsRepositories(
        org: string,
        requestBody: {
            /**
             * An array of repository ids for which immutable releases enforcement should be applied. You can only provide a list of repository ids when the `enforced_repositories` is set to `selected`. You can add and remove individual repositories using the [Enable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#enable-a-selected-repository-for-immutable-releases-in-an-organization) and [Disable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#disable-a-selected-repository-for-immutable-releases-in-an-organization) endpoints.
             */
            selected_repository_ids: Array<number>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/settings/immutable-releases/repositories',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Enable a selected repository for immutable releases in an organization
     * Adds a repository to the list of selected repositories that are enforced for immutable releases in an organization. To use this endpoint, the organization immutable releases policy for `enforced_repositories` must be configured to `selected`.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param repositoryId The unique identifier of the repository.
     * @returns void
     * @throws ApiError
     */
    public static orgsEnableSelectedRepositoryImmutableReleasesOrganization(
        org: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/settings/immutable-releases/repositories/{repository_id}',
            path: {
                'org': org,
                'repository_id': repositoryId,
            },
        });
    }
    /**
     * Disable a selected repository for immutable releases in an organization
     * Removes a repository from the list of selected repositories that are enforced for immutable releases in an organization. To use this endpoint, the organization immutable releases policy for `enforced_repositories` must be configured to `selected`.
     *
     * OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param repositoryId The unique identifier of the repository.
     * @returns void
     * @throws ApiError
     */
    public static orgsDisableSelectedRepositoryImmutableReleasesOrganization(
        org: string,
        repositoryId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/settings/immutable-releases/repositories/{repository_id}',
            path: {
                'org': org,
                'repository_id': repositoryId,
            },
        });
    }
    /**
     * @deprecated
     * Enable or disable a security feature for an organization
     * > [!WARNING]
     * > **Closing down notice:** The ability to enable or disable a security feature for all eligible repositories in an organization is closing down. Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead. For more information, see the [changelog](https://github.blog/changelog/2024-07-22-deprecation-of-api-endpoint-to-enable-or-disable-a-security-feature-for-an-organization/).
     *
     * Enables or disables the specified security feature for all eligible repositories in an organization. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
     *
     * The authenticated user must be an organization owner or be member of a team with the security manager role to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:org`, `write:org`, or `repo` scopes to use this endpoint.
     * @param org The organization name. The name is not case sensitive.
     * @param securityProduct The security feature to enable or disable.
     * @param enablement The action to take.
     *
     * `enable_all` means to enable the specified security feature for all repositories in the organization.
     * `disable_all` means to disable the specified security feature for all repositories in the organization.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static orgsEnableOrDisableSecurityProductOnAllOrgRepos(
        org: string,
        securityProduct: 'dependency_graph' | 'dependabot_alerts' | 'dependabot_security_updates' | 'advanced_security' | 'code_scanning_default_setup' | 'secret_scanning' | 'secret_scanning_push_protection',
        enablement: 'enable_all' | 'disable_all',
        requestBody?: any,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/{security_product}/{enablement}',
            path: {
                'org': org,
                'security_product': securityProduct,
                'enablement': enablement,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `The action could not be taken due to an in progress enablement, or a policy is preventing enablement`,
            },
        });
    }
    /**
     * List organization memberships for the authenticated user
     * Lists all of the authenticated user's organization memberships.
     * @param state Indicates the state of the memberships to return. If not specified, the API returns both active and pending memberships.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns org_membership Response
     * @throws ApiError
     */
    public static orgsListMembershipsForAuthenticatedUser(
        state?: 'active' | 'pending',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<org_membership>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/memberships/orgs',
            query: {
                'state': state,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get an organization membership for the authenticated user
     * If the authenticated user is an active or pending member of the organization, this endpoint will return the user's membership. If the authenticated user is not affiliated with the organization, a `404` is returned. This endpoint will return a `403` if the request is made by a GitHub App that is blocked by the organization.
     * @param org The organization name. The name is not case sensitive.
     * @returns org_membership Response
     * @throws ApiError
     */
    public static orgsGetMembershipForAuthenticatedUser(
        org: string,
    ): CancelablePromise<org_membership> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/memberships/orgs/{org}',
            path: {
                'org': org,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update an organization membership for the authenticated user
     * Converts the authenticated user to an active member of the organization, if that user has a pending invitation from the organization.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns org_membership Response
     * @throws ApiError
     */
    public static orgsUpdateMembershipForAuthenticatedUser(
        org: string,
        requestBody: {
            /**
             * The state that the membership should be in. Only `"active"` will be accepted.
             */
            state: 'active';
        },
    ): CancelablePromise<org_membership> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/user/memberships/orgs/{org}',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List organizations for the authenticated user
     * List organizations for the authenticated user.
     *
     * For OAuth app tokens and personal access tokens (classic), this endpoint only lists organizations that your authorization allows you to operate on in some way (e.g., you can list teams with `read:org` scope, you can publicize your organization membership with `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope for OAuth app tokens and personal access tokens (classic). Requests with insufficient scope will receive a `403 Forbidden` response.
     *
     * > [!NOTE]
     * > Requests using a fine-grained access token will receive a `200 Success` response with an empty list.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns organization_simple Response
     * @throws ApiError
     */
    public static orgsListForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<organization_simple>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/orgs',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * List organizations for a user
     * List [public organization memberships](https://docs.github.com/articles/publicizing-or-concealing-organization-membership) for the specified user.
     *
     * This method only lists _public_ memberships, regardless of authentication. If you need to fetch all of the organization memberships (public and private) for the authenticated user, use the [List organizations for the authenticated user](https://docs.github.com/rest/orgs/orgs#list-organizations-for-the-authenticated-user) API instead.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns organization_simple Response
     * @throws ApiError
     */
    public static orgsListForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<organization_simple>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/orgs',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
}

// From: PullsService.ts
export class PullsService {
    /**
     * List pull requests
     * Lists pull requests in a specified repository.
     *
     * Draft pull requests are available in public repositories with GitHub
     * Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing
     * plans, and in public and private repositories with GitHub Team and GitHub Enterprise
     * Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)
     * in the GitHub Help documentation.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param state Either `open`, `closed`, or `all` to filter by state.
     * @param head Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.
     * @param base Filter pulls by base branch name. Example: `gh-pages`.
     * @param sort What to sort results by. `popularity` will sort by the number of comments. `long-running` will sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month.
     * @param direction The direction of the sort. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns pull_request_simple Response
     * @throws ApiError
     */
    public static pullsList(
        owner: string,
        repo: string,
        state: 'open' | 'closed' | 'all' = 'open',
        head?: string,
        base?: string,
        sort: 'created' | 'updated' | 'popularity' | 'long-running' = 'created',
        direction?: 'asc' | 'desc',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<pull_request_simple>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'state': state,
                'head': head,
                'base': base,
                'sort': sort,
                'direction': direction,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Create a pull request
     * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns pull_request Response
     * @throws ApiError
     */
    public static pullsCreate(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The title of the new pull request. Required unless `issue` is specified.
             */
            title?: string;
            /**
             * The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.
             */
            head: string;
            /**
             * The name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization.
             */
            head_repo?: string;
            /**
             * The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.
             */
            base: string;
            /**
             * The contents of the pull request.
             */
            body?: string;
            /**
             * Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.
             */
            maintainer_can_modify?: boolean;
            /**
             * Indicates whether the pull request is a draft. See "[Draft Pull Requests](https://docs.github.com/articles/about-pull-requests#draft-pull-requests)" in the GitHub Help documentation to learn more.
             */
            draft?: boolean;
            /**
             * An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.
             */
            issue?: number;
        },
    ): CancelablePromise<pull_request> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pulls',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List review comments in a repository
     * Lists review comments for all pull requests in a repository. By default,
     * review comments are in ascending order by ID.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param sort
     * @param direction The direction to sort results. Ignored without `sort` parameter.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns pull_request_review_comment Response
     * @throws ApiError
     */
    public static pullsListReviewCommentsForRepo(
        owner: string,
        repo: string,
        sort?: 'created' | 'updated' | 'created_at',
        direction?: 'asc' | 'desc',
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<pull_request_review_comment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/comments',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'sort': sort,
                'direction': direction,
                'since': since,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get a review comment for a pull request
     * Provides details for a specified review comment.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @returns pull_request_review_comment Response
     * @throws ApiError
     */
    public static pullsGetReviewComment(
        owner: string,
        repo: string,
        commentId: number,
    ): CancelablePromise<pull_request_review_comment> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/comments/{comment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'comment_id': commentId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a review comment for a pull request
     * Edits the content of a specified review comment.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param requestBody
     * @returns pull_request_review_comment Response
     * @throws ApiError
     */
    public static pullsUpdateReviewComment(
        owner: string,
        repo: string,
        commentId: number,
        requestBody: {
            /**
             * The text of the reply to the review comment.
             */
            body: string;
        },
    ): CancelablePromise<pull_request_review_comment> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/pulls/comments/{comment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'comment_id': commentId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a review comment for a pull request
     * Deletes a review comment.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @returns void
     * @throws ApiError
     */
    public static pullsDeleteReviewComment(
        owner: string,
        repo: string,
        commentId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/pulls/comments/{comment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'comment_id': commentId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a pull request
     * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists details of a pull request by providing its number.
     *
     * When you get, [create](https://docs.github.com/rest/pulls/pulls/#create-a-pull-request), or [edit](https://docs.github.com/rest/pulls/pulls#update-a-pull-request) a pull request, GitHub creates a merge commit to test whether the pull request can be automatically merged into the base branch. This test commit is not added to the base branch or the head branch. You can review the status of the test commit using the `mergeable` key. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
     *
     * The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`, then GitHub has started a background job to compute the mergeability. After giving the job time to complete, resubmit the request. When the job finishes, you will see a non-`null` value for the `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be the SHA of the _test_ merge commit.
     *
     * The value of the `merge_commit_sha` attribute changes depending on the state of the pull request. Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how you merged the pull request:
     *
     * *   If merged as a [merge commit](https://docs.github.com/articles/about-merge-methods-on-github/), `merge_commit_sha` represents the SHA of the merge commit.
     * *   If merged via a [squash](https://docs.github.com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha` represents the SHA of the squashed commit on the base branch.
     * *   If [rebased](https://docs.github.com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha` represents the commit that the base branch was updated to.
     *
     * Pass the appropriate [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types) to fetch diff and patch formats.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * - **`application/vnd.github.diff`**: For more information, see "[git-diff](https://git-scm.com/docs/git-diff)" in the Git documentation. If a diff is corrupt, contact us through the [GitHub Support portal](https://support.github.com/). Include the repository name and pull request ID in your message.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @returns pull_request Pass the appropriate [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types) to fetch diff and patch formats.
     * @throws ApiError
     */
    public static pullsGet(
        owner: string,
        repo: string,
        pullNumber: number,
    ): CancelablePromise<pull_request> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            errors: {
                304: `Not modified`,
                404: `Resource not found`,
                406: `Unacceptable`,
                500: `Internal Error`,
                503: `Service unavailable`,
            },
        });
    }
    /**
     * Update a pull request
     * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param requestBody
     * @returns pull_request Response
     * @throws ApiError
     */
    public static pullsUpdate(
        owner: string,
        repo: string,
        pullNumber: number,
        requestBody?: {
            /**
             * The title of the pull request.
             */
            title?: string;
            /**
             * The contents of the pull request.
             */
            body?: string;
            /**
             * State of this Pull Request. Either `open` or `closed`.
             */
            state?: 'open' | 'closed';
            /**
             * The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.
             */
            base?: string;
            /**
             * Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.
             */
            maintainer_can_modify?: boolean;
        },
    ): CancelablePromise<pull_request> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List review comments on a pull request
     * Lists all review comments for a specified pull request. By default, review comments
     * are in ascending order by ID.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param sort The property to sort the results by.
     * @param direction The direction to sort results. Ignored without `sort` parameter.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns pull_request_review_comment Response
     * @throws ApiError
     */
    public static pullsListReviewComments(
        owner: string,
        repo: string,
        pullNumber: number,
        sort: 'created' | 'updated' = 'created',
        direction?: 'asc' | 'desc',
        since?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<pull_request_review_comment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/comments',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            query: {
                'sort': sort,
                'direction': direction,
                'since': since,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create a review comment for a pull request
     * Creates a review comment on the diff of a specified pull request. To add a regular comment to a pull request timeline, see "[Create an issue comment](https://docs.github.com/rest/issues/comments#create-an-issue-comment)."
     *
     * If your comment applies to more than one line in the pull request diff, you should use the parameters `line`, `side`, and optionally `start_line` and `start_side` in your request.
     *
     * The `position` parameter is closing down. If you use `position`, the `line`, `side`, `start_line`, and `start_side` parameters are not required.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
     * and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param requestBody
     * @returns pull_request_review_comment Response
     * @throws ApiError
     */
    public static pullsCreateReviewComment(
        owner: string,
        repo: string,
        pullNumber: number,
        requestBody: {
            /**
             * The text of the review comment.
             */
            body: string;
            /**
             * The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.
             */
            commit_id: string;
            /**
             * The relative path to the file that necessitates a comment.
             */
            path: string;
            /**
             * **This parameter is closing down. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
             * @deprecated
             */
            position?: number;
            /**
             * In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation.
             */
            side?: 'LEFT' | 'RIGHT';
            /**
             * **Required unless using `subject_type:file`**. The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.
             */
            line?: number;
            /**
             * **Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation.
             */
            start_line?: number;
            /**
             * **Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context.
             */
            start_side?: 'LEFT' | 'RIGHT' | 'side';
            /**
             * The ID of the review comment to reply to. To find the ID of a review comment with ["List review comments on a pull request"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.
             */
            in_reply_to?: number;
            /**
             * The level at which the comment is targeted.
             */
            subject_type?: 'line' | 'file';
        },
    ): CancelablePromise<pull_request_review_comment> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/comments',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Create a reply for a review comment
     * Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of the review comment you are replying to. This must be the ID of a _top-level review comment_, not a reply to that comment. Replies to replies are not supported.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
     * and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param commentId The unique identifier of the comment.
     * @param requestBody
     * @returns pull_request_review_comment Response
     * @throws ApiError
     */
    public static pullsCreateReplyForReviewComment(
        owner: string,
        repo: string,
        pullNumber: number,
        commentId: number,
        requestBody: {
            /**
             * The text of the review comment.
             */
            body: string;
        },
    ): CancelablePromise<pull_request_review_comment> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
                'comment_id': commentId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List commits on a pull request
     * Lists a maximum of 250 commits for a pull request. To receive a complete
     * commit list for pull requests with more than 250 commits, use the [List commits](https://docs.github.com/rest/commits/commits#list-commits)
     * endpoint.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns commit Response
     * @throws ApiError
     */
    public static pullsListCommits(
        owner: string,
        repo: string,
        pullNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<commit>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/commits',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List pull requests files
     * Lists the files in a specified pull request.
     *
     * > [!NOTE]
     * > Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns diff_entry Response
     * @throws ApiError
     */
    public static pullsListFiles(
        owner: string,
        repo: string,
        pullNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<diff_entry>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/files',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
                500: `Internal Error`,
                503: `Service unavailable`,
            },
        });
    }
    /**
     * Check if a pull request has been merged
     * Checks if a pull request has been merged into the base branch. The HTTP status of the response indicates whether or not the pull request has been merged; the response body is empty.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @returns void
     * @throws ApiError
     */
    public static pullsCheckIfMerged(
        owner: string,
        repo: string,
        pullNumber: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/merge',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            errors: {
                404: `Not Found if pull request has not been merged`,
            },
        });
    }
    /**
     * Merge a pull request
     * Merges a pull request into the base branch.
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param requestBody
     * @returns pull_request_merge_result if merge was successful
     * @throws ApiError
     */
    public static pullsMerge(
        owner: string,
        repo: string,
        pullNumber: number,
        requestBody?: {
            /**
             * Title for the automatic commit message.
             */
            commit_title?: string;
            /**
             * Extra detail to append to automatic commit message.
             */
            commit_message?: string;
            /**
             * SHA that pull request head must match to allow merge.
             */
            sha?: string;
            /**
             * The merge method to use.
             */
            merge_method?: 'merge' | 'squash' | 'rebase';
        } | null,
    ): CancelablePromise<pull_request_merge_result> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/merge',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                405: `Method Not Allowed if merge cannot be performed`,
                409: `Conflict if sha was provided and pull request head did not match`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get all requested reviewers for a pull request
     * Gets the users or teams whose review is requested for a pull request. Once a requested reviewer submits a review, they are no longer considered a requested reviewer. Their review will instead be returned by the [List reviews for a pull request](https://docs.github.com/rest/pulls/reviews#list-reviews-for-a-pull-request) operation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @returns pull_request_review_request Response
     * @throws ApiError
     */
    public static pullsListRequestedReviewers(
        owner: string,
        repo: string,
        pullNumber: number,
    ): CancelablePromise<pull_request_review_request> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
        });
    }
    /**
     * Request reviewers for a pull request
     * Requests reviews for a pull request from a given set of users and/or teams.
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param requestBody
     * @returns pull_request_simple Response
     * @throws ApiError
     */
    public static pullsRequestReviewers(
        owner: string,
        repo: string,
        pullNumber: number,
        requestBody?: {
            /**
             * An array of user `login`s that will be requested.
             */
            reviewers?: Array<string>;
            /**
             * An array of team `slug`s that will be requested.
             */
            team_reviewers?: Array<string>;
        },
    ): CancelablePromise<pull_request_simple> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Unprocessable Entity if user is not a collaborator`,
            },
        });
    }
    /**
     * Remove requested reviewers from a pull request
     * Removes review requests from a pull request for a given set of users and/or teams.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param requestBody
     * @returns pull_request_simple Response
     * @throws ApiError
     */
    public static pullsRemoveRequestedReviewers(
        owner: string,
        repo: string,
        pullNumber: number,
        requestBody: {
            /**
             * An array of user `login`s that will be removed.
             */
            reviewers: Array<string>;
            /**
             * An array of team `slug`s that will be removed.
             */
            team_reviewers?: Array<string>;
        },
    ): CancelablePromise<pull_request_simple> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List reviews for a pull request
     * Lists all reviews for a specified pull request. The list of reviews returns in chronological order.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns pull_request_review The list of reviews returns in chronological order.
     * @throws ApiError
     */
    public static pullsListReviews(
        owner: string,
        repo: string,
        pullNumber: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<pull_request_review>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/reviews',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create a review for a pull request
     * Creates a review on a specified pull request.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     *
     * Pull request reviews created in the `PENDING` state are not submitted and therefore do not include the `submitted_at` property in the response. To create a pending review for a pull request, leave the `event` parameter blank. For more information about submitting a `PENDING` review, see "[Submit a review for a pull request](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request)."
     *
     * > [!NOTE]
     * > To comment on a specific line in a file, you need to first determine the position of that line in the diff. To see a pull request diff, add the `application/vnd.github.v3.diff` media type to the `Accept` header of a call to the [Get a pull request](https://docs.github.com/rest/pulls/pulls#get-a-pull-request) endpoint.
     *
     * The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param requestBody
     * @returns pull_request_review Response
     * @throws ApiError
     */
    public static pullsCreateReview(
        owner: string,
        repo: string,
        pullNumber: number,
        requestBody?: {
            /**
             * The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.
             */
            commit_id?: string;
            /**
             * **Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.
             */
            body?: string;
            /**
             * The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request) when you are ready.
             */
            event?: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
            /**
             * Use the following table to specify the location, destination, and contents of the draft review comment.
             */
            comments?: Array<{
                /**
                 * The relative path to the file that necessitates a review comment.
                 */
                path: string;
                /**
                 * The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
                 */
                position?: number;
                /**
                 * Text of the review comment.
                 */
                body: string;
                line?: number;
                side?: string;
                start_line?: number;
                start_side?: string;
            }>;
        },
    ): CancelablePromise<pull_request_review> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/reviews',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a review for a pull request
     * Retrieves a pull request review by its ID.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param reviewId The unique identifier of the review.
     * @returns pull_request_review Response
     * @throws ApiError
     */
    public static pullsGetReview(
        owner: string,
        repo: string,
        pullNumber: number,
        reviewId: number,
    ): CancelablePromise<pull_request_review> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
                'review_id': reviewId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a review for a pull request
     * Updates the contents of a specified review summary comment.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param reviewId The unique identifier of the review.
     * @param requestBody
     * @returns pull_request_review Response
     * @throws ApiError
     */
    public static pullsUpdateReview(
        owner: string,
        repo: string,
        pullNumber: number,
        reviewId: number,
        requestBody: {
            /**
             * The body text of the pull request review.
             */
            body: string;
        },
    ): CancelablePromise<pull_request_review> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
                'review_id': reviewId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete a pending review for a pull request
     * Deletes a pull request review that has not been submitted. Submitted reviews cannot be deleted.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param reviewId The unique identifier of the review.
     * @returns pull_request_review Response
     * @throws ApiError
     */
    public static pullsDeletePendingReview(
        owner: string,
        repo: string,
        pullNumber: number,
        reviewId: number,
    ): CancelablePromise<pull_request_review> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
                'review_id': reviewId,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List comments for a pull request review
     * Lists comments for a specific pull request review.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param reviewId The unique identifier of the review.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns review_comment Response
     * @throws ApiError
     */
    public static pullsListCommentsForReview(
        owner: string,
        repo: string,
        pullNumber: number,
        reviewId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<review_comment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
                'review_id': reviewId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Dismiss a review for a pull request
     * Dismisses a specified review on a pull request.
     *
     * > [!NOTE]
     * > To dismiss a pull request review on a [protected branch](https://docs.github.com/rest/branches/branch-protection), you must be a repository administrator or be included in the list of people or teams who can dismiss pull request reviews.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param reviewId The unique identifier of the review.
     * @param requestBody
     * @returns pull_request_review Response
     * @throws ApiError
     */
    public static pullsDismissReview(
        owner: string,
        repo: string,
        pullNumber: number,
        reviewId: number,
        requestBody: {
            /**
             * The message for the pull request review dismissal
             */
            message: string;
            event?: 'DISMISS';
        },
    ): CancelablePromise<pull_request_review> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
                'review_id': reviewId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Submit a review for a pull request
     * Submits a pending review for a pull request. For more information about creating a pending review for a pull request, see "[Create a review for a pull request](https://docs.github.com/rest/pulls/reviews#create-a-review-for-a-pull-request)."
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param reviewId The unique identifier of the review.
     * @param requestBody
     * @returns pull_request_review Response
     * @throws ApiError
     */
    public static pullsSubmitReview(
        owner: string,
        repo: string,
        pullNumber: number,
        reviewId: number,
        requestBody: {
            /**
             * The body text of the pull request review
             */
            body?: string;
            /**
             * The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.
             */
            event: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
        },
    ): CancelablePromise<pull_request_review> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
                'review_id': reviewId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Update a pull request branch
     * Updates the pull request branch with the latest upstream changes by merging HEAD from the base branch into the pull request branch.
     * Note: If making a request on behalf of a GitHub App you must also have permissions to write the contents of the head repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pullNumber The number that identifies the pull request.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static pullsUpdateBranch(
        owner: string,
        repo: string,
        pullNumber: number,
        requestBody?: {
            /**
             * The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the "[List commits](https://docs.github.com/rest/commits/commits#list-commits)" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref.
             */
            expected_head_sha?: string;
        } | null,
    ): CancelablePromise<{
        message?: string;
        url?: string;
    }> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/pulls/{pull_number}/update-branch',
            path: {
                'owner': owner,
                'repo': repo,
                'pull_number': pullNumber,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
}

// From: ReposService.ts
export class ReposService {
    /**
     * List organization repositories
     * Lists repositories for the specified organization.
     *
     * > [!NOTE]
     * > In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
     * @param org The organization name. The name is not case sensitive.
     * @param type Specifies the types of repositories you want returned.
     * @param sort The property to sort the results by.
     * @param direction The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns minimal_repository Response
     * @throws ApiError
     */
    public static reposListForOrg(
        org: string,
        type: 'all' | 'public' | 'private' | 'forks' | 'sources' | 'member' = 'all',
        sort: 'created' | 'updated' | 'pushed' | 'full_name' = 'created',
        direction?: 'asc' | 'desc',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<minimal_repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/repos',
            path: {
                'org': org,
            },
            query: {
                'type': type,
                'sort': sort,
                'direction': direction,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create an organization repository
     * Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
     *
     * OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody
     * @returns full_repository Response
     * @throws ApiError
     */
    public static reposCreateInOrg(
        org: string,
        requestBody: {
            /**
             * The name of the repository.
             */
            name: string;
            /**
             * A short description of the repository.
             */
            description?: string;
            /**
             * A URL with more information about the repository.
             */
            homepage?: string;
            /**
             * Whether the repository is private.
             */
            private?: boolean;
            /**
             * The visibility of the repository.
             */
            visibility?: 'public' | 'private';
            /**
             * Either `true` to enable issues for this repository or `false` to disable them.
             */
            has_issues?: boolean;
            /**
             * Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
             */
            has_projects?: boolean;
            /**
             * Either `true` to enable the wiki for this repository or `false` to disable it.
             */
            has_wiki?: boolean;
            /**
             * Whether downloads are enabled.
             */
            has_downloads?: boolean;
            /**
             * Either `true` to make this repo available as a template repository or `false` to prevent it.
             */
            is_template?: boolean;
            /**
             * The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
             */
            team_id?: number;
            /**
             * Pass `true` to create an initial commit with empty README.
             */
            auto_init?: boolean;
            /**
             * Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".
             */
            gitignore_template?: string;
            /**
             * Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".
             */
            license_template?: string;
            /**
             * Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
             */
            allow_squash_merge?: boolean;
            /**
             * Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
             */
            allow_merge_commit?: boolean;
            /**
             * Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
             */
            allow_rebase_merge?: boolean;
            /**
             * Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
             */
            allow_auto_merge?: boolean;
            /**
             * Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**
             */
            delete_branch_on_merge?: boolean;
            /**
             * Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
             * @deprecated
             */
            use_squash_pr_title_as_default?: boolean;
            /**
             * Required when using `squash_merge_commit_message`.
             *
             * The default value for a squash merge commit title:
             *
             * - `PR_TITLE` - default to the pull request's title.
             * - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
             */
            squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
            /**
             * The default value for a squash merge commit message:
             *
             * - `PR_BODY` - default to the pull request's body.
             * - `COMMIT_MESSAGES` - default to the branch's commit messages.
             * - `BLANK` - default to a blank commit message.
             */
            squash_merge_commit_message?: 'PR_BODY' | 'COMMIT_MESSAGES' | 'BLANK';
            /**
             * Required when using `merge_commit_message`.
             *
             * The default value for a merge commit title.
             *
             * - `PR_TITLE` - default to the pull request's title.
             * - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
             */
            merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
            /**
             * The default value for a merge commit message.
             *
             * - `PR_TITLE` - default to the pull request's title.
             * - `PR_BODY` - default to the pull request's body.
             * - `BLANK` - default to a blank commit message.
             */
            merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
            /**
             * The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.
             */
            custom_properties?: Record<string, any>;
        },
    ): CancelablePromise<full_repository> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/repos',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get all organization repository rulesets
     * Get all the repository rulesets for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param targets A comma-separated list of rule targets to filter by.
     * If provided, only rulesets that apply to the specified targets will be returned.
     * For example, `branch,tag,push`.
     *
     * @returns repository_ruleset Response
     * @throws ApiError
     */
    public static reposGetOrgRulesets(
        org: string,
        perPage: number = 30,
        page: number = 1,
        targets?: string,
    ): CancelablePromise<Array<repository_ruleset>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/rulesets',
            path: {
                'org': org,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'targets': targets,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Create an organization repository ruleset
     * Create a repository ruleset for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @param requestBody Request body
     * @returns repository_ruleset Response
     * @throws ApiError
     */
    public static reposCreateOrgRuleset(
        org: string,
        requestBody: {
            /**
             * The name of the ruleset.
             */
            name: string;
            /**
             * The target of the ruleset
             */
            target?: 'branch' | 'tag' | 'push' | 'repository';
            enforcement: repository_rule_enforcement;
            /**
             * The actors that can bypass the rules in this ruleset
             */
            bypass_actors?: Array<repository_ruleset_bypass_actor>;
            conditions?: org_ruleset_conditions;
            /**
             * An array of rules within the ruleset.
             */
            rules?: Array<org_rules>;
        },
    ): CancelablePromise<repository_ruleset> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/{org}/rulesets',
            path: {
                'org': org,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * List organization rule suites
     * Lists suites of rule evaluations at the organization level.
     * For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets)."
     * @param org The organization name. The name is not case sensitive.
     * @param ref The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
     * @param repositoryName The name of the repository to filter on.
     * @param timePeriod The time period to filter by.
     *
     * For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for rule suites that occurred in the past 7 days (168 hours).
     * @param actorName The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
     * @param ruleSuiteResult The rule suite results to filter on. When specified, only suites with this result will be returned.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns rule_suites Response
     * @throws ApiError
     */
    public static reposGetOrgRuleSuites(
        org: string,
        ref?: string,
        repositoryName?: string,
        timePeriod: 'hour' | 'day' | 'week' | 'month' = 'day',
        actorName?: string,
        ruleSuiteResult: 'pass' | 'fail' | 'bypass' | 'all' = 'all',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<rule_suites> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/rulesets/rule-suites',
            path: {
                'org': org,
            },
            query: {
                'ref': ref,
                'repository_name': repositoryName,
                'time_period': timePeriod,
                'actor_name': actorName,
                'rule_suite_result': ruleSuiteResult,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get an organization rule suite
     * Gets information about a suite of rule evaluations from within an organization.
     * For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets)."
     * @param org The organization name. The name is not case sensitive.
     * @param ruleSuiteId The unique identifier of the rule suite result.
     * To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)
     * for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)
     * for organizations.
     * @returns rule_suite Response
     * @throws ApiError
     */
    public static reposGetOrgRuleSuite(
        org: string,
        ruleSuiteId: number,
    ): CancelablePromise<rule_suite> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/rulesets/rule-suites/{rule_suite_id}',
            path: {
                'org': org,
                'rule_suite_id': ruleSuiteId,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get an organization repository ruleset
     * Get a repository ruleset for an organization.
     *
     * **Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
     * making the API request has write access to the ruleset.
     * @param org The organization name. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @returns repository_ruleset Response
     * @throws ApiError
     */
    public static reposGetOrgRuleset(
        org: string,
        rulesetId: number,
    ): CancelablePromise<repository_ruleset> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/{org}/rulesets/{ruleset_id}',
            path: {
                'org': org,
                'ruleset_id': rulesetId,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Update an organization repository ruleset
     * Update a ruleset for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @param requestBody Request body
     * @returns repository_ruleset Response
     * @throws ApiError
     */
    public static reposUpdateOrgRuleset(
        org: string,
        rulesetId: number,
        requestBody?: {
            /**
             * The name of the ruleset.
             */
            name?: string;
            /**
             * The target of the ruleset
             */
            target?: 'branch' | 'tag' | 'push' | 'repository';
            enforcement?: repository_rule_enforcement;
            /**
             * The actors that can bypass the rules in this ruleset
             */
            bypass_actors?: Array<repository_ruleset_bypass_actor>;
            conditions?: org_ruleset_conditions;
            /**
             * An array of rules within the ruleset.
             */
            rules?: Array<org_rules>;
        },
    ): CancelablePromise<repository_ruleset> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs/{org}/rulesets/{ruleset_id}',
            path: {
                'org': org,
                'ruleset_id': rulesetId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Delete an organization repository ruleset
     * Delete a ruleset for an organization.
     * @param org The organization name. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteOrgRuleset(
        org: string,
        rulesetId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/orgs/{org}/rulesets/{ruleset_id}',
            path: {
                'org': org,
                'ruleset_id': rulesetId,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get a repository
     * The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
     *
     * > [!NOTE]
     * > - In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
     * > - To view merge-related settings, you must have the `contents:read` and `contents:write` permissions.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns full_repository Response
     * @throws ApiError
     */
    public static reposGet(
        owner: string,
        repo: string,
    ): CancelablePromise<full_repository> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                301: `Moved permanently`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a repository
     * **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/repos/repos#replace-all-repository-topics) endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns full_repository Response
     * @throws ApiError
     */
    public static reposUpdate(
        owner: string,
        repo: string,
        requestBody?: {
            /**
             * The name of the repository.
             */
            name?: string;
            /**
             * A short description of the repository.
             */
            description?: string;
            /**
             * A URL with more information about the repository.
             */
            homepage?: string;
            /**
             * Either `true` to make the repository private or `false` to make it public. Default: `false`.
             * **Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.
             */
            private?: boolean;
            /**
             * The visibility of the repository.
             */
            visibility?: 'public' | 'private';
            /**
             * Specify which security and analysis features to enable or disable for the repository.
             *
             * To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
             *
             * For example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:
             * `{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.
             *
             * You can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
             */
            security_and_analysis?: {
                /**
                 * Use the `status` property to enable or disable GitHub Advanced Security for this repository.
                 * For more information, see "[About GitHub Advanced
                 * Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."
                 *
                 * For standalone Code Scanning or Secret Protection products, this parameter cannot be used.
                 */
                advanced_security?: {
                    /**
                     * Can be `enabled` or `disabled`.
                     */
                    status?: string;
                };
                /**
                 * Use the `status` property to enable or disable GitHub Code Security for this repository.
                 */
                code_security?: {
                    /**
                     * Can be `enabled` or `disabled`.
                     */
                    status?: string;
                };
                /**
                 * Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."
                 */
                secret_scanning?: {
                    /**
                     * Can be `enabled` or `disabled`.
                     */
                    status?: string;
                };
                /**
                 * Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."
                 */
                secret_scanning_push_protection?: {
                    /**
                     * Can be `enabled` or `disabled`.
                     */
                    status?: string;
                };
                /**
                 * Use the `status` property to enable or disable secret scanning AI detection for this repository. For more information, see "[Responsible detection of generic secrets with AI](https://docs.github.com/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/generic-secret-detection/responsible-ai-generic-secrets)."
                 */
                secret_scanning_ai_detection?: {
                    /**
                     * Can be `enabled` or `disabled`.
                     */
                    status?: string;
                };
                /**
                 * Use the `status` property to enable or disable secret scanning non-provider patterns for this repository. For more information, see "[Supported secret scanning patterns](/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."
                 */
                secret_scanning_non_provider_patterns?: {
                    /**
                     * Can be `enabled` or `disabled`.
                     */
                    status?: string;
                };
            } | null;
            /**
             * Either `true` to enable issues for this repository or `false` to disable them.
             */
            has_issues?: boolean;
            /**
             * Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
             */
            has_projects?: boolean;
            /**
             * Either `true` to enable the wiki for this repository or `false` to disable it.
             */
            has_wiki?: boolean;
            /**
             * Either `true` to make this repo available as a template repository or `false` to prevent it.
             */
            is_template?: boolean;
            /**
             * Updates the default branch for this repository.
             */
            default_branch?: string;
            /**
             * Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
             */
            allow_squash_merge?: boolean;
            /**
             * Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
             */
            allow_merge_commit?: boolean;
            /**
             * Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
             */
            allow_rebase_merge?: boolean;
            /**
             * Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
             */
            allow_auto_merge?: boolean;
            /**
             * Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.
             */
            delete_branch_on_merge?: boolean;
            /**
             * Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.
             */
            allow_update_branch?: boolean;
            /**
             * Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
             * @deprecated
             */
            use_squash_pr_title_as_default?: boolean;
            /**
             * Required when using `squash_merge_commit_message`.
             *
             * The default value for a squash merge commit title:
             *
             * - `PR_TITLE` - default to the pull request's title.
             * - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
             */
            squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
            /**
             * The default value for a squash merge commit message:
             *
             * - `PR_BODY` - default to the pull request's body.
             * - `COMMIT_MESSAGES` - default to the branch's commit messages.
             * - `BLANK` - default to a blank commit message.
             */
            squash_merge_commit_message?: 'PR_BODY' | 'COMMIT_MESSAGES' | 'BLANK';
            /**
             * Required when using `merge_commit_message`.
             *
             * The default value for a merge commit title.
             *
             * - `PR_TITLE` - default to the pull request's title.
             * - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
             */
            merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
            /**
             * The default value for a merge commit message.
             *
             * - `PR_TITLE` - default to the pull request's title.
             * - `PR_BODY` - default to the pull request's body.
             * - `BLANK` - default to a blank commit message.
             */
            merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
            /**
             * Whether to archive this repository. `false` will unarchive a previously archived repository.
             */
            archived?: boolean;
            /**
             * Either `true` to allow private forks, or `false` to prevent private forks.
             */
            allow_forking?: boolean;
            /**
             * Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.
             */
            web_commit_signoff_required?: boolean;
        },
    ): CancelablePromise<full_repository> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                307: `Temporary Redirect`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete a repository
     * Deleting a repository requires admin access.
     *
     * If an organization owner has configured the organization to prevent members from deleting organization-owned
     * repositories, you will get a `403 Forbidden` response.
     *
     * OAuth app tokens and personal access tokens (classic) need the `delete_repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposDelete(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                307: `Temporary Redirect`,
                403: `If an organization owner has configured the organization to prevent members from deleting organization-owned repositories, a member will get this response:`,
                404: `Resource not found`,
                409: `Conflict`,
            },
        });
    }
    /**
     * List repository activities
     * Lists a detailed history of changes to a repository, such as pushes, merges, force pushes, and branch changes, and associates these changes with commits and users.
     *
     * For more information about viewing repository activity,
     * see "[Viewing activity and data for your repository](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param direction The direction to sort the results by.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param before A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param after A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param ref The Git reference for the activities you want to list.
     *
     * The `ref` for a branch can be formatted either as `refs/heads/BRANCH_NAME` or `BRANCH_NAME`, where `BRANCH_NAME` is the name of your branch.
     * @param actor The GitHub username to use to filter by the actor who performed the activity.
     * @param timePeriod The time period to filter by.
     *
     * For example, `day` will filter for activity that occurred in the past 24 hours, and `week` will filter for activity that occurred in the past 7 days (168 hours).
     * @param activityType The activity type to filter by.
     *
     * For example, you can choose to filter by "force_push", to see all force pushes to the repository.
     * @returns activity Response
     * @throws ApiError
     */
    public static reposListActivities(
        owner: string,
        repo: string,
        direction: 'asc' | 'desc' = 'desc',
        perPage: number = 30,
        before?: string,
        after?: string,
        ref?: string,
        actor?: string,
        timePeriod?: 'day' | 'week' | 'month' | 'quarter' | 'year',
        activityType?: 'push' | 'force_push' | 'branch_creation' | 'branch_deletion' | 'pr_merge' | 'merge_queue_merge',
    ): CancelablePromise<Array<activity>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/activity',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'direction': direction,
                'per_page': perPage,
                'before': before,
                'after': after,
                'ref': ref,
                'actor': actor,
                'time_period': timePeriod,
                'activity_type': activityType,
            },
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Create an attestation
     * Store an artifact attestation and associate it with a repository.
     *
     * The authenticated user must have write permission to the repository and, if using a fine-grained access token, the `attestations:write` permission is required.
     *
     * Artifact attestations are meant to be created using the [attest action](https://github.com/actions/attest). For more information, see our guide on [using artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns any response
     * @throws ApiError
     */
    public static reposCreateAttestation(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The attestation's Sigstore Bundle.
             * Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.
             */
            bundle: {
                mediaType?: string;
                verificationMaterial?: Record<string, any>;
                dsseEnvelope?: Record<string, any>;
            };
        },
    ): CancelablePromise<{
        /**
         * The ID of the attestation.
         */
        id?: number;
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/attestations',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List attestations
     * List a collection of artifact attestations with a given subject digest that are associated with a repository.
     *
     * The authenticated user making the request must have read access to the repository. In addition, when using a fine-grained access token the `attestations:read` permission is required.
     *
     * **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param subjectDigest The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param before A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param after A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param predicateType Optional filter for fetching attestations with a given predicate type.
     * This option accepts `provenance`, `sbom`, `release`, or freeform text
     * for custom predicate types.
     * @returns any Response
     * @throws ApiError
     */
    public static reposListAttestations(
        owner: string,
        repo: string,
        subjectDigest: string,
        perPage: number = 30,
        before?: string,
        after?: string,
        predicateType?: string,
    ): CancelablePromise<{
        attestations?: Array<{
            /**
             * The attestation's Sigstore Bundle.
             * Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.
             */
            bundle?: {
                mediaType?: string;
                verificationMaterial?: Record<string, any>;
                dsseEnvelope?: Record<string, any>;
            };
            repository_id?: number;
            bundle_url?: string;
            initiator?: string;
        }>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/attestations/{subject_digest}',
            path: {
                'owner': owner,
                'repo': repo,
                'subject_digest': subjectDigest,
            },
            query: {
                'per_page': perPage,
                'before': before,
                'after': after,
                'predicate_type': predicateType,
            },
        });
    }
    /**
     * Get all autolinks of a repository
     * Gets all autolinks that are configured for a repository.
     *
     * Information about autolinks are only available to repository administrators.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns autolink Response
     * @throws ApiError
     */
    public static reposListAutolinks(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<autolink>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/autolinks',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Create an autolink reference for a repository
     * Users with admin access to the repository can create an autolink.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns autolink response
     * @throws ApiError
     */
    public static reposCreateAutolink(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.
             */
            key_prefix: string;
            /**
             * The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.
             */
            url_template: string;
            /**
             * Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.
             */
            is_alphanumeric?: boolean;
        },
    ): CancelablePromise<autolink> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/autolinks',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get an autolink reference of a repository
     * This returns a single autolink reference by ID that was configured for the given repository.
     *
     * Information about autolinks are only available to repository administrators.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param autolinkId The unique identifier of the autolink.
     * @returns autolink Response
     * @throws ApiError
     */
    public static reposGetAutolink(
        owner: string,
        repo: string,
        autolinkId: number,
    ): CancelablePromise<autolink> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/autolinks/{autolink_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'autolink_id': autolinkId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete an autolink reference from a repository
     * This deletes a single autolink reference by ID that was configured for the given repository.
     *
     * Information about autolinks are only available to repository administrators.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param autolinkId The unique identifier of the autolink.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteAutolink(
        owner: string,
        repo: string,
        autolinkId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/autolinks/{autolink_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'autolink_id': autolinkId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Check if Dependabot security updates are enabled for a repository
     * Shows whether Dependabot security updates are enabled, disabled or paused for a repository. The authenticated user must have admin read access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns check_automated_security_fixes Response if Dependabot is enabled
     * @throws ApiError
     */
    public static reposCheckAutomatedSecurityFixes(
        owner: string,
        repo: string,
    ): CancelablePromise<check_automated_security_fixes> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/automated-security-fixes',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                404: `Not Found if Dependabot is not enabled for the repository`,
            },
        });
    }
    /**
     * Enable Dependabot security updates
     * Enables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposEnableAutomatedSecurityFixes(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/automated-security-fixes',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Disable Dependabot security updates
     * Disables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposDisableAutomatedSecurityFixes(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/automated-security-fixes',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * List branches
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param _protected Setting to `true` returns only branches protected by branch protections or rulesets. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns short_branch Response
     * @throws ApiError
     */
    public static reposListBranches(
        owner: string,
        repo: string,
        _protected?: boolean,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<short_branch>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'protected': _protected,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a branch
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns branch_with_protection Response
     * @throws ApiError
     */
    public static reposGetBranch(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<branch_with_protection> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                301: `Moved permanently`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get branch protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns branch_protection Response
     * @throws ApiError
     */
    public static reposGetBranchProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<branch_protection> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update branch protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Protecting a branch requires admin or owner permissions to the repository.
     *
     * > [!NOTE]
     * > Passing new arrays of `users` and `teams` replaces their previous values.
     *
     * > [!NOTE]
     * > The list of users, apps, and teams in total is limited to 100 items.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns protected_branch Response
     * @throws ApiError
     */
    public static reposUpdateBranchProtection(
        owner: string,
        repo: string,
        branch: string,
        requestBody: {
            /**
             * Require status checks to pass before merging. Set to `null` to disable.
             */
            required_status_checks: {
                /**
                 * Require branches to be up to date before merging.
                 */
                strict: boolean;
                /**
                 * **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
                 * @deprecated
                 */
                contexts: Array<string>;
                /**
                 * The list of status checks to require in order to merge into this branch.
                 */
                checks?: Array<{
                    /**
                     * The name of the required check
                     */
                    context: string;
                    /**
                     * The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
                     */
                    app_id?: number;
                }>;
            } | null;
            /**
             * Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.
             */
            enforce_admins: boolean | null;
            /**
             * Require at least one approving review on a pull request, before merging. Set to `null` to disable.
             */
            required_pull_request_reviews: {
                /**
                 * Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
                 */
                dismissal_restrictions?: {
                    /**
                     * The list of user `login`s with dismissal access
                     */
                    users?: Array<string>;
                    /**
                     * The list of team `slug`s with dismissal access
                     */
                    teams?: Array<string>;
                    /**
                     * The list of app `slug`s with dismissal access
                     */
                    apps?: Array<string>;
                };
                /**
                 * Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
                 */
                dismiss_stale_reviews?: boolean;
                /**
                 * Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.
                 */
                require_code_owner_reviews?: boolean;
                /**
                 * Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
                 */
                required_approving_review_count?: number;
                /**
                 * Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`.
                 */
                require_last_push_approval?: boolean;
                /**
                 * Allow specific users, teams, or apps to bypass pull request requirements.
                 */
                bypass_pull_request_allowances?: {
                    /**
                     * The list of user `login`s allowed to bypass pull request requirements.
                     */
                    users?: Array<string>;
                    /**
                     * The list of team `slug`s allowed to bypass pull request requirements.
                     */
                    teams?: Array<string>;
                    /**
                     * The list of app `slug`s allowed to bypass pull request requirements.
                     */
                    apps?: Array<string>;
                };
            } | null;
            /**
             * Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
             */
            restrictions: {
                /**
                 * The list of user `login`s with push access
                 */
                users: Array<string>;
                /**
                 * The list of team `slug`s with push access
                 */
                teams: Array<string>;
                /**
                 * The list of app `slug`s with push access
                 */
                apps?: Array<string>;
            } | null;
            /**
             * Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation.
             */
            required_linear_history?: boolean;
            /**
             * Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation."
             */
            allow_force_pushes?: boolean | null;
            /**
             * Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.
             */
            allow_deletions?: boolean;
            /**
             * If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.
             */
            block_creations?: boolean;
            /**
             * Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.
             */
            required_conversation_resolution?: boolean;
            /**
             * Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.
             */
            lock_branch?: boolean;
            /**
             * Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.
             */
            allow_fork_syncing?: boolean;
        },
    ): CancelablePromise<protected_branch> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete branch protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteBranchProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                403: `Forbidden`,
            },
        });
    }
    /**
     * Get admin branch protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns protected_branch_admin_enforced Response
     * @throws ApiError
     */
    public static reposGetAdminBranchProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<protected_branch_admin_enforced> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
        });
    }
    /**
     * Set admin branch protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns protected_branch_admin_enforced Response
     * @throws ApiError
     */
    public static reposSetAdminBranchProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<protected_branch_admin_enforced> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
        });
    }
    /**
     * Delete admin branch protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteAdminBranchProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get pull request review protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns protected_branch_pull_request_review Response
     * @throws ApiError
     */
    public static reposGetPullRequestReviewProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<protected_branch_pull_request_review> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
        });
    }
    /**
     * Update pull request review protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
     *
     * > [!NOTE]
     * > Passing new arrays of `users` and `teams` replaces their previous values.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns protected_branch_pull_request_review Response
     * @throws ApiError
     */
    public static reposUpdatePullRequestReviewProtection(
        owner: string,
        repo: string,
        branch: string,
        requestBody?: {
            /**
             * Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
             */
            dismissal_restrictions?: {
                /**
                 * The list of user `login`s with dismissal access
                 */
                users?: Array<string>;
                /**
                 * The list of team `slug`s with dismissal access
                 */
                teams?: Array<string>;
                /**
                 * The list of app `slug`s with dismissal access
                 */
                apps?: Array<string>;
            };
            /**
             * Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
             */
            dismiss_stale_reviews?: boolean;
            /**
             * Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.
             */
            require_code_owner_reviews?: boolean;
            /**
             * Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
             */
            required_approving_review_count?: number;
            /**
             * Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`
             */
            require_last_push_approval?: boolean;
            /**
             * Allow specific users, teams, or apps to bypass pull request requirements.
             */
            bypass_pull_request_allowances?: {
                /**
                 * The list of user `login`s allowed to bypass pull request requirements.
                 */
                users?: Array<string>;
                /**
                 * The list of team `slug`s allowed to bypass pull request requirements.
                 */
                teams?: Array<string>;
                /**
                 * The list of app `slug`s allowed to bypass pull request requirements.
                 */
                apps?: Array<string>;
            };
        },
    ): CancelablePromise<protected_branch_pull_request_review> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete pull request review protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns void
     * @throws ApiError
     */
    public static reposDeletePullRequestReviewProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get commit signature protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help.
     *
     * > [!NOTE]
     * > You must enable branch protection to require signed commits.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns protected_branch_admin_enforced Response
     * @throws ApiError
     */
    public static reposGetCommitSignatureProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<protected_branch_admin_enforced> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create commit signature protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns protected_branch_admin_enforced Response
     * @throws ApiError
     */
    public static reposCreateCommitSignatureProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<protected_branch_admin_enforced> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete commit signature protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteCommitSignatureProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get status checks protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns status_check_policy Response
     * @throws ApiError
     */
    public static reposGetStatusChecksProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<status_check_policy> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update status check protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns status_check_policy Response
     * @throws ApiError
     */
    public static reposUpdateStatusCheckProtection(
        owner: string,
        repo: string,
        branch: string,
        requestBody?: {
            /**
             * Require branches to be up to date before merging.
             */
            strict?: boolean;
            /**
             * **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
             * @deprecated
             */
            contexts?: Array<string>;
            /**
             * The list of status checks to require in order to merge into this branch.
             */
            checks?: Array<{
                /**
                 * The name of the required check
                 */
                context: string;
                /**
                 * The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
                 */
                app_id?: number;
            }>;
        },
    ): CancelablePromise<status_check_policy> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove status check protection
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns void
     * @throws ApiError
     */
    public static reposRemoveStatusCheckProtection(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
        });
    }
    /**
     * Get all status check contexts
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns string Response
     * @throws ApiError
     */
    public static reposGetAllStatusCheckContexts(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<Array<string>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Add status check contexts
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns string Response
     * @throws ApiError
     */
    public static reposAddStatusCheckContexts(
        owner: string,
        repo: string,
        branch: string,
        requestBody?: ({
            /**
             * The name of the status checks
             */
            contexts: Array<string>;
        } | Array<string>),
    ): CancelablePromise<Array<string>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Set status check contexts
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns string Response
     * @throws ApiError
     */
    public static reposSetStatusCheckContexts(
        owner: string,
        repo: string,
        branch: string,
        requestBody?: ({
            /**
             * The name of the status checks
             */
            contexts: Array<string>;
        } | Array<string>),
    ): CancelablePromise<Array<string>> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove status check contexts
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns string Response
     * @throws ApiError
     */
    public static reposRemoveStatusCheckContexts(
        owner: string,
        repo: string,
        branch: string,
        requestBody?: ({
            /**
             * The name of the status checks
             */
            contexts: Array<string>;
        } | Array<string>),
    ): CancelablePromise<Array<string>> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists who has access to this protected branch.
     *
     * > [!NOTE]
     * > Users, apps, and teams `restrictions` are only available for organization-owned repositories.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns branch_restriction_policy Response
     * @throws ApiError
     */
    public static reposGetAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<branch_restriction_policy> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Disables the ability to restrict who can push to this branch.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
        });
    }
    /**
     * Get apps with access to the protected branch
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists the GitHub Apps that have push access to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns integration Response
     * @throws ApiError
     */
    public static reposGetAppsWithAccessToProtectedBranch(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<Array<integration>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Add app access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Grants the specified apps push access for this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns integration Response
     * @throws ApiError
     */
    public static reposAddAppAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
        requestBody: {
            /**
             * The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
             */
            apps: Array<string>;
        },
    ): CancelablePromise<Array<integration>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Set app access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns integration Response
     * @throws ApiError
     */
    public static reposSetAppAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
        requestBody: {
            /**
             * The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
             */
            apps: Array<string>;
        },
    ): CancelablePromise<Array<integration>> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove app access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Removes the ability of an app to push to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns integration Response
     * @throws ApiError
     */
    public static reposRemoveAppAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
        requestBody: {
            /**
             * The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
             */
            apps: Array<string>;
        },
    ): CancelablePromise<Array<integration>> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get teams with access to the protected branch
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists the teams who have push access to this branch. The list includes child teams.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns team Response
     * @throws ApiError
     */
    public static reposGetTeamsWithAccessToProtectedBranch(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<Array<team>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Add team access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Grants the specified teams push access for this branch. You can also give push access to child teams.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns team Response
     * @throws ApiError
     */
    public static reposAddTeamAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
        requestBody?: ({
            /**
             * The slug values for teams
             */
            teams: Array<string>;
        } | Array<string>),
    ): CancelablePromise<Array<team>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Set team access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns team Response
     * @throws ApiError
     */
    public static reposSetTeamAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
        requestBody?: ({
            /**
             * The slug values for teams
             */
            teams: Array<string>;
        } | Array<string>),
    ): CancelablePromise<Array<team>> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove team access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Removes the ability of a team to push to this branch. You can also remove push access for child teams.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns team Response
     * @throws ApiError
     */
    public static reposRemoveTeamAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
        requestBody?: ({
            /**
             * The slug values for teams
             */
            teams: Array<string>;
        } | Array<string>),
    ): CancelablePromise<Array<team>> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get users with access to the protected branch
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists the people who have push access to this branch.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @returns simple_user Response
     * @throws ApiError
     */
    public static reposGetUsersWithAccessToProtectedBranch(
        owner: string,
        repo: string,
        branch: string,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Add user access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Grants the specified people push access for this branch.
     *
     * | Type    | Description                                                                                                                   |
     * | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns simple_user Response
     * @throws ApiError
     */
    public static reposAddUserAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
        requestBody: {
            /**
             * The username for users
             */
            users: Array<string>;
        },
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Set user access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.
     *
     * | Type    | Description                                                                                                                   |
     * | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns simple_user Response
     * @throws ApiError
     */
    public static reposSetUserAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
        requestBody: {
            /**
             * The username for users
             */
            users: Array<string>;
        },
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Remove user access restrictions
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Removes the ability of a user to push to this branch.
     *
     * | Type    | Description                                                                                                                                   |
     * | ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns simple_user Response
     * @throws ApiError
     */
    public static reposRemoveUserAccessRestrictions(
        owner: string,
        repo: string,
        branch: string,
        requestBody: {
            /**
             * The username for users
             */
            users: Array<string>;
        },
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Rename a branch
     * Renames a branch in a repository.
     *
     * > [!NOTE]
     * > Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)".
     *
     * The authenticated user must have push access to the branch. If the branch is the default branch, the authenticated user must also have admin or owner permissions.
     *
     * In order to rename the default branch, fine-grained access tokens also need the `administration:write` repository permission.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param requestBody
     * @returns branch_with_protection Response
     * @throws ApiError
     */
    public static reposRenameBranch(
        owner: string,
        repo: string,
        branch: string,
        requestBody: {
            /**
             * The new name of the branch.
             */
            new_name: string;
        },
    ): CancelablePromise<branch_with_protection> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/branches/{branch}/rename',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List CODEOWNERS errors
     * List any syntax errors that are detected in the CODEOWNERS
     * file.
     *
     * For more information about the correct CODEOWNERS syntax,
     * see "[About code owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param ref A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)
     * @returns codeowners_errors Response
     * @throws ApiError
     */
    public static reposCodeownersErrors(
        owner: string,
        repo: string,
        ref?: string,
    ): CancelablePromise<codeowners_errors> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/codeowners/errors',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'ref': ref,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List repository collaborators
     * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
     * The `permissions` hash returned in the response contains the base role permissions of the collaborator. The `role_name` is the highest role assigned to the collaborator after considering all sources of grants, including: repo, teams, organization, and enterprise.
     * There is presently not a way to differentiate between an organization level grant and a repository level grant from this endpoint response.
     *
     * Team members will include the members of child teams.
     *
     * The authenticated user must have write, maintain, or admin privileges on the repository to use this endpoint. For organization-owned repositories, the authenticated user needs to be a member of the organization.
     * OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param affiliation Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
     * @param permission Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns collaborator Response
     * @throws ApiError
     */
    public static reposListCollaborators(
        owner: string,
        repo: string,
        affiliation: 'outside' | 'direct' | 'all' = 'all',
        permission?: 'pull' | 'triage' | 'push' | 'maintain' | 'admin',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<collaborator>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/collaborators',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'affiliation': affiliation,
                'permission': permission,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Check if a user is a repository collaborator
     * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
     *
     * Team members will include the members of child teams.
     *
     * The authenticated user must have push access to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static reposCheckCollaborator(
        owner: string,
        repo: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/collaborators/{username}',
            path: {
                'owner': owner,
                'repo': repo,
                'username': username,
            },
            errors: {
                404: `Not Found if user is not a collaborator`,
            },
        });
    }
    /**
     * Add a repository collaborator
     * Add a user to a repository with a specified level of access. If the repository is owned by an organization, this API does not add the user to the organization - a user that has repository access without being an organization member is called an "outside collaborator" (if they are not an Enterprise Managed User) or a "repository collaborator" if they are an Enterprise Managed User. These users are exempt from some organization policies - see "[Adding outside collaborators to repositories](https://docs.github.com/organizations/managing-user-access-to-your-organizations-repositories/managing-outside-collaborators/adding-outside-collaborators-to-repositories-in-your-organization)" to learn more about these collaborator types.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     *
     * Adding an outside collaborator may be restricted by enterprise and organization administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)" and "[Setting permissions for adding outside collaborators](https://docs.github.com/organizations/managing-organization-settings/setting-permissions-for-adding-outside-collaborators)" for organization settings.
     *
     * For more information on permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the role being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:
     *
     * ```
     * Cannot assign {member} permission of {role name}
     * ```
     *
     * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
     *
     * The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [API](https://docs.github.com/rest/collaborators/invitations).
     *
     * For Enterprise Managed Users, this endpoint does not send invitations - these users are automatically added to organizations and repositories. Enterprise Managed Users can only be added to organizations and repositories within their enterprise.
     *
     * **Updating an existing collaborator's permission level**
     *
     * The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different `permission` parameter. The response will be a `204`, with no other indication that the permission level changed.
     *
     * **Rate limits**
     *
     * You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @param requestBody
     * @returns repository_invitation Response when a new invitation is created
     * @throws ApiError
     */
    public static reposAddCollaborator(
        owner: string,
        repo: string,
        username: string,
        requestBody?: {
            /**
             * The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.
             */
            permission?: string;
        },
    ): CancelablePromise<repository_invitation> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/collaborators/{username}',
            path: {
                'owner': owner,
                'repo': repo,
                'username': username,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Response when:
                - validation failed, or the endpoint has been spammed
                - an Enterprise Managed User (EMU) account was invited to a repository in an enterprise with personal user accounts`,
            },
        });
    }
    /**
     * Remove a repository collaborator
     * Removes a collaborator from a repository.
     *
     * To use this endpoint, the authenticated user must either be an administrator of the repository or target themselves for removal.
     *
     * This endpoint also:
     * - Cancels any outstanding invitations sent by the collaborator
     * - Unassigns the user from any issues
     * - Removes access to organization projects if the user is not an organization member and is not a collaborator on any other organization repositories.
     * - Unstars the repository
     * - Updates access permissions to packages
     *
     * Removing a user as a collaborator has the following effects on forks:
     * - If the user had access to a fork through their membership to this repository, the user will also be removed from the fork.
     * - If the user had their own fork of the repository, the fork will be deleted.
     * - If the user still has read access to the repository, open pull requests by this user from a fork will be denied.
     *
     * > [!NOTE]
     * > A user can still have access to the repository through organization permissions like base repository permissions.
     *
     * Although the API responds immediately, the additional permission updates might take some extra time to complete in the background.
     *
     * For more information on fork permissions, see "[About permissions and visibility of forks](https://docs.github.com/pull-requests/collaborating-with-pull-requests/working-with-forks/about-permissions-and-visibility-of-forks)".
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static reposRemoveCollaborator(
        owner: string,
        repo: string,
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/collaborators/{username}',
            path: {
                'owner': owner,
                'repo': repo,
                'username': username,
            },
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get repository permissions for a user
     * Checks the repository permission and role of a collaborator.
     *
     * The `permission` attribute provides the legacy base roles of `admin`, `write`, `read`, and `none`, where the
     * `maintain` role is mapped to `write` and the `triage` role is mapped to `read`.
     * The `role_name` attribute provides the name of the assigned role, including custom roles. The
     * `permission` can also be used to determine which base level of access the collaborator has to the repository.
     *
     * The calculated permissions are the highest role assigned to the collaborator after considering all sources of grants, including: repo, teams, organization, and enterprise.
     * There is presently not a way to differentiate between an organization level grant and a repository level grant from this endpoint response.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param username The handle for the GitHub user account.
     * @returns repository_collaborator_permission if user has admin permissions
     * @throws ApiError
     */
    public static reposGetCollaboratorPermissionLevel(
        owner: string,
        repo: string,
        username: string,
    ): CancelablePromise<repository_collaborator_permission> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/collaborators/{username}/permission',
            path: {
                'owner': owner,
                'repo': repo,
                'username': username,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List commit comments for a repository
     * Lists the commit comments for a specified repository. Comments are ordered by ascending ID.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns commit_comment Response
     * @throws ApiError
     */
    public static reposListCommitCommentsForRepo(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<commit_comment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/comments',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get a commit comment
     * Gets a specified commit comment.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @returns commit_comment Response
     * @throws ApiError
     */
    public static reposGetCommitComment(
        owner: string,
        repo: string,
        commentId: number,
    ): CancelablePromise<commit_comment> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/comments/{comment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'comment_id': commentId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a commit comment
     * Updates the contents of a specified commit comment.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param requestBody
     * @returns commit_comment Response
     * @throws ApiError
     */
    public static reposUpdateCommitComment(
        owner: string,
        repo: string,
        commentId: number,
        requestBody: {
            /**
             * The contents of the comment
             */
            body: string;
        },
    ): CancelablePromise<commit_comment> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/comments/{comment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'comment_id': commentId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete a commit comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteCommitComment(
        owner: string,
        repo: string,
        commentId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/comments/{comment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'comment_id': commentId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List commits
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     * | `verified_at` | `string` | The date the signature was verified by GitHub. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param sha SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).
     * @param path Only commits containing this file path will be returned.
     * @param author GitHub username or email address to use to filter by commit author.
     * @param committer GitHub username or email address to use to filter by commit committer.
     * @param since Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
     * @param until Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns commit Response
     * @throws ApiError
     */
    public static reposListCommits(
        owner: string,
        repo: string,
        sha?: string,
        path?: string,
        author?: string,
        committer?: string,
        since?: string,
        until?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<commit>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/commits',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'sha': sha,
                'path': path,
                'author': author,
                'committer': committer,
                'since': since,
                'until': until,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                400: `Bad Request`,
                404: `Resource not found`,
                409: `Conflict`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * List branches for HEAD commit
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commitSha The SHA of the commit.
     * @returns branch_short Response
     * @throws ApiError
     */
    public static reposListBranchesForHeadCommit(
        owner: string,
        repo: string,
        commitSha: string,
    ): CancelablePromise<Array<branch_short>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head',
            path: {
                'owner': owner,
                'repo': repo,
                'commit_sha': commitSha,
            },
            errors: {
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List commit comments
     * Lists the comments for a specified commit.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commitSha The SHA of the commit.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns commit_comment Response
     * @throws ApiError
     */
    public static reposListCommentsForCommit(
        owner: string,
        repo: string,
        commitSha: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<commit_comment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/commits/{commit_sha}/comments',
            path: {
                'owner': owner,
                'repo': repo,
                'commit_sha': commitSha,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create a commit comment
     * Create a comment for a commit using its `:commit_sha`.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
     * - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
     * - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
     * - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commitSha The SHA of the commit.
     * @param requestBody
     * @returns commit_comment Response
     * @throws ApiError
     */
    public static reposCreateCommitComment(
        owner: string,
        repo: string,
        commitSha: string,
        requestBody: {
            /**
             * The contents of the comment.
             */
            body: string;
            /**
             * Relative path of the file to comment on.
             */
            path?: string;
            /**
             * Line index in the diff to comment on.
             */
            position?: number;
            /**
             * **Closing down notice**. Use **position** parameter instead. Line number in the file to comment on.
             */
            line?: number;
        },
    ): CancelablePromise<commit_comment> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/commits/{commit_sha}/comments',
            path: {
                'owner': owner,
                'repo': repo,
                'commit_sha': commitSha,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List pull requests associated with a commit
     * Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, it will return merged and open pull requests associated with the commit.
     *
     * To list the open or merged pull requests associated with a branch, you can set the `commit_sha` parameter to the branch name.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param commitSha The SHA of the commit.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns pull_request_simple Response
     * @throws ApiError
     */
    public static reposListPullRequestsAssociatedWithCommit(
        owner: string,
        repo: string,
        commitSha: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<pull_request_simple>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/commits/{commit_sha}/pulls',
            path: {
                'owner': owner,
                'repo': repo,
                'commit_sha': commitSha,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                409: `Conflict`,
            },
        });
    }
    /**
     * Get a commit
     * Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.
     *
     * > [!NOTE]
     * > If there are more than 300 files in the commit diff and the default JSON media type is requested, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)." Pagination query parameters are not supported for these media types.
     *
     * - **`application/vnd.github.diff`**: Returns the diff of the commit. Larger diffs may time out and return a 5xx status code.
     * - **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property. Larger diffs may time out and return a 5xx status code.
     * - **`application/vnd.github.sha`**: Returns the commit's SHA-1 hash. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     * | `verified_at` | `string` | The date the signature was verified by GitHub. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param ref The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns commit Response
     * @throws ApiError
     */
    public static reposGetCommit(
        owner: string,
        repo: string,
        ref: string,
        page: number = 1,
        perPage: number = 30,
    ): CancelablePromise<commit> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/commits/{ref}',
            path: {
                'owner': owner,
                'repo': repo,
                'ref': ref,
            },
            query: {
                'page': page,
                'per_page': perPage,
            },
            errors: {
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
                500: `Internal Error`,
                503: `Service unavailable`,
            },
        });
    }
    /**
     * Get the combined status for a specific reference
     * Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.
     *
     *
     * Additionally, a combined `state` is returned. The `state` is one of:
     *
     * *   **failure** if any of the contexts report as `error` or `failure`
     * *   **pending** if there are no statuses or a context is `pending`
     * *   **success** if the latest status for all contexts is `success`
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param ref The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns combined_commit_status Response
     * @throws ApiError
     */
    public static reposGetCombinedStatusForRef(
        owner: string,
        repo: string,
        ref: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<combined_commit_status> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/commits/{ref}/status',
            path: {
                'owner': owner,
                'repo': repo,
                'ref': ref,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List commit statuses for a reference
     * Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.
     *
     * This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param ref The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns status Response
     * @throws ApiError
     */
    public static reposListCommitStatusesForRef(
        owner: string,
        repo: string,
        ref: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<status>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/commits/{ref}/statuses',
            path: {
                'owner': owner,
                'repo': repo,
                'ref': ref,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                301: `Moved permanently`,
            },
        });
    }
    /**
     * Get community profile metrics
     * Returns all community profile metrics for a repository. The repository cannot be a fork.
     *
     * The returned metrics include an overall health score, the repository description, the presence of documentation, the
     * detected code of conduct, the detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
     * README, and CONTRIBUTING files.
     *
     * The `health_percentage` score is defined as a percentage of how many of
     * the recommended community health files are present. For more information, see
     * "[About community profiles for public repositories](https://docs.github.com/communities/setting-up-your-project-for-healthy-contributions/about-community-profiles-for-public-repositories)."
     *
     * `content_reports_enabled` is only returned for organization-owned repositories.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns community_profile Response
     * @throws ApiError
     */
    public static reposGetCommunityProfileMetrics(
        owner: string,
        repo: string,
    ): CancelablePromise<community_profile> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/community/profile',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Compare two commits
     * Compares two commits against one another. You can compare refs (branches or tags) and commit SHAs in the same repository, or you can compare refs and commit SHAs that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see "[Understanding connections between repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."
     *
     * This endpoint is equivalent to running the `git log BASE..HEAD` command, but it returns commits in a different order. The `git log BASE..HEAD` command returns commits in reverse chronological order, whereas the API returns commits in chronological order.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.diff`**: Returns the diff of the commit.
     * - **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property.
     *
     * The API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
     *
     * When calling this endpoint without any paging parameter (`per_page` or `page`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.
     *
     * **Working with large comparisons**
     *
     * To process a response with a large number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When using pagination:
     *
     * - The list of changed files is only shown on the first page of results, and it includes up to 300 changed files for the entire comparison.
     * - The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.
     *
     * For more information on working with pagination, see "[Using pagination in the REST API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)."
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The `verification` object includes the following fields:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     * | `verified_at` | `string` | The date the signature was verified by GitHub. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param basehead The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns commit_comparison Response
     * @throws ApiError
     */
    public static reposCompareCommits(
        owner: string,
        repo: string,
        basehead: string,
        page: number = 1,
        perPage: number = 30,
    ): CancelablePromise<commit_comparison> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/compare/{basehead}',
            path: {
                'owner': owner,
                'repo': repo,
                'basehead': basehead,
            },
            query: {
                'page': page,
                'per_page': perPage,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
                503: `Service unavailable`,
            },
        });
    }
    /**
     * Get repository content
     * Gets the contents of a file or directory in a repository. Specify the file path or directory with the `path` parameter. If you omit the `path` parameter, you will receive the contents of the repository's root directory.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw file contents for files and symlinks.
     * - **`application/vnd.github.html+json`**: Returns the file contents in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
     * - **`application/vnd.github.object+json`**: Returns the contents in a consistent object format regardless of the content type. For example, instead of an array of objects for a directory, the response will be an object with an `entries` attribute containing the array of objects.
     *
     * If the content is a directory, the response will be an array of objects, one object for each item in the directory. When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value _should_ be "submodule". This behavior exists [for backwards compatibility purposes](https://git.io/v1YCW). In the next major version of the API, the type will be returned as "submodule".
     *
     * If the content is a symlink and the symlink's target is a normal file in the repository, then the API responds with the content of the file. Otherwise, the API responds with an object describing the symlink itself.
     *
     * If the content is a submodule, the `submodule_git_url` field identifies the location of the submodule repository, and the `sha` identifies a specific commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out the submodule at that specific commit. If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the github.com URLs (`html_url` and `_links["html"]`) will have null values.
     *
     * **Notes**:
     *
     * - To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/git/trees#get-a-tree).
     * - This API has an upper limit of 1,000 files for a directory. If you need to retrieve
     * more files, use the [Git Trees API](https://docs.github.com/rest/git/trees#get-a-tree).
     * - Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.
     * - If the requested file's size is:
     * - 1 MB or smaller: All features of this endpoint are supported.
     * - Between 1-100 MB: Only the `raw` or `object` custom media types are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty
     * string and the `encoding` field will be `"none"`. To get the contents of these larger files, use the `raw` media type.
     * - Greater than 100 MB: This endpoint is not supported.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param path path parameter
     * @param ref The name of the commit/branch/tag. Default: the repositorys default branch.
     * @returns any Response
     * @throws ApiError
     */
    public static reposGetContent(
        owner: string,
        repo: string,
        path: string,
        ref?: string,
    ): CancelablePromise<(content_directory | content_file | content_symlink | content_submodule)> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/contents/{path}',
            path: {
                'owner': owner,
                'repo': repo,
                'path': path,
            },
            query: {
                'ref': ref,
            },
            errors: {
                302: `Found`,
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create or update file contents
     * Creates a new file or replaces an existing file in a repository.
     *
     * > [!NOTE]
     * > If you use this endpoint and the "[Delete a file](https://docs.github.com/rest/repos/contents/#delete-a-file)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The `workflow` scope is also required in order to modify files in the `.github/workflows` directory.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param path path parameter
     * @param requestBody
     * @returns file_commit Response
     * @throws ApiError
     */
    public static reposCreateOrUpdateFileContents(
        owner: string,
        repo: string,
        path: string,
        requestBody: {
            /**
             * The commit message.
             */
            message: string;
            /**
             * The new file content, using Base64 encoding.
             */
            content: string;
            /**
             * **Required if you are updating a file**. The blob SHA of the file being replaced.
             */
            sha?: string;
            /**
             * The branch name. Default: the repositorys default branch.
             */
            branch?: string;
            /**
             * The person that committed the file. Default: the authenticated user.
             */
            committer?: {
                /**
                 * The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
                 */
                name: string;
                /**
                 * The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
                 */
                email: string;
                date?: string;
            };
            /**
             * The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
             */
            author?: {
                /**
                 * The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
                 */
                name: string;
                /**
                 * The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
                 */
                email: string;
                date?: string;
            };
        },
    ): CancelablePromise<file_commit> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/contents/{path}',
            path: {
                'owner': owner,
                'repo': repo,
                'path': path,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete a file
     * Deletes a file in a repository.
     *
     * You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.
     *
     * The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.
     *
     * You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.
     *
     * > [!NOTE]
     * > If you use this endpoint and the "[Create or update file contents](https://docs.github.com/rest/repos/contents/#create-or-update-file-contents)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param path path parameter
     * @param requestBody
     * @returns file_commit Response
     * @throws ApiError
     */
    public static reposDeleteFile(
        owner: string,
        repo: string,
        path: string,
        requestBody: {
            /**
             * The commit message.
             */
            message: string;
            /**
             * The blob SHA of the file being deleted.
             */
            sha: string;
            /**
             * The branch name. Default: the repositorys default branch
             */
            branch?: string;
            /**
             * object containing information about the committer.
             */
            committer?: {
                /**
                 * The name of the author (or committer) of the commit
                 */
                name?: string;
                /**
                 * The email of the author (or committer) of the commit
                 */
                email?: string;
            };
            /**
             * object containing information about the author.
             */
            author?: {
                /**
                 * The name of the author (or committer) of the commit
                 */
                name?: string;
                /**
                 * The email of the author (or committer) of the commit
                 */
                email?: string;
            };
        },
    ): CancelablePromise<file_commit> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/contents/{path}',
            path: {
                'owner': owner,
                'repo': repo,
                'path': path,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
                503: `Service unavailable`,
            },
        });
    }
    /**
     * List repository contributors
     * Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.
     *
     * GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param anon Set to `1` or `true` to include anonymous contributors in results.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns contributor If repository contains content
     * @throws ApiError
     */
    public static reposListContributors(
        owner: string,
        repo: string,
        anon?: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<contributor>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/contributors',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'anon': anon,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List deployments
     * Simple filtering of deployments is available via query parameters:
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param sha The SHA recorded at creation time.
     * @param ref The name of the ref. This can be a branch, tag, or SHA.
     * @param task The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
     * @param environment The name of the environment that was deployed to (e.g., `staging` or `production`).
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns deployment Response
     * @throws ApiError
     */
    public static reposListDeployments(
        owner: string,
        repo: string,
        sha: string = 'none',
        ref: string = 'none',
        task: string = 'none',
        environment: string | null = 'none',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<deployment>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/deployments',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'sha': sha,
                'ref': ref,
                'task': task,
                'environment': environment,
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create a deployment
     * Deployments offer a few configurable parameters with certain defaults.
     *
     * The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
     * before we merge a pull request.
     *
     * The `environment` parameter allows deployments to be issued to different runtime environments. Teams often have
     * multiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter
     * makes it easier to track which environments have requested deployments. The default environment is `production`.
     *
     * The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
     * the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
     * the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
     * return a failure response.
     *
     * By default, [commit statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be in a `success`
     * state. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to
     * specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
     * not require any contexts or create any commit statuses, the deployment will always succeed.
     *
     * The `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text
     * field that will be passed on when a deployment event is dispatched.
     *
     * The `task` parameter is used by the deployment system to allow different execution paths. In the web world this might
     * be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an
     * application with debugging enabled.
     *
     * Merged branch response:
     *
     * You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
     * a deployment. This auto-merge happens when:
     * *   Auto-merge option is enabled in the repository
     * *   Topic branch does not include the latest changes on the base branch, which is `master` in the response example
     * *   There are no merge conflicts
     *
     * If there are no new commits in the base branch, a new request to create a deployment should give a successful
     * response.
     *
     * Merge conflict response:
     *
     * This error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't
     * be merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.
     *
     * Failed commit status checks:
     *
     * This error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`
     * status for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns deployment Response
     * @returns any Merged branch response
     * @throws ApiError
     */
    public static reposCreateDeployment(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The ref to deploy. This can be a branch, tag, or SHA.
             */
            ref: string;
            /**
             * Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
             */
            task?: string;
            /**
             * Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.
             */
            auto_merge?: boolean;
            /**
             * The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.
             */
            required_contexts?: Array<string>;
            payload?: (Record<string, any> | string);
            /**
             * Name for the target deployment environment (e.g., `production`, `staging`, `qa`).
             */
            environment?: string;
            /**
             * Short description of the deployment.
             */
            description?: string | null;
            /**
             * Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`
             */
            transient_environment?: boolean;
            /**
             * Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.
             */
            production_environment?: boolean;
        },
    ): CancelablePromise<deployment | {
        message?: string;
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/deployments',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                409: `Conflict when there is a merge conflict or the commit's status checks failed`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a deployment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param deploymentId deployment_id parameter
     * @returns deployment Response
     * @throws ApiError
     */
    public static reposGetDeployment(
        owner: string,
        repo: string,
        deploymentId: number,
    ): CancelablePromise<deployment> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/deployments/{deployment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'deployment_id': deploymentId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete a deployment
     * If the repository only has one deployment, you can delete the deployment regardless of its status. If the repository has more than one deployment, you can only delete inactive deployments. This ensures that repositories with multiple deployments will always have an active deployment.
     *
     * To set a deployment as inactive, you must:
     *
     * *   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
     * *   Mark the active deployment as inactive by adding any non-successful deployment status.
     *
     * For more information, see "[Create a deployment](https://docs.github.com/rest/deployments/deployments/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/rest/deployments/statuses#create-a-deployment-status)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param deploymentId deployment_id parameter
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteDeployment(
        owner: string,
        repo: string,
        deploymentId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/deployments/{deployment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'deployment_id': deploymentId,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List deployment statuses
     * Users with pull access can view deployment statuses for a deployment:
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param deploymentId deployment_id parameter
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns deployment_status Response
     * @throws ApiError
     */
    public static reposListDeploymentStatuses(
        owner: string,
        repo: string,
        deploymentId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<deployment_status>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/deployments/{deployment_id}/statuses',
            path: {
                'owner': owner,
                'repo': repo,
                'deployment_id': deploymentId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a deployment status
     * Users with `push` access can create deployment statuses for a given deployment.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo_deployment` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param deploymentId deployment_id parameter
     * @param requestBody
     * @returns deployment_status Response
     * @throws ApiError
     */
    public static reposCreateDeploymentStatus(
        owner: string,
        repo: string,
        deploymentId: number,
        requestBody: {
            /**
             * The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
             */
            state: 'error' | 'failure' | 'inactive' | 'in_progress' | 'queued' | 'pending' | 'success';
            /**
             * The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment.
             *
             * > [!NOTE]
             * > It's recommended to use the `log_url` parameter, which replaces `target_url`.
             */
            target_url?: string;
            /**
             * The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`
             */
            log_url?: string;
            /**
             * A short description of the status. The maximum description length is 140 characters.
             */
            description?: string;
            /**
             * Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used.
             */
            environment?: string;
            /**
             * Sets the URL for accessing your environment. Default: `""`
             */
            environment_url?: string;
            /**
             * Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`
             */
            auto_inactive?: boolean;
        },
    ): CancelablePromise<deployment_status> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/deployments/{deployment_id}/statuses',
            path: {
                'owner': owner,
                'repo': repo,
                'deployment_id': deploymentId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a deployment status
     * Users with pull access can view a deployment status for a deployment:
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param deploymentId deployment_id parameter
     * @param statusId
     * @returns deployment_status Response
     * @throws ApiError
     */
    public static reposGetDeploymentStatus(
        owner: string,
        repo: string,
        deploymentId: number,
        statusId: number,
    ): CancelablePromise<deployment_status> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'deployment_id': deploymentId,
                'status_id': statusId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a repository dispatch event
     * You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
     *
     * The `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
     *
     * This input example shows how you can use the `client_payload` as a test to debug your workflow.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static reposCreateDispatchEvent(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * A custom webhook event name. Must be 100 characters or fewer.
             */
            event_type: string;
            /**
             * JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB.
             */
            client_payload?: Record<string, any>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/dispatches',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List environments
     * Lists the environments for a repository.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static reposGetAllEnvironments(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        /**
         * The number of environments in this repository
         */
        total_count?: number;
        environments?: Array<environment>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get an environment
     * > [!NOTE]
     * > To get information about name patterns that branches must match in order to deploy to this environment, see "[Get a deployment branch policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)."
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @returns environment Response
     * @throws ApiError
     */
    public static reposGetEnvironment(
        owner: string,
        repo: string,
        environmentName: string,
    ): CancelablePromise<environment> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
            },
        });
    }
    /**
     * Create or update an environment
     * Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."
     *
     * > [!NOTE]
     * > To create or update name patterns that branches must match in order to deploy to this environment, see "[Deployment branch policies](/rest/deployments/branch-policies)."
     *
     * > [!NOTE]
     * > To create or update secrets for an environment, see "[GitHub Actions secrets](/rest/actions/secrets)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param requestBody
     * @returns environment Response
     * @throws ApiError
     */
    public static reposCreateOrUpdateEnvironment(
        owner: string,
        repo: string,
        environmentName: string,
        requestBody?: {
            wait_timer?: wait_timer;
            prevent_self_review?: prevent_self_review;
            /**
             * The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
             */
            reviewers?: Array<{
                type?: deployment_reviewer_type;
                /**
                 * The id of the user or team who can review the deployment
                 */
                id?: number;
            }> | null;
            deployment_branch_policy?: deployment_branch_policy_settings;
        } | null,
    ): CancelablePromise<environment> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/environments/{environment_name}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation error when the environment name is invalid or when \`protected_branches\` and \`custom_branch_policies\` in \`deployment_branch_policy\` are set to the same value`,
            },
        });
    }
    /**
     * Delete an environment
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteAnEnvironment(
        owner: string,
        repo: string,
        environmentName: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/environments/{environment_name}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
            },
        });
    }
    /**
     * List deployment branch policies
     * Lists the deployment branch policies for an environment.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static reposListDeploymentBranchPolicies(
        owner: string,
        repo: string,
        environmentName: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<{
        /**
         * The number of deployment branch policies for the environment.
         */
        total_count: number;
        branch_policies: Array<deployment_branch_policy>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create a deployment branch policy
     * Creates a deployment branch or tag policy for an environment.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param requestBody
     * @returns deployment_branch_policy Response
     * @throws ApiError
     */
    public static reposCreateDeploymentBranchPolicy(
        owner: string,
        repo: string,
        environmentName: string,
        requestBody: deployment_branch_policy_name_pattern_with_type,
    ): CancelablePromise<deployment_branch_policy> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                303: `Response if the same branch name pattern already exists`,
                404: `Not Found or \`deployment_branch_policy.custom_branch_policies\` property for the environment is set to false`,
            },
        });
    }
    /**
     * Get a deployment branch policy
     * Gets a deployment branch or tag policy for an environment.
     *
     * Anyone with read access to the repository can use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param branchPolicyId The unique identifier of the branch policy.
     * @returns deployment_branch_policy Response
     * @throws ApiError
     */
    public static reposGetDeploymentBranchPolicy(
        owner: string,
        repo: string,
        environmentName: string,
        branchPolicyId: number,
    ): CancelablePromise<deployment_branch_policy> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
                'branch_policy_id': branchPolicyId,
            },
        });
    }
    /**
     * Update a deployment branch policy
     * Updates a deployment branch or tag policy for an environment.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param branchPolicyId The unique identifier of the branch policy.
     * @param requestBody
     * @returns deployment_branch_policy Response
     * @throws ApiError
     */
    public static reposUpdateDeploymentBranchPolicy(
        owner: string,
        repo: string,
        environmentName: string,
        branchPolicyId: number,
        requestBody: deployment_branch_policy_name_pattern,
    ): CancelablePromise<deployment_branch_policy> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
                'branch_policy_id': branchPolicyId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a deployment branch policy
     * Deletes a deployment branch or tag policy for an environment.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param branchPolicyId The unique identifier of the branch policy.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteDeploymentBranchPolicy(
        owner: string,
        repo: string,
        environmentName: string,
        branchPolicyId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
                'branch_policy_id': branchPolicyId,
            },
        });
    }
    /**
     * Get all deployment protection rules for an environment
     * Gets all custom deployment protection rules that are enabled for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
     *
     * For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app).
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @returns any List of deployment protection rules
     * @throws ApiError
     */
    public static reposGetAllDeploymentProtectionRules(
        environmentName: string,
        repo: string,
        owner: string,
    ): CancelablePromise<{
        /**
         * The number of enabled custom deployment protection rules for this environment
         */
        total_count?: number;
        custom_deployment_protection_rules?: Array<deployment_protection_rule>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules',
            path: {
                'environment_name': environmentName,
                'repo': repo,
                'owner': owner,
            },
        });
    }
    /**
     * Create a custom deployment protection rule on an environment
     * Enable a custom deployment protection rule for an environment.
     *
     * The authenticated user must have admin or owner permissions to the repository to use this endpoint.
     *
     * For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app), as well as the [guide to creating custom deployment protection rules](https://docs.github.com/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules).
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param requestBody
     * @returns deployment_protection_rule The enabled custom deployment protection rule
     * @throws ApiError
     */
    public static reposCreateDeploymentProtectionRule(
        environmentName: string,
        repo: string,
        owner: string,
        requestBody: {
            /**
             * The ID of the custom app that will be enabled on the environment.
             */
            integration_id?: number;
        },
    ): CancelablePromise<deployment_protection_rule> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules',
            path: {
                'environment_name': environmentName,
                'repo': repo,
                'owner': owner,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List custom deployment rule integrations available for an environment
     * Gets all custom deployment protection rule integrations that are available for an environment.
     *
     * The authenticated user must have admin or owner permissions to the repository to use this endpoint.
     *
     * For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
     *
     * For more information about the app that is providing this custom deployment rule, see "[GET an app](https://docs.github.com/rest/apps/apps#get-an-app)".
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any A list of custom deployment rule integrations available for this environment.
     * @throws ApiError
     */
    public static reposListCustomDeploymentRuleIntegrations(
        environmentName: string,
        repo: string,
        owner: string,
        page: number = 1,
        perPage: number = 30,
    ): CancelablePromise<{
        /**
         * The total number of custom deployment protection rule integrations available for this environment.
         */
        total_count?: number;
        available_custom_deployment_protection_rule_integrations?: Array<custom_deployment_rule_app>;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps',
            path: {
                'environment_name': environmentName,
                'repo': repo,
                'owner': owner,
            },
            query: {
                'page': page,
                'per_page': perPage,
            },
        });
    }
    /**
     * Get a custom deployment protection rule
     * Gets an enabled custom deployment protection rule for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
     *
     * For more information about the app that is providing this custom deployment rule, see [`GET /apps/{app_slug}`](https://docs.github.com/rest/apps/apps#get-an-app).
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param protectionRuleId The unique identifier of the protection rule.
     * @returns deployment_protection_rule Response
     * @throws ApiError
     */
    public static reposGetCustomDeploymentProtectionRule(
        owner: string,
        repo: string,
        environmentName: string,
        protectionRuleId: number,
    ): CancelablePromise<deployment_protection_rule> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'environment_name': environmentName,
                'protection_rule_id': protectionRuleId,
            },
        });
    }
    /**
     * Disable a custom protection rule for an environment
     * Disables a custom deployment protection rule for an environment.
     *
     * The authenticated user must have admin or owner permissions to the repository to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param environmentName The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param protectionRuleId The unique identifier of the protection rule.
     * @returns void
     * @throws ApiError
     */
    public static reposDisableDeploymentProtectionRule(
        environmentName: string,
        repo: string,
        owner: string,
        protectionRuleId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}',
            path: {
                'environment_name': environmentName,
                'repo': repo,
                'owner': owner,
                'protection_rule_id': protectionRuleId,
            },
        });
    }
    /**
     * List forks
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param sort The sort order. `stargazers` will sort by star count.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns minimal_repository Response
     * @throws ApiError
     */
    public static reposListForks(
        owner: string,
        repo: string,
        sort: 'newest' | 'oldest' | 'stargazers' | 'watchers' = 'newest',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<minimal_repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/forks',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'sort': sort,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                400: `Bad Request`,
            },
        });
    }
    /**
     * Create a fork
     * Create a fork for the authenticated user.
     *
     * > [!NOTE]
     * > Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
     *
     * > [!NOTE]
     * > Although this endpoint works with GitHub Apps, the GitHub App must be installed on the destination account with access to all repositories and on the source account with access to the source repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns full_repository Response
     * @throws ApiError
     */
    public static reposCreateFork(
        owner: string,
        repo: string,
        requestBody?: {
            /**
             * Optional parameter to specify the organization name if forking into an organization.
             */
            organization?: string;
            /**
             * When forking from an existing repository, a new name for the fork.
             */
            name?: string;
            /**
             * When forking from an existing repository, fork with only the default branch.
             */
            default_branch_only?: boolean;
        } | null,
    ): CancelablePromise<full_repository> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/forks',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List repository webhooks
     * Lists webhooks for a repository. `last response` may return null if there have not been any deliveries within 30 days.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns hook Response
     * @throws ApiError
     */
    public static reposListWebhooks(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<hook>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/hooks',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a repository webhook
     * Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
     * share the same `config` as long as those webhooks do not have any `events` that overlap.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns hook Response
     * @throws ApiError
     */
    public static reposCreateWebhook(
        owner: string,
        repo: string,
        requestBody?: {
            /**
             * Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.
             */
            name?: string;
            /**
             * Key/value pairs to provide settings for this webhook.
             */
            config?: {
                url?: webhook_config_url;
                content_type?: webhook_config_content_type;
                secret?: webhook_config_secret;
                insecure_ssl?: webhook_config_insecure_ssl;
            };
            /**
             * Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.
             */
            events?: Array<string>;
            /**
             * Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
             */
            active?: boolean;
        } | null,
    ): CancelablePromise<hook> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/hooks',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a repository webhook
     * Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/webhooks/repo-config#get-a-webhook-configuration-for-a-repository)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @returns hook Response
     * @throws ApiError
     */
    public static reposGetWebhook(
        owner: string,
        repo: string,
        hookId: number,
    ): CancelablePromise<hook> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a repository webhook
     * Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/webhooks/repo-config#update-a-webhook-configuration-for-a-repository)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param requestBody
     * @returns hook Response
     * @throws ApiError
     */
    public static reposUpdateWebhook(
        owner: string,
        repo: string,
        hookId: number,
        requestBody: {
            config?: webhook_config;
            /**
             * Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.
             */
            events?: Array<string>;
            /**
             * Determines a list of events to be added to the list of events that the Hook triggers for.
             */
            add_events?: Array<string>;
            /**
             * Determines a list of events to be removed from the list of events that the Hook triggers for.
             */
            remove_events?: Array<string>;
            /**
             * Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
             */
            active?: boolean;
        },
    ): CancelablePromise<hook> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete a repository webhook
     * Delete a webhook for an organization.
     *
     * The authenticated user must be a repository owner, or have admin access in the repository, to delete the webhook.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteWebhook(
        owner: string,
        repo: string,
        hookId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a webhook configuration for a repository
     * Returns the webhook configuration for a repository. To get more information about the webhook, including the `active` state and `events`, use "[Get a repository webhook](/rest/webhooks/repos#get-a-repository-webhook)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `read:repo_hook` or `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @returns webhook_config Response
     * @throws ApiError
     */
    public static reposGetWebhookConfigForRepo(
        owner: string,
        repo: string,
        hookId: number,
    ): CancelablePromise<webhook_config> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}/config',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
            },
        });
    }
    /**
     * Update a webhook configuration for a repository
     * Updates the webhook configuration for a repository. To update more information about the webhook, including the `active` state and `events`, use "[Update a repository webhook](/rest/webhooks/repos#update-a-repository-webhook)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `write:repo_hook` or `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param requestBody
     * @returns webhook_config Response
     * @throws ApiError
     */
    public static reposUpdateWebhookConfigForRepo(
        owner: string,
        repo: string,
        hookId: number,
        requestBody?: {
            url?: webhook_config_url;
            content_type?: webhook_config_content_type;
            secret?: webhook_config_secret;
            insecure_ssl?: webhook_config_insecure_ssl;
        },
    ): CancelablePromise<webhook_config> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}/config',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List deliveries for a repository webhook
     * Returns a list of webhook deliveries for a webhook configured in a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param cursor Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
     * @returns hook_delivery_item Response
     * @throws ApiError
     */
    public static reposListWebhookDeliveries(
        owner: string,
        repo: string,
        hookId: number,
        perPage: number = 30,
        cursor?: string,
    ): CancelablePromise<Array<hook_delivery_item>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}/deliveries',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
            },
            query: {
                'per_page': perPage,
                'cursor': cursor,
            },
            errors: {
                400: `Bad Request`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a delivery for a repository webhook
     * Returns a delivery for a webhook configured in a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param deliveryId
     * @returns hook_delivery Response
     * @throws ApiError
     */
    public static reposGetWebhookDelivery(
        owner: string,
        repo: string,
        hookId: number,
        deliveryId: number,
    ): CancelablePromise<hook_delivery> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
                'delivery_id': deliveryId,
            },
            errors: {
                400: `Bad Request`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Redeliver a delivery for a repository webhook
     * Redeliver a webhook delivery for a webhook configured in a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @param deliveryId
     * @returns any Accepted
     * @throws ApiError
     */
    public static reposRedeliverWebhookDelivery(
        owner: string,
        repo: string,
        hookId: number,
        deliveryId: number,
    ): CancelablePromise<Record<string, any>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
                'delivery_id': deliveryId,
            },
            errors: {
                400: `Bad Request`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Ping a repository webhook
     * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @returns void
     * @throws ApiError
     */
    public static reposPingWebhook(
        owner: string,
        repo: string,
        hookId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}/pings',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Test the push repository webhook
     * This will trigger the hook with the latest push to the current repository if the hook is subscribed to `push` events. If the hook is not subscribed to `push` events, the server will respond with 204 but no test POST will be generated.
     *
     * > [!NOTE]
     * > Previously `/repos/:owner/:repo/hooks/:hook_id/test`
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param hookId The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
     * @returns void
     * @throws ApiError
     */
    public static reposTestPushWebhook(
        owner: string,
        repo: string,
        hookId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/hooks/{hook_id}/tests',
            path: {
                'owner': owner,
                'repo': repo,
                'hook_id': hookId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Check if immutable releases are enabled for a repository
     * Shows whether immutable releases are enabled or disabled. Also identifies whether immutability is being
     * enforced by the repository owner.  The authenticated user must have admin read access to the repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns check_immutable_releases Response if immutable releases are enabled
     * @throws ApiError
     */
    public static reposCheckImmutableReleases(
        owner: string,
        repo: string,
    ): CancelablePromise<check_immutable_releases> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/immutable-releases',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                404: `Not Found if immutable releases are not enabled for the repository`,
            },
        });
    }
    /**
     * Enable immutable releases
     * Enables immutable releases for a repository. The authenticated user must have admin access to the repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposEnableImmutableReleases(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/immutable-releases',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                409: `Conflict`,
            },
        });
    }
    /**
     * Disable immutable releases
     * Disables immutable releases for a repository. The authenticated user must have admin access to the repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposDisableImmutableReleases(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/immutable-releases',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                409: `Conflict`,
            },
        });
    }
    /**
     * List repository invitations
     * When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns repository_invitation Response
     * @throws ApiError
     */
    public static reposListInvitations(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<repository_invitation>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/invitations',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Update a repository invitation
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param invitationId The unique identifier of the invitation.
     * @param requestBody
     * @returns repository_invitation Response
     * @throws ApiError
     */
    public static reposUpdateInvitation(
        owner: string,
        repo: string,
        invitationId: number,
        requestBody?: {
            /**
             * The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.
             */
            permissions?: 'read' | 'write' | 'maintain' | 'triage' | 'admin';
        },
    ): CancelablePromise<repository_invitation> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/invitations/{invitation_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'invitation_id': invitationId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a repository invitation
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param invitationId The unique identifier of the invitation.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteInvitation(
        owner: string,
        repo: string,
        invitationId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/invitations/{invitation_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'invitation_id': invitationId,
            },
        });
    }
    /**
     * List deploy keys
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns deploy_key Response
     * @throws ApiError
     */
    public static reposListDeployKeys(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<deploy_key>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/keys',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Create a deploy key
     * You can create a read-only deploy key.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns deploy_key Response
     * @throws ApiError
     */
    public static reposCreateDeployKey(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * A name for the key.
             */
            title?: string;
            /**
             * The contents of the key.
             */
            key: string;
            /**
             * If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.
             *
             * Deploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/)."
             */
            read_only?: boolean;
        },
    ): CancelablePromise<deploy_key> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/keys',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a deploy key
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param keyId The unique identifier of the key.
     * @returns deploy_key Response
     * @throws ApiError
     */
    public static reposGetDeployKey(
        owner: string,
        repo: string,
        keyId: number,
    ): CancelablePromise<deploy_key> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/keys/{key_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'key_id': keyId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete a deploy key
     * Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param keyId The unique identifier of the key.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteDeployKey(
        owner: string,
        repo: string,
        keyId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/keys/{key_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'key_id': keyId,
            },
        });
    }
    /**
     * List repository languages
     * Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns language Response
     * @throws ApiError
     */
    public static reposListLanguages(
        owner: string,
        repo: string,
    ): CancelablePromise<language> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/languages',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Sync a fork branch with the upstream repository
     * Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns merged_upstream The branch has been successfully synced with the upstream repository
     * @throws ApiError
     */
    public static reposMergeUpstream(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The name of the branch which should be updated to match upstream.
             */
            branch: string;
        },
    ): CancelablePromise<merged_upstream> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/merge-upstream',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                409: `The branch could not be synced because of a merge conflict`,
                422: `The branch could not be synced for some other reason`,
            },
        });
    }
    /**
     * Merge a branch
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns commit Successful Response (The resulting merge commit)
     * @throws ApiError
     */
    public static reposMerge(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The name of the base branch that the head will be merged into.
             */
            base: string;
            /**
             * The head to merge. This can be a branch name or a commit SHA1.
             */
            head: string;
            /**
             * Commit message to use for the merge commit. If omitted, a default message will be used.
             */
            commit_message?: string;
        },
    ): CancelablePromise<commit> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/merges',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Not Found when the base or head does not exist`,
                409: `Conflict when there is a merge conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a GitHub Pages site
     * Gets information about a GitHub Pages site.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns page Response
     * @throws ApiError
     */
    public static reposGetPages(
        owner: string,
        repo: string,
    ): CancelablePromise<page> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pages',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a GitHub Pages site
     * Configures a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)."
     *
     * The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns page Response
     * @throws ApiError
     */
    public static reposCreatePagesSite(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The process in which the Page will be built. Possible values are `"legacy"` and `"workflow"`.
             */
            build_type?: 'legacy' | 'workflow';
            /**
             * The source branch and directory used to publish your Pages site.
             */
            source?: {
                /**
                 * The repository branch used to publish your site's source files.
                 */
                branch: string;
                /**
                 * The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`. Default: `/`
                 */
                path?: '/' | '/docs';
            };
        } | null,
    ): CancelablePromise<page> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pages',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Update information about a GitHub Pages site
     * Updates information for a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
     *
     * The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static reposUpdateInformationAboutPagesSite(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see "[Using a custom domain with GitHub Pages](https://docs.github.com/pages/configuring-a-custom-domain-for-your-github-pages-site)."
             */
            cname?: string | null;
            /**
             * Specify whether HTTPS should be enforced for the repository.
             */
            https_enforced?: boolean;
            /**
             * The process by which the GitHub Pages site will be built. `workflow` means that the site is built by a custom GitHub Actions workflow. `legacy` means that the site is built by GitHub when changes are pushed to a specific branch.
             */
            build_type?: 'legacy' | 'workflow';
            source?: ('gh-pages' | 'master' | 'master /docs' | {
                /**
                 * The repository branch used to publish your site's source files.
                 */
                branch: string;
                /**
                 * The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`.
                 */
                path: '/' | '/docs';
            });
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/pages',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete a GitHub Pages site
     * Deletes a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
     *
     * The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposDeletePagesSite(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/pages',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                404: `Resource not found`,
                409: `Conflict`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List GitHub Pages builds
     * Lists builts of a GitHub Pages site.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns page_build Response
     * @throws ApiError
     */
    public static reposListPagesBuilds(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<page_build>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pages/builds',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Request a GitHub Pages build
     * You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
     *
     * Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns page_build_status Response
     * @throws ApiError
     */
    public static reposRequestPagesBuild(
        owner: string,
        repo: string,
    ): CancelablePromise<page_build_status> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pages/builds',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Get latest Pages build
     * Gets information about the single most recent build of a GitHub Pages site.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns page_build Response
     * @throws ApiError
     */
    public static reposGetLatestPagesBuild(
        owner: string,
        repo: string,
    ): CancelablePromise<page_build> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pages/builds/latest',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Get GitHub Pages build
     * Gets information about a GitHub Pages build.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param buildId
     * @returns page_build Response
     * @throws ApiError
     */
    public static reposGetPagesBuild(
        owner: string,
        repo: string,
        buildId: number,
    ): CancelablePromise<page_build> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pages/builds/{build_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'build_id': buildId,
            },
        });
    }
    /**
     * Create a GitHub Pages deployment
     * Create a GitHub Pages deployment for a repository.
     *
     * The authenticated user must have write permission to the repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns page_deployment Response
     * @throws ApiError
     */
    public static reposCreatePagesDeployment(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
             */
            artifact_id?: number;
            /**
             * The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
             */
            artifact_url?: string;
            /**
             * The target environment for this GitHub Pages deployment.
             */
            environment?: string;
            /**
             * A unique string that represents the version of the build for this deployment.
             */
            pages_build_version: string;
            /**
             * The OIDC token issued by GitHub Actions certifying the origin of the deployment.
             */
            oidc_token: string;
        },
    ): CancelablePromise<page_deployment> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pages/deployments',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get the status of a GitHub Pages deployment
     * Gets the current status of a GitHub Pages deployment.
     *
     * The authenticated user must have read permission for the GitHub Pages site.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pagesDeploymentId The ID of the Pages deployment. You can also give the commit SHA of the deployment.
     * @returns pages_deployment_status Response
     * @throws ApiError
     */
    public static reposGetPagesDeployment(
        owner: string,
        repo: string,
        pagesDeploymentId: (number | string),
    ): CancelablePromise<pages_deployment_status> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'pages_deployment_id': pagesDeploymentId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Cancel a GitHub Pages deployment
     * Cancels a GitHub Pages deployment.
     *
     * The authenticated user must have write permissions for the GitHub Pages site.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param pagesDeploymentId The ID of the Pages deployment. You can also give the commit SHA of the deployment.
     * @returns void
     * @throws ApiError
     */
    public static reposCancelPagesDeployment(
        owner: string,
        repo: string,
        pagesDeploymentId: (number | string),
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel',
            path: {
                'owner': owner,
                'repo': repo,
                'pages_deployment_id': pagesDeploymentId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a DNS health check for GitHub Pages
     * Gets a health check of the DNS settings for the `CNAME` record configured for a repository's GitHub Pages.
     *
     * The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous background task to get the results for the domain. After the background task completes, subsequent requests to this endpoint return a `200 OK` status with the health check results in the response.
     *
     * The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission to use this endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns pages_health_check Response
     * @returns empty_object Empty response
     * @throws ApiError
     */
    public static reposGetPagesHealthCheck(
        owner: string,
        repo: string,
    ): CancelablePromise<pages_health_check | empty_object> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/pages/health',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                400: `Custom domains are not available for GitHub Pages`,
                404: `Resource not found`,
                422: `There isn't a CNAME for this page`,
            },
        });
    }
    /**
     * Check if private vulnerability reporting is enabled for a repository
     * Returns a boolean indicating whether or not private vulnerability reporting is enabled for the repository. For more information, see "[Evaluating the security settings of a repository](https://docs.github.com/code-security/security-advisories/working-with-repository-security-advisories/evaluating-the-security-settings-of-a-repository)".
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns any Private vulnerability reporting status
     * @throws ApiError
     */
    public static reposCheckPrivateVulnerabilityReporting(
        owner: string,
        repo: string,
    ): CancelablePromise<{
        /**
         * Whether or not private vulnerability reporting is enabled for the repository.
         */
        enabled: boolean;
    }> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/private-vulnerability-reporting',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                422: `Bad Request`,
            },
        });
    }
    /**
     * Enable private vulnerability reporting for a repository
     * Enables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposEnablePrivateVulnerabilityReporting(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/private-vulnerability-reporting',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                422: `Bad Request`,
            },
        });
    }
    /**
     * Disable private vulnerability reporting for a repository
     * Disables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)".
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposDisablePrivateVulnerabilityReporting(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/private-vulnerability-reporting',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                422: `Bad Request`,
            },
        });
    }
    /**
     * Get all custom property values for a repository
     * Gets all custom property values that are set for a repository.
     * Users with read access to the repository can use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns custom_property_value Response
     * @throws ApiError
     */
    public static reposCustomPropertiesForReposGetRepositoryValues(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<custom_property_value>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/properties/values',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create or update custom property values for a repository
     * Create new or update existing custom property values for a repository.
     * Using a value of `null` for a custom property will remove or 'unset' the property value from the repository.
     *
     * Repository admins and other users with the repository-level "edit custom property values" fine-grained permission can use this endpoint.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static reposCustomPropertiesForReposCreateOrUpdateRepositoryValues(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * A list of custom property names and associated values to apply to the repositories.
             */
            properties: Array<custom_property_value>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/properties/values',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a repository README
     * Gets the preferred README for a repository.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
     * - **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param ref The name of the commit/branch/tag. Default: the repositorys default branch.
     * @returns content_file Response
     * @throws ApiError
     */
    public static reposGetReadme(
        owner: string,
        repo: string,
        ref?: string,
    ): CancelablePromise<content_file> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/readme',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'ref': ref,
            },
            errors: {
                304: `Not modified`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a repository README for a directory
     * Gets the README from a repository directory.
     *
     * This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
     *
     * - **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
     * - **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param dir The alternate path to look for a README file
     * @param ref The name of the commit/branch/tag. Default: the repositorys default branch.
     * @returns content_file Response
     * @throws ApiError
     */
    public static reposGetReadmeInDirectory(
        owner: string,
        repo: string,
        dir: string,
        ref?: string,
    ): CancelablePromise<content_file> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/readme/{dir}',
            path: {
                'owner': owner,
                'repo': repo,
                'dir': dir,
            },
            query: {
                'ref': ref,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List releases
     * This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/repos/repos#list-repository-tags).
     *
     * Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns release Response
     * @throws ApiError
     */
    public static reposListReleases(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<release>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/releases',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a release
     * Users with push access to the repository can create a release.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns release Response
     * @throws ApiError
     */
    public static reposCreateRelease(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The name of the tag.
             */
            tag_name: string;
            /**
             * Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
             */
            target_commitish?: string;
            /**
             * The name of the release.
             */
            name?: string;
            /**
             * Text describing the contents of the tag.
             */
            body?: string;
            /**
             * `true` to create a draft (unpublished) release, `false` to create a published one.
             */
            draft?: boolean;
            /**
             * `true` to identify the release as a prerelease. `false` to identify the release as a full release.
             */
            prerelease?: boolean;
            /**
             * If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."
             */
            discussion_category_name?: string;
            /**
             * Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.
             */
            generate_release_notes?: boolean;
            /**
             * Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
             */
            make_latest?: 'true' | 'false' | 'legacy';
        },
    ): CancelablePromise<release> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/releases',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Not Found if the discussion category name is invalid`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a release asset
     * To download the asset's binary content:
     *
     * - If within a browser, fetch the location specified in the `browser_download_url` key provided in the response.
     * - Alternatively, set the `Accept` header of the request to
     * [`application/octet-stream`](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).
     * The API will either redirect the client to the location, or stream it directly if possible.
     * API clients should handle both a `200` or `302` response.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param assetId The unique identifier of the asset.
     * @returns release_asset Response
     * @throws ApiError
     */
    public static reposGetReleaseAsset(
        owner: string,
        repo: string,
        assetId: number,
    ): CancelablePromise<release_asset> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/releases/assets/{asset_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'asset_id': assetId,
            },
            errors: {
                302: `Found`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Update a release asset
     * Users with push access to the repository can edit a release asset.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param assetId The unique identifier of the asset.
     * @param requestBody
     * @returns release_asset Response
     * @throws ApiError
     */
    public static reposUpdateReleaseAsset(
        owner: string,
        repo: string,
        assetId: number,
        requestBody?: {
            /**
             * The file name of the asset.
             */
            name?: string;
            /**
             * An alternate short description of the asset. Used in place of the filename.
             */
            label?: string;
            state?: string;
        },
    ): CancelablePromise<release_asset> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/releases/assets/{asset_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'asset_id': assetId,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete a release asset
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param assetId The unique identifier of the asset.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteReleaseAsset(
        owner: string,
        repo: string,
        assetId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/releases/assets/{asset_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'asset_id': assetId,
            },
        });
    }
    /**
     * Generate release notes content for a release
     * Generate a name and body describing a [release](https://docs.github.com/rest/releases/releases#get-a-release). The body content will be markdown formatted and contain information like the changes since last release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns release_notes_content Name and body of generated release notes
     * @throws ApiError
     */
    public static reposGenerateReleaseNotes(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The tag name for the release. This can be an existing tag or a new one.
             */
            tag_name: string;
            /**
             * Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists.
             */
            target_commitish?: string;
            /**
             * The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.
             */
            previous_tag_name?: string;
            /**
             * Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used.
             */
            configuration_file_path?: string;
        },
    ): CancelablePromise<release_notes_content> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/releases/generate-notes',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get the latest release
     * View the latest published full release for the repository.
     *
     * The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns release Response
     * @throws ApiError
     */
    public static reposGetLatestRelease(
        owner: string,
        repo: string,
    ): CancelablePromise<release> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/releases/latest',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Get a release by tag name
     * Get a published release with the specified tag.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param tag tag parameter
     * @returns release Response
     * @throws ApiError
     */
    public static reposGetReleaseByTag(
        owner: string,
        repo: string,
        tag: string,
    ): CancelablePromise<release> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/releases/tags/{tag}',
            path: {
                'owner': owner,
                'repo': repo,
                'tag': tag,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a release
     * Gets a public release with the specified release ID.
     *
     * > [!NOTE]
     * > This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param releaseId The unique identifier of the release.
     * @returns release **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
     * @throws ApiError
     */
    public static reposGetRelease(
        owner: string,
        repo: string,
        releaseId: number,
    ): CancelablePromise<release> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/releases/{release_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'release_id': releaseId,
            },
            errors: {
                401: `Unauthorized`,
            },
        });
    }
    /**
     * Update a release
     * Users with push access to the repository can edit a release.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param releaseId The unique identifier of the release.
     * @param requestBody
     * @returns release Response
     * @throws ApiError
     */
    public static reposUpdateRelease(
        owner: string,
        repo: string,
        releaseId: number,
        requestBody?: {
            /**
             * The name of the tag.
             */
            tag_name?: string;
            /**
             * Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
             */
            target_commitish?: string;
            /**
             * The name of the release.
             */
            name?: string;
            /**
             * Text describing the contents of the tag.
             */
            body?: string;
            /**
             * `true` makes the release a draft, and `false` publishes the release.
             */
            draft?: boolean;
            /**
             * `true` to identify the release as a prerelease, `false` to identify the release as a full release.
             */
            prerelease?: boolean;
            /**
             * Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
             */
            make_latest?: 'true' | 'false' | 'legacy';
            /**
             * If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."
             */
            discussion_category_name?: string;
        },
    ): CancelablePromise<release> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/repos/{owner}/{repo}/releases/{release_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'release_id': releaseId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Not Found if the discussion category name is invalid`,
            },
        });
    }
    /**
     * Delete a release
     * Users with push access to the repository can delete a release.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param releaseId The unique identifier of the release.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteRelease(
        owner: string,
        repo: string,
        releaseId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/releases/{release_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'release_id': releaseId,
            },
        });
    }
    /**
     * List release assets
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param releaseId The unique identifier of the release.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns release_asset Response
     * @throws ApiError
     */
    public static reposListReleaseAssets(
        owner: string,
        repo: string,
        releaseId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<release_asset>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/releases/{release_id}/assets',
            path: {
                'owner': owner,
                'repo': repo,
                'release_id': releaseId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Upload a release asset
     * This endpoint makes use of a [Hypermedia relation](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the `upload_url` returned in
     * the response of the [Create a release endpoint](https://docs.github.com/rest/releases/releases#create-a-release) to upload a release asset.
     *
     * You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.
     *
     * Most libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:
     *
     * `application/zip`
     *
     * GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
     * you'll still need to pass your authentication to be able to upload an asset.
     *
     * When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`. It can be safely deleted.
     *
     * **Notes:**
     * *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The "[List release assets](https://docs.github.com/rest/releases/assets#list-release-assets)"
     * endpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
     * *   To find the `release_id` query the [`GET /repos/{owner}/{repo}/releases/latest` endpoint](https://docs.github.com/rest/releases/releases#get-the-latest-release).
     * *   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param releaseId The unique identifier of the release.
     * @param name
     * @param label
     * @param requestBody
     * @returns release_asset Response for successful upload
     * @throws ApiError
     */
    public static reposUploadReleaseAsset(
        owner: string,
        repo: string,
        releaseId: number,
        name: string,
        label?: string,
        requestBody?: Blob,
    ): CancelablePromise<release_asset> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/releases/{release_id}/assets',
            path: {
                'owner': owner,
                'repo': repo,
                'release_id': releaseId,
            },
            query: {
                'name': name,
                'label': label,
            },
            body: requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                422: `Response if you upload an asset with the same filename as another uploaded asset`,
            },
        });
    }
    /**
     * Get rules for a branch
     * Returns all active rules that apply to the specified branch. The branch does not need to exist; rules that would apply
     * to a branch with that name will be returned. All active rules that apply will be returned, regardless of the level
     * at which they are configured (e.g. repository or organization). Rules in rulesets with "evaluate" or "disabled"
     * enforcement statuses are not returned.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param branch The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns repository_rule_detailed Response
     * @throws ApiError
     */
    public static reposGetBranchRules(
        owner: string,
        repo: string,
        branch: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<repository_rule_detailed>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/rules/branches/{branch}',
            path: {
                'owner': owner,
                'repo': repo,
                'branch': branch,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get all repository rulesets
     * Get all the rulesets for a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param includesParents Include rulesets configured at higher levels that apply to this repository
     * @param targets A comma-separated list of rule targets to filter by.
     * If provided, only rulesets that apply to the specified targets will be returned.
     * For example, `branch,tag,push`.
     *
     * @returns repository_ruleset Response
     * @throws ApiError
     */
    public static reposGetRepoRulesets(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
        includesParents: boolean = true,
        targets?: string,
    ): CancelablePromise<Array<repository_ruleset>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/rulesets',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
                'includes_parents': includesParents,
                'targets': targets,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Create a repository ruleset
     * Create a ruleset for a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody Request body
     * @returns repository_ruleset Response
     * @throws ApiError
     */
    public static reposCreateRepoRuleset(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The name of the ruleset.
             */
            name: string;
            /**
             * The target of the ruleset
             */
            target?: 'branch' | 'tag' | 'push';
            enforcement: repository_rule_enforcement;
            /**
             * The actors that can bypass the rules in this ruleset
             */
            bypass_actors?: Array<repository_ruleset_bypass_actor>;
            conditions?: repository_ruleset_conditions;
            /**
             * An array of rules within the ruleset.
             */
            rules?: Array<repository_rule>;
        },
    ): CancelablePromise<repository_ruleset> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/rulesets',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * List repository rule suites
     * Lists suites of rule evaluations at the repository level.
     * For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param ref The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
     * @param timePeriod The time period to filter by.
     *
     * For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for rule suites that occurred in the past 7 days (168 hours).
     * @param actorName The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
     * @param ruleSuiteResult The rule suite results to filter on. When specified, only suites with this result will be returned.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns rule_suites Response
     * @throws ApiError
     */
    public static reposGetRepoRuleSuites(
        owner: string,
        repo: string,
        ref?: string,
        timePeriod: 'hour' | 'day' | 'week' | 'month' = 'day',
        actorName?: string,
        ruleSuiteResult: 'pass' | 'fail' | 'bypass' | 'all' = 'all',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<rule_suites> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/rulesets/rule-suites',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'ref': ref,
                'time_period': timePeriod,
                'actor_name': actorName,
                'rule_suite_result': ruleSuiteResult,
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get a repository rule suite
     * Gets information about a suite of rule evaluations from within a repository.
     * For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param ruleSuiteId The unique identifier of the rule suite result.
     * To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)
     * for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)
     * for organizations.
     * @returns rule_suite Response
     * @throws ApiError
     */
    public static reposGetRepoRuleSuite(
        owner: string,
        repo: string,
        ruleSuiteId: number,
    ): CancelablePromise<rule_suite> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'rule_suite_id': ruleSuiteId,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get a repository ruleset
     * Get a ruleset for a repository.
     *
     * **Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
     * making the API request has write access to the ruleset.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @param includesParents Include rulesets configured at higher levels that apply to this repository
     * @returns repository_ruleset Response
     * @throws ApiError
     */
    public static reposGetRepoRuleset(
        owner: string,
        repo: string,
        rulesetId: number,
        includesParents: boolean = true,
    ): CancelablePromise<repository_ruleset> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/rulesets/{ruleset_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'ruleset_id': rulesetId,
            },
            query: {
                'includes_parents': includesParents,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Update a repository ruleset
     * Update a ruleset for a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @param requestBody Request body
     * @returns repository_ruleset Response
     * @throws ApiError
     */
    public static reposUpdateRepoRuleset(
        owner: string,
        repo: string,
        rulesetId: number,
        requestBody?: {
            /**
             * The name of the ruleset.
             */
            name?: string;
            /**
             * The target of the ruleset
             */
            target?: 'branch' | 'tag' | 'push';
            enforcement?: repository_rule_enforcement;
            /**
             * The actors that can bypass the rules in this ruleset
             */
            bypass_actors?: Array<repository_ruleset_bypass_actor>;
            conditions?: repository_ruleset_conditions;
            /**
             * An array of rules within the ruleset.
             */
            rules?: Array<repository_rule>;
        },
    ): CancelablePromise<repository_ruleset> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/rulesets/{ruleset_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'ruleset_id': rulesetId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Delete a repository ruleset
     * Delete a ruleset for a repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteRepoRuleset(
        owner: string,
        repo: string,
        rulesetId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/rulesets/{ruleset_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'ruleset_id': rulesetId,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get repository ruleset history
     * Get the history of a repository ruleset.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns ruleset_version Response
     * @throws ApiError
     */
    public static reposGetRepoRulesetHistory(
        owner: string,
        repo: string,
        rulesetId: number,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<ruleset_version>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/rulesets/{ruleset_id}/history',
            path: {
                'owner': owner,
                'repo': repo,
                'ruleset_id': rulesetId,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get repository ruleset version
     * Get a version of a repository ruleset.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param rulesetId The ID of the ruleset.
     * @param versionId The ID of the version
     * @returns ruleset_version_with_state Response
     * @throws ApiError
     */
    public static reposGetRepoRulesetVersion(
        owner: string,
        repo: string,
        rulesetId: number,
        versionId: number,
    ): CancelablePromise<ruleset_version_with_state> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'ruleset_id': rulesetId,
                'version_id': versionId,
            },
            errors: {
                404: `Resource not found`,
                500: `Internal Error`,
            },
        });
    }
    /**
     * Get the weekly commit activity
     * Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
     *
     * > [!NOTE]
     * > This endpoint can only be used for repositories with fewer than 10,000 commits. If the repository contains 10,000 or more commits, a 422 status code will be returned.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns code_frequency_stat Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
     * @returns any Accepted
     * @throws ApiError
     */
    public static reposGetCodeFrequencyStats(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<code_frequency_stat> | Record<string, any>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/stats/code_frequency',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                422: `Repository contains more than 10,000 commits`,
            },
        });
    }
    /**
     * Get the last year of commit activity
     * Returns the last year of commit activity grouped by week. The `days` array is a group of commits per day, starting on `Sunday`.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns commit_activity Response
     * @returns any Accepted
     * @throws ApiError
     */
    public static reposGetCommitActivityStats(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<commit_activity> | Record<string, any>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/stats/commit_activity',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Get all contributor commit activity
     *
     * Returns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:
     *
     * *   `w` - Start of the week, given as a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).
     * *   `a` - Number of additions
     * *   `d` - Number of deletions
     * *   `c` - Number of commits
     *
     * > [!NOTE]
     * > This endpoint will return `0` values for all addition and deletion counts in repositories with 10,000 or more commits.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns contributor_activity Response
     * @returns any Accepted
     * @throws ApiError
     */
    public static reposGetContributorsStats(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<contributor_activity> | Record<string, any>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/stats/contributors',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Get the weekly commit count
     * Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract `owner` from `all`.
     *
     * The array order is oldest week (index 0) to most recent week.
     *
     * The most recent week is seven days ago at UTC midnight to today at UTC midnight.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns participation_stats The array order is oldest week (index 0) to most recent week.
     * @throws ApiError
     */
    public static reposGetParticipationStats(
        owner: string,
        repo: string,
    ): CancelablePromise<participation_stats> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/stats/participation',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get the hourly commit count for each day
     * Each array contains the day number, hour number, and number of commits:
     *
     * *   `0-6`: Sunday - Saturday
     * *   `0-23`: Hour of day
     * *   Number of commits
     *
     * For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns code_frequency_stat For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
     * @throws ApiError
     */
    public static reposGetPunchCardStats(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<code_frequency_stat>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/stats/punch_card',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Create a commit status
     * Users with push access in a repository can create commit statuses for a given SHA.
     *
     * Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param sha
     * @param requestBody
     * @returns status Response
     * @throws ApiError
     */
    public static reposCreateCommitStatus(
        owner: string,
        repo: string,
        sha: string,
        requestBody: {
            /**
             * The state of the status.
             */
            state: 'error' | 'failure' | 'pending' | 'success';
            /**
             * The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.
             * For example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:
             * `http://ci.example.com/user/repo/build/sha`
             */
            target_url?: string | null;
            /**
             * A short description of the status.
             */
            description?: string | null;
            /**
             * A string label to differentiate this status from the status of other systems. This field is case-insensitive.
             */
            context?: string;
        },
    ): CancelablePromise<status> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/statuses/{sha}',
            path: {
                'owner': owner,
                'repo': repo,
                'sha': sha,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List repository tags
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns tag Response
     * @throws ApiError
     */
    public static reposListTags(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<tag>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/tags',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * @deprecated
     * Closing down - List tag protection states for a repository
     * > [!WARNING]
     * > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#get-all-repository-rulesets)" endpoint instead.
     *
     * This returns the tag protection states of a repository.
     *
     * This information is only available to repository administrators.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns tag_protection Response
     * @throws ApiError
     */
    public static reposListTagProtection(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<tag_protection>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/tags/protection',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * @deprecated
     * Closing down - Create a tag protection state for a repository
     * > [!WARNING]
     * > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#create-a-repository-ruleset)" endpoint instead.
     *
     * This creates a tag protection state for a repository.
     * This endpoint is only available to repository administrators.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns tag_protection Response
     * @throws ApiError
     */
    public static reposCreateTagProtection(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * An optional glob pattern to match against when enforcing tag protection.
             */
            pattern: string;
        },
    ): CancelablePromise<tag_protection> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/tags/protection',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * @deprecated
     * Closing down - Delete a tag protection state for a repository
     * > [!WARNING]
     * > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#delete-a-repository-ruleset)" endpoint instead.
     *
     * This deletes a tag protection state for a repository.
     * This endpoint is only available to repository administrators.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param tagProtectionId The unique identifier of the tag protection.
     * @returns void
     * @throws ApiError
     */
    public static reposDeleteTagProtection(
        owner: string,
        repo: string,
        tagProtectionId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/tags/protection/{tag_protection_id}',
            path: {
                'owner': owner,
                'repo': repo,
                'tag_protection_id': tagProtectionId,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Download a repository archive (tar)
     * Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the repositorys default branch (usually
     * `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
     * the `Location` header to make a second `GET` request.
     *
     * > [!NOTE]
     * > For private repositories, these links are temporary and expire after five minutes.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param ref
     * @returns void
     * @throws ApiError
     */
    public static reposDownloadTarballArchive(
        owner: string,
        repo: string,
        ref: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/tarball/{ref}',
            path: {
                'owner': owner,
                'repo': repo,
                'ref': ref,
            },
            errors: {
                302: `Response`,
            },
        });
    }
    /**
     * List repository teams
     * Lists the teams that have access to the specified repository and that are also visible to the authenticated user.
     *
     * For a public repository, a team is listed only if that team added the public repository explicitly.
     *
     * OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to use this endpoint with a public repository, and `repo` scope to use this endpoint with a private repository.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns team Response
     * @throws ApiError
     */
    public static reposListTeams(
        owner: string,
        repo: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<team>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/teams',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get all repository topics
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns topic Response
     * @throws ApiError
     */
    public static reposGetAllTopics(
        owner: string,
        repo: string,
        page: number = 1,
        perPage: number = 30,
    ): CancelablePromise<topic> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/topics',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'page': page,
                'per_page': perPage,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Replace all repository topics
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns topic Response
     * @throws ApiError
     */
    public static reposReplaceAllTopics(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` will be saved as lowercase.
             */
            names: Array<string>;
        },
    ): CancelablePromise<topic> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/topics',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get repository clones
     * Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param per The time frame to display results for.
     * @returns clone_traffic Response
     * @returns any Accepted
     * @throws ApiError
     */
    public static reposGetClones(
        owner: string,
        repo: string,
        per: 'day' | 'week' = 'day',
    ): CancelablePromise<clone_traffic | Record<string, any>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/traffic/clones',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per': per,
            },
            errors: {
                403: `Forbidden`,
            },
        });
    }
    /**
     * Get top referral paths
     * Get the top 10 popular contents over the last 14 days.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns content_traffic Response
     * @returns any Accepted
     * @throws ApiError
     */
    public static reposGetTopPaths(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<content_traffic> | Record<string, any>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/traffic/popular/paths',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                403: `Forbidden`,
            },
        });
    }
    /**
     * Get top referral sources
     * Get the top 10 referrers over the last 14 days.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns referrer_traffic Response
     * @returns any Accepted
     * @throws ApiError
     */
    public static reposGetTopReferrers(
        owner: string,
        repo: string,
    ): CancelablePromise<Array<referrer_traffic> | Record<string, any>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/traffic/popular/referrers',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                403: `Forbidden`,
            },
        });
    }
    /**
     * Get page views
     * Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param per The time frame to display results for.
     * @returns view_traffic Response
     * @returns any Accepted
     * @throws ApiError
     */
    public static reposGetViews(
        owner: string,
        repo: string,
        per: 'day' | 'week' = 'day',
    ): CancelablePromise<view_traffic | Record<string, any>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/traffic/views',
            path: {
                'owner': owner,
                'repo': repo,
            },
            query: {
                'per': per,
            },
            errors: {
                403: `Forbidden`,
            },
        });
    }
    /**
     * Transfer a repository
     * A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://docs.github.com/articles/about-repository-transfers/).
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns minimal_repository Response
     * @throws ApiError
     */
    public static reposTransfer(
        owner: string,
        repo: string,
        requestBody: {
            /**
             * The username or organization name the repository will be transferred to.
             */
            new_owner: string;
            /**
             * The new name to be given to the repository.
             */
            new_name?: string;
            /**
             * ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
             */
            team_ids?: Array<number>;
        },
    ): CancelablePromise<minimal_repository> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{owner}/{repo}/transfer',
            path: {
                'owner': owner,
                'repo': repo,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Check if vulnerability alerts are enabled for a repository
     * Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin read access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposCheckVulnerabilityAlerts(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/vulnerability-alerts',
            path: {
                'owner': owner,
                'repo': repo,
            },
            errors: {
                404: `Not Found if repository is not enabled with vulnerability alerts`,
            },
        });
    }
    /**
     * Enable vulnerability alerts
     * Enables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposEnableVulnerabilityAlerts(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/repos/{owner}/{repo}/vulnerability-alerts',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Disable vulnerability alerts
     * Disables dependency alerts and the dependency graph for a repository.
     * The authenticated user must have admin access to the repository. For more information,
     * see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @returns void
     * @throws ApiError
     */
    public static reposDisableVulnerabilityAlerts(
        owner: string,
        repo: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/repos/{owner}/{repo}/vulnerability-alerts',
            path: {
                'owner': owner,
                'repo': repo,
            },
        });
    }
    /**
     * Download a repository archive (zip)
     * Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the repositorys default branch (usually
     * `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
     * the `Location` header to make a second `GET` request.
     *
     * > [!NOTE]
     * > For private repositories, these links are temporary and expire after five minutes. If the repository is empty, you will receive a 404 when you follow the redirect.
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository without the `.git` extension. The name is not case sensitive.
     * @param ref
     * @returns void
     * @throws ApiError
     */
    public static reposDownloadZipballArchive(
        owner: string,
        repo: string,
        ref: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repos/{owner}/{repo}/zipball/{ref}',
            path: {
                'owner': owner,
                'repo': repo,
                'ref': ref,
            },
            errors: {
                302: `Response`,
            },
        });
    }
    /**
     * Create a repository using a template
     * Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. If the repository is not public, the authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/repos/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.
     *
     * OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
     * @param templateOwner The account owner of the template repository. The name is not case sensitive.
     * @param templateRepo The name of the template repository without the `.git` extension. The name is not case sensitive.
     * @param requestBody
     * @returns full_repository Response
     * @throws ApiError
     */
    public static reposCreateUsingTemplate(
        templateOwner: string,
        templateRepo: string,
        requestBody: {
            /**
             * The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.
             */
            owner?: string;
            /**
             * The name of the new repository.
             */
            name: string;
            /**
             * A short description of the new repository.
             */
            description?: string;
            /**
             * Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.
             */
            include_all_branches?: boolean;
            /**
             * Either `true` to create a new private repository or `false` to create a new public one.
             */
            private?: boolean;
        },
    ): CancelablePromise<full_repository> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/repos/{template_owner}/{template_repo}/generate',
            path: {
                'template_owner': templateOwner,
                'template_repo': templateRepo,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * List public repositories
     * Lists all public repositories in the order that they were created.
     *
     * Note:
     * - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
     * - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of repositories.
     * @param since A repository ID. Only return repositories with an ID greater than this ID.
     * @returns minimal_repository Response
     * @throws ApiError
     */
    public static reposListPublic(
        since?: number,
    ): CancelablePromise<Array<minimal_repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/repositories',
            query: {
                'since': since,
            },
            errors: {
                304: `Not modified`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List repositories for the authenticated user
     * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
     *
     * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
     * @param visibility Limit results to repositories with the specified visibility.
     * @param affiliation Comma-separated list of values. Can include:
     * * `owner`: Repositories that are owned by the authenticated user.
     * * `collaborator`: Repositories that the user has been added to as a collaborator.
     * * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.
     * @param type Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
     * @param sort The property to sort the results by.
     * @param direction The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param since Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @param before Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * @returns repository Response
     * @throws ApiError
     */
    public static reposListForAuthenticatedUser(
        visibility: 'all' | 'public' | 'private' = 'all',
        affiliation: string = 'owner,collaborator,organization_member',
        type: 'all' | 'owner' | 'public' | 'private' | 'member' = 'all',
        sort: 'created' | 'updated' | 'pushed' | 'full_name' = 'full_name',
        direction?: 'asc' | 'desc',
        perPage: number = 30,
        page: number = 1,
        since?: string,
        before?: string,
    ): CancelablePromise<Array<repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/repos',
            query: {
                'visibility': visibility,
                'affiliation': affiliation,
                'type': type,
                'sort': sort,
                'direction': direction,
                'per_page': perPage,
                'page': page,
                'since': since,
                'before': before,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Create a repository for the authenticated user
     * Creates a new repository for the authenticated user.
     *
     * OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
     * @param requestBody
     * @returns full_repository Response
     * @throws ApiError
     */
    public static reposCreateForAuthenticatedUser(
        requestBody: {
            /**
             * The name of the repository.
             */
            name: string;
            /**
             * A short description of the repository.
             */
            description?: string;
            /**
             * A URL with more information about the repository.
             */
            homepage?: string;
            /**
             * Whether the repository is private.
             */
            private?: boolean;
            /**
             * Whether issues are enabled.
             */
            has_issues?: boolean;
            /**
             * Whether projects are enabled.
             */
            has_projects?: boolean;
            /**
             * Whether the wiki is enabled.
             */
            has_wiki?: boolean;
            /**
             * Whether discussions are enabled.
             */
            has_discussions?: boolean;
            /**
             * The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
             */
            team_id?: number;
            /**
             * Whether the repository is initialized with a minimal README.
             */
            auto_init?: boolean;
            /**
             * The desired language or platform to apply to the .gitignore.
             */
            gitignore_template?: string;
            /**
             * The license keyword of the open source license for this repository.
             */
            license_template?: string;
            /**
             * Whether to allow squash merges for pull requests.
             */
            allow_squash_merge?: boolean;
            /**
             * Whether to allow merge commits for pull requests.
             */
            allow_merge_commit?: boolean;
            /**
             * Whether to allow rebase merges for pull requests.
             */
            allow_rebase_merge?: boolean;
            /**
             * Whether to allow Auto-merge to be used on pull requests.
             */
            allow_auto_merge?: boolean;
            /**
             * Whether to delete head branches when pull requests are merged
             */
            delete_branch_on_merge?: boolean;
            /**
             * Required when using `squash_merge_commit_message`.
             *
             * The default value for a squash merge commit title:
             *
             * - `PR_TITLE` - default to the pull request's title.
             * - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
             */
            squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
            /**
             * The default value for a squash merge commit message:
             *
             * - `PR_BODY` - default to the pull request's body.
             * - `COMMIT_MESSAGES` - default to the branch's commit messages.
             * - `BLANK` - default to a blank commit message.
             */
            squash_merge_commit_message?: 'PR_BODY' | 'COMMIT_MESSAGES' | 'BLANK';
            /**
             * Required when using `merge_commit_message`.
             *
             * The default value for a merge commit title.
             *
             * - `PR_TITLE` - default to the pull request's title.
             * - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
             */
            merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
            /**
             * The default value for a merge commit message.
             *
             * - `PR_TITLE` - default to the pull request's title.
             * - `PR_BODY` - default to the pull request's body.
             * - `BLANK` - default to a blank commit message.
             */
            merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
            /**
             * Whether downloads are enabled.
             */
            has_downloads?: boolean;
            /**
             * Whether this repository acts as a template that can be used to generate new repositories.
             */
            is_template?: boolean;
        },
    ): CancelablePromise<full_repository> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/user/repos',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                400: `Bad Request`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List repository invitations for the authenticated user
     * When authenticating as a user, this endpoint will list all currently open repository invitations for that user.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns repository_invitation Response
     * @throws ApiError
     */
    public static reposListInvitationsForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<repository_invitation>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/repository_invitations',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Accept a repository invitation
     * @param invitationId The unique identifier of the invitation.
     * @returns void
     * @throws ApiError
     */
    public static reposAcceptInvitationForAuthenticatedUser(
        invitationId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/user/repository_invitations/{invitation_id}',
            path: {
                'invitation_id': invitationId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
                409: `Conflict`,
            },
        });
    }
    /**
     * Decline a repository invitation
     * @param invitationId The unique identifier of the invitation.
     * @returns void
     * @throws ApiError
     */
    public static reposDeclineInvitationForAuthenticatedUser(
        invitationId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/user/repository_invitations/{invitation_id}',
            path: {
                'invitation_id': invitationId,
            },
            errors: {
                304: `Not modified`,
                403: `Forbidden`,
                404: `Resource not found`,
                409: `Conflict`,
            },
        });
    }
    /**
     * List repositories for a user
     * Lists public repositories for the specified user.
     * @param username The handle for the GitHub user account.
     * @param type Limit results to repositories of the specified type.
     * @param sort The property to sort the results by.
     * @param direction The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns minimal_repository Response
     * @throws ApiError
     */
    public static reposListForUser(
        username: string,
        type: 'all' | 'owner' | 'member' = 'owner',
        sort: 'created' | 'updated' | 'pushed' | 'full_name' = 'full_name',
        direction?: 'asc' | 'desc',
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<minimal_repository>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/repos',
            path: {
                'username': username,
            },
            query: {
                'type': type,
                'sort': sort,
                'direction': direction,
                'per_page': perPage,
                'page': page,
            },
        });
    }
}

// From: UsersService.ts
export class UsersService {
    /**
     * Get the authenticated user
     * OAuth app tokens and personal access tokens (classic) need the `user` scope in order for the response to include private profile information.
     * @returns any Response
     * @throws ApiError
     */
    public static usersGetAuthenticated(): CancelablePromise<(private_user | public_user)> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Update the authenticated user
     * **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
     * @param requestBody
     * @returns private_user Response
     * @throws ApiError
     */
    public static usersUpdateAuthenticated(
        requestBody?: {
            /**
             * The new name of the user.
             */
            name?: string;
            /**
             * The publicly visible email address of the user.
             */
            email?: string;
            /**
             * The new blog URL of the user.
             */
            blog?: string;
            /**
             * The new Twitter username of the user.
             */
            twitter_username?: string | null;
            /**
             * The new company of the user.
             */
            company?: string;
            /**
             * The new location of the user.
             */
            location?: string;
            /**
             * The new hiring availability of the user.
             */
            hireable?: boolean;
            /**
             * The new short biography of the user.
             */
            bio?: string;
        },
    ): CancelablePromise<private_user> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/user',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List users blocked by the authenticated user
     * List the users you've blocked on your personal account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static usersListBlockedByAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/blocks',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Check if a user is blocked by the authenticated user
     * Returns a 204 if the given user is blocked by the authenticated user. Returns a 404 if the given user is not blocked by the authenticated user, or if the given user account has been identified as spam by GitHub.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static usersCheckBlocked(
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/blocks/{username}',
            path: {
                'username': username,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `If the user is not blocked`,
            },
        });
    }
    /**
     * Block a user
     * Blocks the given user and returns a 204. If the authenticated user cannot block the given user a 422 is returned.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static usersBlock(
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/user/blocks/{username}',
            path: {
                'username': username,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Unblock a user
     * Unblocks the given user and returns a 204.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static usersUnblock(
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/user/blocks/{username}',
            path: {
                'username': username,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Set primary email visibility for the authenticated user
     * Sets the visibility for your primary email addresses.
     * @param requestBody
     * @returns email Response
     * @throws ApiError
     */
    public static usersSetPrimaryEmailVisibilityForAuthenticatedUser(
        requestBody: {
            /**
             * Denotes whether an email is publicly visible.
             */
            visibility: 'public' | 'private';
        },
    ): CancelablePromise<Array<email>> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/user/email/visibility',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List email addresses for the authenticated user
     * Lists all of your email addresses, and specifies which one is visible
     * to the public.
     *
     * OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns email Response
     * @throws ApiError
     */
    public static usersListEmailsForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<email>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/emails',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Add an email address for the authenticated user
     * OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
     * @param requestBody
     * @returns email Response
     * @throws ApiError
     */
    public static usersAddEmailForAuthenticatedUser(
        requestBody?: ({
            /**
             * Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.
             */
            emails: Array<string>;
        } | Array<string> | string),
    ): CancelablePromise<Array<email>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/user/emails',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete an email address for the authenticated user
     * OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static usersDeleteEmailForAuthenticatedUser(
        requestBody?: ({
            /**
             * Email addresses associated with the GitHub user account.
             */
            emails: Array<string>;
        } | Array<string> | string),
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/user/emails',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List followers of the authenticated user
     * Lists the people following the authenticated user.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static usersListFollowersForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/followers',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * List the people the authenticated user follows
     * Lists the people who the authenticated user follows.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static usersListFollowedByAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/following',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
            },
        });
    }
    /**
     * Check if a person is followed by the authenticated user
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static usersCheckPersonIsFollowedByAuthenticated(
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/following/{username}',
            path: {
                'username': username,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `if the person is not followed by the authenticated user`,
            },
        });
    }
    /**
     * Follow a user
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
     *
     * OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static usersFollow(
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/user/following/{username}',
            path: {
                'username': username,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Unfollow a user
     * OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
     * @param username The handle for the GitHub user account.
     * @returns void
     * @throws ApiError
     */
    public static usersUnfollow(
        username: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/user/following/{username}',
            path: {
                'username': username,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List GPG keys for the authenticated user
     * Lists the current user's GPG keys.
     *
     * OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns gpg_key Response
     * @throws ApiError
     */
    public static usersListGpgKeysForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<gpg_key>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/gpg_keys',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a GPG key for the authenticated user
     * Adds a GPG key to the authenticated user's GitHub account.
     *
     * OAuth app tokens and personal access tokens (classic) need the `write:gpg_key` scope to use this endpoint.
     * @param requestBody
     * @returns gpg_key Response
     * @throws ApiError
     */
    public static usersCreateGpgKeyForAuthenticatedUser(
        requestBody: {
            /**
             * A descriptive name for the new key.
             */
            name?: string;
            /**
             * A GPG key in ASCII-armored format.
             */
            armored_public_key: string;
        },
    ): CancelablePromise<gpg_key> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/user/gpg_keys',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a GPG key for the authenticated user
     * View extended details for a single GPG key.
     *
     * OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
     * @param gpgKeyId The unique identifier of the GPG key.
     * @returns gpg_key Response
     * @throws ApiError
     */
    public static usersGetGpgKeyForAuthenticatedUser(
        gpgKeyId: number,
    ): CancelablePromise<gpg_key> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/gpg_keys/{gpg_key_id}',
            path: {
                'gpg_key_id': gpgKeyId,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete a GPG key for the authenticated user
     * Removes a GPG key from the authenticated user's GitHub account.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:gpg_key` scope to use this endpoint.
     * @param gpgKeyId The unique identifier of the GPG key.
     * @returns void
     * @throws ApiError
     */
    public static usersDeleteGpgKeyForAuthenticatedUser(
        gpgKeyId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/user/gpg_keys/{gpg_key_id}',
            path: {
                'gpg_key_id': gpgKeyId,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List public SSH keys for the authenticated user
     * Lists the public SSH keys for the authenticated user's GitHub account.
     *
     * OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns key Response
     * @throws ApiError
     */
    public static usersListPublicSshKeysForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<key>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/keys',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a public SSH key for the authenticated user
     * Adds a public SSH key to the authenticated user's GitHub account.
     *
     * OAuth app tokens and personal access tokens (classic) need the `write:public_key` scope to use this endpoint.
     * @param requestBody
     * @returns key Response
     * @throws ApiError
     */
    public static usersCreatePublicSshKeyForAuthenticatedUser(
        requestBody: {
            /**
             * A descriptive name for the new key.
             */
            title?: string;
            /**
             * The public SSH key to add to your GitHub account.
             */
            key: string;
        },
    ): CancelablePromise<key> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/user/keys',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get a public SSH key for the authenticated user
     * View extended details for a single public SSH key.
     *
     * OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
     * @param keyId The unique identifier of the key.
     * @returns key Response
     * @throws ApiError
     */
    public static usersGetPublicSshKeyForAuthenticatedUser(
        keyId: number,
    ): CancelablePromise<key> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/keys/{key_id}',
            path: {
                'key_id': keyId,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete a public SSH key for the authenticated user
     * Removes a public SSH key from the authenticated user's GitHub account.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:public_key` scope to use this endpoint.
     * @param keyId The unique identifier of the key.
     * @returns void
     * @throws ApiError
     */
    public static usersDeletePublicSshKeyForAuthenticatedUser(
        keyId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/user/keys/{key_id}',
            path: {
                'key_id': keyId,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List public email addresses for the authenticated user
     * Lists your publicly visible email address, which you can set with the
     * [Set primary email visibility for the authenticated user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user)
     * endpoint.
     *
     * OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns email Response
     * @throws ApiError
     */
    public static usersListPublicEmailsForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<email>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/public_emails',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List social accounts for the authenticated user
     * Lists all of your social accounts.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns social_account Response
     * @throws ApiError
     */
    public static usersListSocialAccountsForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<social_account>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/social_accounts',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Add social accounts for the authenticated user
     * Add one or more social accounts to the authenticated user's profile.
     *
     * OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
     * @param requestBody
     * @returns social_account Response
     * @throws ApiError
     */
    public static usersAddSocialAccountForAuthenticatedUser(
        requestBody: {
            /**
             * Full URLs for the social media profiles to add.
             */
            account_urls: Array<string>;
        },
    ): CancelablePromise<Array<social_account>> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/user/social_accounts',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Delete social accounts for the authenticated user
     * Deletes one or more social accounts from the authenticated user's profile.
     *
     * OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
     * @param requestBody
     * @returns void
     * @throws ApiError
     */
    public static usersDeleteSocialAccountForAuthenticatedUser(
        requestBody: {
            /**
             * Full URLs for the social media profiles to delete.
             */
            account_urls: Array<string>;
        },
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/user/social_accounts',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List SSH signing keys for the authenticated user
     * Lists the SSH signing keys for the authenticated user's GitHub account.
     *
     * OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns ssh_signing_key Response
     * @throws ApiError
     */
    public static usersListSshSigningKeysForAuthenticatedUser(
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<ssh_signing_key>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/ssh_signing_keys',
            query: {
                'per_page': perPage,
                'page': page,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Create a SSH signing key for the authenticated user
     * Creates an SSH signing key for the authenticated user's GitHub account.
     *
     * OAuth app tokens and personal access tokens (classic) need the `write:ssh_signing_key` scope to use this endpoint.
     * @param requestBody
     * @returns ssh_signing_key Response
     * @throws ApiError
     */
    public static usersCreateSshSigningKeyForAuthenticatedUser(
        requestBody: {
            /**
             * A descriptive name for the new key.
             */
            title?: string;
            /**
             * The public SSH key to add to your GitHub account. For more information, see "[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)."
             */
            key: string;
        },
    ): CancelablePromise<ssh_signing_key> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/user/ssh_signing_keys',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * Get an SSH signing key for the authenticated user
     * Gets extended details for an SSH signing key.
     *
     * OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
     * @param sshSigningKeyId The unique identifier of the SSH signing key.
     * @returns ssh_signing_key Response
     * @throws ApiError
     */
    public static usersGetSshSigningKeyForAuthenticatedUser(
        sshSigningKeyId: number,
    ): CancelablePromise<ssh_signing_key> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/ssh_signing_keys/{ssh_signing_key_id}',
            path: {
                'ssh_signing_key_id': sshSigningKeyId,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete an SSH signing key for the authenticated user
     * Deletes an SSH signing key from the authenticated user's GitHub account.
     *
     * OAuth app tokens and personal access tokens (classic) need the `admin:ssh_signing_key` scope to use this endpoint.
     * @param sshSigningKeyId The unique identifier of the SSH signing key.
     * @returns void
     * @throws ApiError
     */
    public static usersDeleteSshSigningKeyForAuthenticatedUser(
        sshSigningKeyId: number,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/user/ssh_signing_keys/{ssh_signing_key_id}',
            path: {
                'ssh_signing_key_id': sshSigningKeyId,
            },
            errors: {
                304: `Not modified`,
                401: `Requires authentication`,
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * Get a user using their ID
     * Provides publicly available information about someone with a GitHub account. This method takes their durable user `ID` instead of their `login`, which can change over time.
     *
     * If you are requesting information about an [Enterprise Managed User](https://docs.github.com/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises/about-enterprise-managed-users), or a GitHub App bot that is installed in an organization that uses Enterprise Managed Users, your requests must be authenticated as a user or GitHub App that has access to the organization to view that account's information. If you are not authorized, the request will return a `404 Not Found` status.
     *
     * The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).
     *
     * The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see [Emails API](https://docs.github.com/rest/users/emails).
     * @param accountId account_id parameter
     * @returns any Response
     * @throws ApiError
     */
    public static usersGetById(
        accountId: number,
    ): CancelablePromise<(private_user | public_user)> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/user/{account_id}',
            path: {
                'account_id': accountId,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List users
     * Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.
     *
     * Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of users.
     * @param since A user ID. Only return users with an ID greater than this ID.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static usersList(
        since?: number,
        perPage: number = 30,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users',
            query: {
                'since': since,
                'per_page': perPage,
            },
            errors: {
                304: `Not modified`,
            },
        });
    }
    /**
     * Get a user
     * Provides publicly available information about someone with a GitHub account.
     *
     * If you are requesting information about an [Enterprise Managed User](https://docs.github.com/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises/about-enterprise-managed-users), or a GitHub App bot that is installed in an organization that uses Enterprise Managed Users, your requests must be authenticated as a user or GitHub App that has access to the organization to view that account's information. If you are not authorized, the request will return a `404 Not Found` status.
     *
     * The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).
     *
     * The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see [Emails API](https://docs.github.com/rest/users/emails).
     * @param username The handle for the GitHub user account.
     * @returns any Response
     * @throws ApiError
     */
    public static usersGetByUsername(
        username: string,
    ): CancelablePromise<(private_user | public_user)> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}',
            path: {
                'username': username,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List attestations by bulk subject digests
     * List a collection of artifact attestations associated with any entry in a list of subject digests owned by a user.
     *
     * The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `attestations:read` permission is required.
     *
     * **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
     * @param username The handle for the GitHub user account.
     * @param requestBody
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param before A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param after A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns any Response
     * @throws ApiError
     */
    public static usersListAttestationsBulk(
        username: string,
        requestBody: {
            /**
             * List of subject digests to fetch attestations for.
             */
            subject_digests: Array<string>;
            /**
             * Optional filter for fetching attestations with a given predicate type.
             * This option accepts `provenance`, `sbom`, `release`, or freeform text
             * for custom predicate types.
             */
            predicate_type?: string;
        },
        perPage: number = 30,
        before?: string,
        after?: string,
    ): CancelablePromise<{
        /**
         * Mapping of subject digest to bundles.
         */
        attestations_subject_digests?: Record<string, Array<{
            /**
             * The bundle of the attestation.
             */
            bundle?: {
                mediaType?: string;
                verificationMaterial?: Record<string, any>;
                dsseEnvelope?: Record<string, any>;
            };
            repository_id?: number;
            bundle_url?: string;
        }> | null>;
        /**
         * Information about the current page.
         */
        page_info?: {
            /**
             * Indicates whether there is a next page.
             */
            has_next?: boolean;
            /**
             * Indicates whether there is a previous page.
             */
            has_previous?: boolean;
            /**
             * The cursor to the next page.
             */
            next?: string;
            /**
             * The cursor to the previous page.
             */
            previous?: string;
        };
    }> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/users/{username}/attestations/bulk-list',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'before': before,
                'after': after,
            },
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Delete attestations in bulk
     * Delete artifact attestations in bulk by either subject digests or unique ID.
     * @param username The handle for the GitHub user account.
     * @param requestBody
     * @returns any Response
     * @throws ApiError
     */
    public static usersDeleteAttestationsBulk(
        username: string,
        requestBody: any,
    ): CancelablePromise<any> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/users/{username}/attestations/delete-request',
            path: {
                'username': username,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete attestations by subject digest
     * Delete an artifact attestation by subject digest.
     * @param username The handle for the GitHub user account.
     * @param subjectDigest Subject Digest
     * @returns any Response
     * @throws ApiError
     */
    public static usersDeleteAttestationsBySubjectDigest(
        username: string,
        subjectDigest: string,
    ): CancelablePromise<any> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/users/{username}/attestations/digest/{subject_digest}',
            path: {
                'username': username,
                'subject_digest': subjectDigest,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * Delete attestations by ID
     * Delete an artifact attestation by unique ID that is associated with a repository owned by a user.
     * @param username The handle for the GitHub user account.
     * @param attestationId Attestation ID
     * @returns any Response
     * @throws ApiError
     */
    public static usersDeleteAttestationsById(
        username: string,
        attestationId: number,
    ): CancelablePromise<any> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/users/{username}/attestations/{attestation_id}',
            path: {
                'username': username,
                'attestation_id': attestationId,
            },
            errors: {
                403: `Forbidden`,
                404: `Resource not found`,
            },
        });
    }
    /**
     * List attestations
     * List a collection of artifact attestations with a given subject digest that are associated with repositories owned by a user.
     *
     * The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `attestations:read` permission is required.
     *
     * **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
     * @param username The handle for the GitHub user account.
     * @param subjectDigest Subject Digest
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param before A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param after A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param predicateType Optional filter for fetching attestations with a given predicate type.
     * This option accepts `provenance`, `sbom`, `release`, or freeform text
     * for custom predicate types.
     * @returns any Response
     * @returns empty_object Response
     * @throws ApiError
     */
    public static usersListAttestations(
        username: string,
        subjectDigest: string,
        perPage: number = 30,
        before?: string,
        after?: string,
        predicateType?: string,
    ): CancelablePromise<{
        attestations?: Array<{
            /**
             * The attestation's Sigstore Bundle.
             * Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.
             */
            bundle?: {
                mediaType?: string;
                verificationMaterial?: Record<string, any>;
                dsseEnvelope?: Record<string, any>;
            };
            repository_id?: number;
            bundle_url?: string;
            initiator?: string;
        }>;
    } | empty_object> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/attestations/{subject_digest}',
            path: {
                'username': username,
                'subject_digest': subjectDigest,
            },
            query: {
                'per_page': perPage,
                'before': before,
                'after': after,
                'predicate_type': predicateType,
            },
            errors: {
                404: `Resource not found`,
            },
        });
    }
    /**
     * List followers of a user
     * Lists the people following the specified user.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static usersListFollowersForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/followers',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List the people a user follows
     * Lists the people who the specified user follows.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns simple_user Response
     * @throws ApiError
     */
    public static usersListFollowingForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<simple_user>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/following',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Check if a user follows another user
     * @param username The handle for the GitHub user account.
     * @param targetUser
     * @returns void
     * @throws ApiError
     */
    public static usersCheckFollowingForUser(
        username: string,
        targetUser: string,
    ): CancelablePromise<void> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/following/{target_user}',
            path: {
                'username': username,
                'target_user': targetUser,
            },
            errors: {
                404: `if the user does not follow the target user`,
            },
        });
    }
    /**
     * List GPG keys for a user
     * Lists the GPG keys for a user. This information is accessible by anyone.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns gpg_key Response
     * @throws ApiError
     */
    public static usersListGpgKeysForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<gpg_key>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/gpg_keys',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * Get contextual information for a user
     * Provides hovercard information. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.
     *
     * The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository, you would use a `subject_type` value of `repository` and a `subject_id` value of `1300192` (the ID of the `Spoon-Knife` repository).
     *
     * OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
     * @param username The handle for the GitHub user account.
     * @param subjectType Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.
     * @param subjectId Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.
     * @returns hovercard Response
     * @throws ApiError
     */
    public static usersGetContextForUser(
        username: string,
        subjectType?: 'organization' | 'repository' | 'issue' | 'pull_request',
        subjectId?: string,
    ): CancelablePromise<hovercard> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/hovercard',
            path: {
                'username': username,
            },
            query: {
                'subject_type': subjectType,
                'subject_id': subjectId,
            },
            errors: {
                404: `Resource not found`,
                422: `Validation failed, or the endpoint has been spammed.`,
            },
        });
    }
    /**
     * List public keys for a user
     * Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns key_simple Response
     * @throws ApiError
     */
    public static usersListPublicKeysForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<key_simple>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/keys',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List social accounts for a user
     * Lists social media accounts for a user. This endpoint is accessible by anyone.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns social_account Response
     * @throws ApiError
     */
    public static usersListSocialAccountsForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<social_account>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/social_accounts',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
    /**
     * List SSH signing keys for a user
     * Lists the SSH signing keys for a user. This operation is accessible by anyone.
     * @param username The handle for the GitHub user account.
     * @param perPage The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @param page The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
     * @returns ssh_signing_key Response
     * @throws ApiError
     */
    public static usersListSshSigningKeysForUser(
        username: string,
        perPage: number = 30,
        page: number = 1,
    ): CancelablePromise<Array<ssh_signing_key>> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{username}/ssh_signing_keys',
            path: {
                'username': username,
            },
            query: {
                'per_page': perPage,
                'page': page,
            },
        });
    }
}

